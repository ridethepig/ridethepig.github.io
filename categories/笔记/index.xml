<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 on Catfood Dev Blog</title><link>https://ridethepig.github.io/categories/%E7%AC%94%E8%AE%B0/</link><description>Recent content in 笔记 on Catfood Dev Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 08 Nov 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://ridethepig.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>NOIP退役整理 2 图论</title><link>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/</link><pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate><guid>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/</guid><description>&lt;h1 id="noip退役整理-2-图论">NOIP退役整理 2 图论&lt;/h1>
&lt;blockquote>
&lt;p>看完保证你, 退役!&lt;/p>
&lt;p>继续没有任何证明的笔记&lt;/p>
&lt;/blockquote>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="0-基础的算法">0. 基础的算法&lt;/h2>
&lt;h3 id="-1-链式前向星">-1. 链式前向星&lt;/h3>
&lt;p>最最最最重要的存图方法.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> next, to, w; } edge[maxn &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_edge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; edge[cnt].w &lt;span style="color:#f92672">=&lt;/span> w; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[cnt].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="0-百分数bfs和电风扇dfs">0. 百分数(BFS)和电风扇(DFS)&lt;/h3>
&lt;p>这个我不想说什么. 不过什么DFS的手工栈估计也是不会考,我虽然会写但是只用过一次还炸了&lt;/p>
&lt;h3 id="1拓扑排序">1.拓扑排序&lt;/h3>
&lt;p>拓扑序是一个比较重要的顺序,可以用来做各种事情,比如在图上递推, 或者直接解题什么的.&lt;/p>
&lt;p>主要就是在DAG上分析依赖关系. 还可以判环.主要思想就是:每次找入度为0的节点,找到后删除该节点和该节点的出度边.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// deg[]是入度. vis[]呵呵. 以下默认使用链星. (生成树除外)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Topo&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deg[v] &lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>deg[v]) Topo(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//main
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[i] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>deg[i]) Topo(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以在这个主要模板上做各种操作. 判环的话, 记一个color标记(比如:记正在访问为-1, 已经访问为1, 没有访问为0), 如果祖先节点没有返回但是子孙节点又访问到了它, 于是就有环了.&lt;/p>
&lt;p>其实还有BFS的写法.估计不考, 就不管了.&lt;a class="link" href="https://blog.csdn.net/baodream/article/details/80368764" target="_blank" rel="noopener"
>随便找了一个板子&lt;/a>&lt;/p>
&lt;h2 id="1最短路">1.最短路&lt;/h2>
&lt;h3 id="1-dijkstra">1. Dijkstra&lt;/h3>
&lt;p>先膜一波: %%%Dijkstra%%%&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>priority_queue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e5&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> inf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x7fffffff&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span>((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">T_Edge&lt;/span>{ &lt;span style="color:#66d9ef">int&lt;/span> to, next, w; } edge[maxn &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddEdge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; edge[cnt].w &lt;span style="color:#f92672">=&lt;/span> w; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">T_Node&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i, d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T_Node(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b)&lt;span style="color:#f92672">:&lt;/span> i(a), d(b) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">friend&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> (T_Node a, T_Node b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a.d &lt;span style="color:#f92672">&amp;gt;&lt;/span> b.d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>T_Node&lt;span style="color:#f92672">&amp;gt;&lt;/span> pq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n, m, s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> dis[maxn &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>], vis[maxn &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> read(); m &lt;span style="color:#f92672">=&lt;/span> read(); s &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ui, vi, wi;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ui &lt;span style="color:#f92672">=&lt;/span> read(); vi &lt;span style="color:#f92672">=&lt;/span> read(); wi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AddEdge(ui, vi, wi);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[i] &lt;span style="color:#f92672">=&lt;/span> inf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T_Node now(s, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> now.i &lt;span style="color:#f92672">=&lt;/span> s; now.d &lt;span style="color:#f92672">=&lt;/span> dis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq.push(now);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pq.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> now &lt;span style="color:#f92672">=&lt;/span> pq.top(); pq.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> now.i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(vis[u]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[v] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dis[v] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dis[u] &lt;span style="color:#f92672">+&lt;/span> edge[i].w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">=&lt;/span> dis[u] &lt;span style="color:#f92672">+&lt;/span> edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq.push(T_Node(v, dis[v]));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>, dis[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个的复杂度是严格&lt;code>O(nlog(n))&lt;/code>的.(其实跑n遍dj比一遍floyd要快(不考虑常数) // 笑)&lt;/p>
&lt;h3 id="2-spfa">2. SPFA&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() { &lt;span style="color:#75715e">/*...*/&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span>{ &lt;span style="color:#66d9ef">int&lt;/span> next, to, w; } edge[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_edge&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> w) {&lt;span style="color:#75715e">/*...*/&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> vis[maxn], dis[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spfa&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> q[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(q, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(q));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(dis, &lt;span style="color:#ae81ff">0x3f&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dis));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q[l] &lt;span style="color:#f92672">=&lt;/span> s, dis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (l &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> q[l &lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[u] &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dis[v] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dis[u] &lt;span style="color:#f92672">+&lt;/span> edge[i].w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">=&lt;/span> dis[u] &lt;span style="color:#f92672">+&lt;/span> edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[v]) vis[v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, q[&lt;span style="color:#f92672">++&lt;/span>r] &lt;span style="color:#f92672">=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//main
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个写起来比较方便, 虽然有可能会被卡掉.&lt;/p>
&lt;h3 id="3-floyd">3. Floyd&lt;/h3>
&lt;p>这个的主要思想是DP. 所以也是可以在上面加个一位瞎搞的. 复杂度很高, &lt;code>O(n^3)&lt;/code>&lt;/p>
&lt;p>状态转移方程
$$
D[k,i,j] 表示经过几个编号不超过k的节点,从i到j的最短路.我们把这个k作为一个中转点一样的东西 \\
显然, D[k, i, j] = min(D[k-1, i, j], D[k-1, i, k] + D[k-1, k, j]) \\
再显然,k这一维可以被推掉 \\
就变成了: D[i, j] = min(D[i, j], D[i,k] + D[k,j])
$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//init
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>memset(d, &lt;span style="color:#ae81ff">0x3f&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(d));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) d[i][i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">//自己到自己
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// read in...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d[i][j] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(d[i][j], d[i][k] &lt;span style="color:#f92672">+&lt;/span> d[k][j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个玩意儿似乎可以用来求最小环, 最后再写吧&lt;/p>
&lt;p>然而更加牛逼的是, 这个玩意儿的求解过程比较类似于矩阵乘法, 有些看似不可做的题目可以用类似于这样的矩阵快速幂跑.&lt;/p>
&lt;h3 id="4-相关题目">4. 相关题目&lt;/h3>
&lt;ol>
&lt;li>Luogu P1144 最短路计数. 在跑Dj/ Spfa的时候随便统计一下&lt;/li>
&lt;li>Luogu P2384 把加法换成了乘法, 保证你退役2333. 其实打个log就好了&lt;/li>
&lt;li>Luogu P1613 在Floyd上加一维乱搞&lt;/li>
&lt;/ol>
&lt;h3 id="5-我是不是应该皮一把k短路">5. 我是不是应该皮一把k短路&lt;/h3>
&lt;p>A*可做. 复杂度上界&lt;code>O(nklog(nk)&lt;/code>&lt;/p>
&lt;p>我不会写红红火火恍恍惚惚&lt;/p>
&lt;h2 id="2生成树">2.生成树&lt;/h2>
&lt;h3 id="1-kruskal">1. Kruskal&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e5&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> fa[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findfa&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fa[x] &lt;span style="color:#f92672">==&lt;/span> x &lt;span style="color:#f92672">?&lt;/span> fa[x] &lt;span style="color:#f92672">:&lt;/span> fa[x] &lt;span style="color:#f92672">=&lt;/span> findfa(fa[x]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> from, to, w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">friend&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> (Edge a, Edge b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a.w &lt;span style="color:#f92672">&amp;lt;&lt;/span> b.w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} edge[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> read(); &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[i].from &lt;span style="color:#f92672">=&lt;/span> read(), edge[i].to &lt;span style="color:#f92672">=&lt;/span> read(), edge[i].w &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>sort(edge &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, edge &lt;span style="color:#f92672">+&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) fa[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> fau;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((fau &lt;span style="color:#f92672">=&lt;/span> findfa(edge[i].from)) &lt;span style="color:#f92672">!=&lt;/span> findfa(edge[i].to)){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fa[edge[i].to] &lt;span style="color:#f92672">=&lt;/span> fau;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">+=&lt;/span> edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cnt &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;fuck&amp;#34;&lt;/span>); &lt;span style="color:#75715e">//如果边数不对就说明生成失败了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,ans);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-prim-不讲">2. Prim 不讲&lt;/h3>
&lt;p>这个基本用不到. 只有在稠密图上才会优于KS.&lt;/p>
&lt;h3 id="3-变种生成树">3. 变种生成树&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>最大生成树就把排序的顺序改一下就好了.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>次大/小生成树有点难写.&lt;/p>
&lt;p>先求最小生成树T,枚举添加不在T中的边,则添加后一定会形成环,找到环上边值第二大的边,把它删掉,计算当前生成树的权值,取所有枚举修改的生成树的最小值,即为次小生成树.这种方法的实现更为简单,首先求最小生成树T,然后从每个结点u,遍历最小生成树T,用一个二维的数组max[u][v]记录结点u到结点v的路径上边的最大值,然后枚举不在T中的边(u,v),计算T-max[u][v]+w(u,v)的最小值,即为次小生成树的权值 ,这种方法的时间复杂度为&lt;code>O(n^2+e)&lt;/code>.&lt;/p>
&lt;p>因为没什么题,就不多说了.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>考生成树的时候,一般是Day2T1的难度.基本上不会有什么特别的地方,一旦看出来能敲对就可以了.题目都比较弱智,不贴了&lt;/p>
&lt;h2 id="3tarjan">3.Tarjan&lt;/h2>
&lt;p>先膜一波为敬: %%%Tarjan%%%&lt;/p>
&lt;h3 id="1-强连通分量">1. 强连通分量&lt;/h3>
&lt;p>概念就不说了. 主要用来缩点,缩完以后就把一个有环图变成DAG,就可以随便瞎搞了.&lt;/p>
&lt;p>求这个玩意儿,其实有另外一个奇葩的跑两边的算法.(在接受FanDalao的指导之前,我一直写的是那个k打头的算法).&lt;/p>
&lt;p>先上板子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> low[maxn], dfn[maxn], stk[maxn], instk[maxn], tim, top, scc[maxn], num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// scc[u]代表u属于的强连通分量的编号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// low[u]代表u能到达的最小的dfn,似乎也就是最老的祖先
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// dfn代表的似乎是dfs序列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Tarjan&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfn[u] &lt;span style="color:#f92672">=&lt;/span> low[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>tim;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instk[stk[&lt;span style="color:#f92672">++&lt;/span>top] &lt;span style="color:#f92672">=&lt;/span> u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dfn[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Tarjan(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], low[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (instk[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], dfn[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[u] &lt;span style="color:#f92672">==&lt;/span> dfn[u]) { &lt;span style="color:#75715e">//完了,又回到自己了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> num &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> stk[top &lt;span style="color:#f92672">--&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instk[v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scc[v] &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v &lt;span style="color:#f92672">==&lt;/span> u) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还是有一些有趣的题目的.不过感觉都比较趋同,缩点-&amp;gt;搞一搞连通性,最短路,出度入度-&amp;gt;没了&lt;/p>
&lt;h3 id="2-割点和桥">2. 割点和桥&lt;/h3>
&lt;p>概念不说.&lt;/p>
&lt;p>割点&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u,&lt;span style="color:#66d9ef">int&lt;/span> root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sz &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfn[u] &lt;span style="color:#f92672">=&lt;/span> low[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>cnt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u];i;i &lt;span style="color:#f92672">=&lt;/span> edge[i].next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dfn[v]) low[u] &lt;span style="color:#f92672">=&lt;/span> min(low[u],dfn[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sz &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(v,root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[v] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> dfn[u]) iscut[u] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> min(low[u],low[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (u &lt;span style="color:#f92672">==&lt;/span> root &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sz &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iscut[u] &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// may be more beautiful
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">point&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> rt) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sz &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; dfn[u] &lt;span style="color:#f92672">=&lt;/span> low[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>tim;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dfn[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sz &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> point(v, rt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[v] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> dfn[u]) iscut[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], low[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], dfn[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (u &lt;span style="color:#f92672">==&lt;/span> rt &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> sz &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) iscut[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>桥 //正确性不明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">bridge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> fa) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> dfn[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>tim;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dfn[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bridge(v, u);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], low[v]) ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (low[v] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dfn[u]) { &lt;span style="color:#75715e">// &amp;#34;&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> isbridge[u][v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (fa &lt;span style="color:#f92672">!=&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low[u] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>min(low[u], dfn[v]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>似乎没有什么题目。&lt;/p>
&lt;h3 id="3-双联通分量">3. 双联通分量&lt;/h3>
&lt;p>&amp;ldquo;点双连通图的定义等价于任意两条边都同在一个简单环中,而边双连通图的定义等价于任意一条边至少在一个简单环中.&amp;ldquo;这个是从网上抄的.&amp;ldquo;不同双连通分量最多只有一个公共点,即某一个割顶,任意一个割顶都是至少两个点双连通的公共点.不同边双连通分量没有公共点,而桥不在任何一个边双连通分量中,点双连通分量一定是一个边双连通分量.&amp;rdquo;&lt;/p>
&lt;p>这个东西的求解跟上面的割点和桥差不多,虽然我没写过.(有一条HNOI2012)&lt;/p>
&lt;p>过天把代码补上&lt;/p>
&lt;h2 id="4-lca">4. LCA&lt;/h2>
&lt;p>&amp;ldquo;对呀对呀..求LCA有六种方法,你知道吗?&amp;rdquo; &amp;ndash;fan乙己 %%%%%%&lt;/p>
&lt;h3 id="1-暴力">1. 暴力&lt;/h3>
&lt;p>我表示不会写. 这个应该跟倍增差不多思想.就是对于两个点,轮流向上面跳,直到碰起来这个样子.&lt;/p>
&lt;h3 id="2-st表rmq">2. ST表/RMQ&lt;/h3>
&lt;p>这个跟tarjan一样不是很常用.就不打了,省的浪费时间和记忆力&lt;/p>
&lt;h3 id="3-倍增">3. 倍增&lt;/h3>
&lt;p>最最最常用而且很好写的lca.大家都在写它.(虽然很容易被卡掉,但是NOIP级别的还没有毒瘤到去卡这个)&lt;/p>
&lt;p>主要思想就是先预处理出每个点的深度,然后对于两个点的深度差倍增的向上跳,因为是倍增所以比一般的跳快一点.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e6&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> next, to; } edge[maxn&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddEdge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v) { edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt&lt;span style="color:#f92672">++&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> deep[maxn], l[maxn][&lt;span style="color:#ae81ff">30&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u) { &lt;span style="color:#75715e">//预处理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l[u][i] &lt;span style="color:#f92672">=&lt;/span> l[l[u][i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]][i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v &lt;span style="color:#f92672">==&lt;/span> l[u][&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#66d9ef">continue&lt;/span>; &lt;span style="color:#75715e">// 什么,儿子变成父亲了233
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> l[v][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> u; &lt;span style="color:#75715e">// v的父亲是u,就是从v向上跳2^0,即1步到达u
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> deep[v] &lt;span style="color:#f92672">=&lt;/span> deep[u] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getlca&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (deep[u] &lt;span style="color:#f92672">&amp;lt;&lt;/span> deep[v]) u &lt;span style="color:#f92672">^=&lt;/span> v &lt;span style="color:#f92672">^=&lt;/span> u &lt;span style="color:#f92672">^=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (deep[l[u][i]] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> deep[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u &lt;span style="color:#f92672">=&lt;/span> l[u][i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#75715e">//把u和v跳到同一高度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (u &lt;span style="color:#f92672">==&lt;/span> v) &lt;span style="color:#66d9ef">return&lt;/span> u; &lt;span style="color:#75715e">//到了一个点上,说明这两个点具有祖先关系
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (l[u][i] &lt;span style="color:#f92672">!=&lt;/span> l[v][i])&lt;span style="color:#75715e">//一起跳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> l[u][i], v &lt;span style="color:#f92672">=&lt;/span> l[v][i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> l[u][&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n,m,s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> read(); m &lt;span style="color:#f92672">=&lt;/span> read(); s &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tmp1,tmp2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i &lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp1 &lt;span style="color:#f92672">=&lt;/span> read(); tmp2 &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AddEdge(tmp1,tmp2); AddEdge(tmp2,tmp1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deep[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; dfs(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp1 &lt;span style="color:#f92672">=&lt;/span> read(); tmp2 &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,getlca(tmp1,tmp2));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-树链剖分">4. 树链剖分&lt;/h3>
&lt;p>树剖是前置技能.不说.&lt;/p>
&lt;p>主要思想是把u和v所在链的顶端跳到一起&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e6&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> next, to; } edge[maxn&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddEdge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v) { edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt&lt;span style="color:#f92672">++&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> sz[maxn], son[maxn], top[maxn], deep[maxn], fa[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs1&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sz[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, son[u] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v &lt;span style="color:#f92672">==&lt;/span> fa[u]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fa[v] &lt;span style="color:#f92672">=&lt;/span> u, deep[v] &lt;span style="color:#f92672">=&lt;/span> deep[u] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs1(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>son[u] &lt;span style="color:#f92672">||&lt;/span> sz[v] &lt;span style="color:#f92672">&amp;gt;&lt;/span> sz[son[u]]) son[u] &lt;span style="color:#f92672">=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sz[u] &lt;span style="color:#f92672">+=&lt;/span> sz[v];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">//处理儿子
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> tp) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> top[u] &lt;span style="color:#f92672">=&lt;/span> tp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (son[u]) dfs2(son[u], tp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v &lt;span style="color:#f92672">!=&lt;/span> fa[u] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> v &lt;span style="color:#f92672">!=&lt;/span> son[u]) dfs2(v, v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#75715e">//处理链顶
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getlca&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (top[u] &lt;span style="color:#f92672">!=&lt;/span> top[v]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (deep[top[u]] &lt;span style="color:#f92672">&amp;lt;&lt;/span> deep[top[v]]) u &lt;span style="color:#f92672">^=&lt;/span> v &lt;span style="color:#f92672">^=&lt;/span> u &lt;span style="color:#f92672">^=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u &lt;span style="color:#f92672">=&lt;/span> fa[top[u]];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (deep[u] &lt;span style="color:#f92672">&amp;gt;&lt;/span> deep[v]) u &lt;span style="color:#f92672">^=&lt;/span> v &lt;span style="color:#f92672">^=&lt;/span> u &lt;span style="color:#f92672">^=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> u;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> read(), m &lt;span style="color:#f92672">=&lt;/span> read(), s &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> read(), v &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AddEdge(u, v); AddEdge(v, u);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs1(s); dfs2(s, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ui &lt;span style="color:#f92672">=&lt;/span> read(), vi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, getlca(ui, vi));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-离线tarjan">5. 离线Tarjan&lt;/h3>
&lt;p>不是很常用.贴一个久远的板子.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3e6&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n,m,s,cnt1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, cnt2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head1[maxn], head2[maxn], ans[maxn], fa[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> vis[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">t_edge&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> next, to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}edge[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">t_query&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> next, to, num, vis;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}query[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddEdge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddQuery&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">father&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">combine&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//freopen(&amp;#34;testdata.in&amp;#34;,&amp;#34;r&amp;#34;,stdin);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> read(), m &lt;span style="color:#f92672">=&lt;/span> read(), s &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;n,&amp;amp;m,&amp;amp;s);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ui,vi;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ui &lt;span style="color:#f92672">=&lt;/span> read(),vi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;ui,&amp;amp;vi);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> AddEdge(ui,vi); AddEdge(vi,ui);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ui &lt;span style="color:#f92672">=&lt;/span> read(),vi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;ui,&amp;amp;vi);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> AddQuery(ui,vi,i);AddQuery(vi,ui,i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//fclose(stdin);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fa[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,ans[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddEdge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u,&lt;span style="color:#66d9ef">int&lt;/span> v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt1].next &lt;span style="color:#f92672">=&lt;/span> head1[u];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt1].to &lt;span style="color:#f92672">=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head1[u] &lt;span style="color:#f92672">=&lt;/span> cnt1 &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">AddQuery&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u,&lt;span style="color:#66d9ef">int&lt;/span> v,&lt;span style="color:#66d9ef">int&lt;/span> num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> query[cnt2].next &lt;span style="color:#f92672">=&lt;/span> head2[u];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> query[cnt2].to &lt;span style="color:#f92672">=&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> query[cnt2].num &lt;span style="color:#f92672">=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head2[u] &lt;span style="color:#f92672">=&lt;/span> cnt2 &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">-&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">father&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fa[x] &lt;span style="color:#f92672">!=&lt;/span> x) fa[x] &lt;span style="color:#f92672">=&lt;/span> father(fa[x]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fa[x];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">combine&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x,&lt;span style="color:#66d9ef">int&lt;/span> y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fa[father(x)] &lt;span style="color:#f92672">=&lt;/span> father(y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[u] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head1[u]; i ; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (vis[v]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dfs(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> combine(v,u);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head2[u]; i ; i &lt;span style="color:#f92672">=&lt;/span> query[i].next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>v &lt;span style="color:#f92672">=&lt;/span> query[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (vis[v] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>query[i].vis)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans[query[i].num] &lt;span style="color:#f92672">=&lt;/span> father(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> query[i].vis &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="6-笛卡尔树">6. 笛卡尔树&lt;/h3>
&lt;p>这个不会写, 巨难&lt;/p>
&lt;h2 id="5-二分图">5. 二分图&lt;/h2>
&lt;h3 id="1-二分染色">1. 二分染色&lt;/h3>
&lt;p>这个算法似乎还是考过的,主要用来判断一个图是否是二分图,还可以顺带做一些操作.看到有某些互斥操作或者两边分的比较明显的就可以考虑二分图相关的东西.染色很简单,暴力遍历一边就结束了.&lt;/p>
&lt;p>题目:&lt;/p>
&lt;ol>
&lt;li>Luogu P1155. 其实也可以不用二分图.也比较不好想到是二分图&lt;/li>
&lt;li>Luogu P1330. 这个比较明显.&lt;/li>
&lt;/ol>
&lt;p>蒟蒻表示自己基本只刷过luogu&amp;hellip;没有什么别的题库.tcl&lt;/p>
&lt;h3 id="2-二分图匹配">2. 二分图匹配&lt;/h3>
&lt;p>这个里面有许多奇奇怪怪的概念:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>定义：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。&lt;br>
匹配点：匹配边上的两点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>极大匹配(Maximal Matching)：是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大匹配(maximum matching)：是所有极大匹配当中边数最大的一个匹配,设为M。选择这样的边数最大的子集称为图的最大匹配问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完美匹配（完备匹配）：一个图中所有的顶点都是匹配点的匹配，即2|M| = |V|。完美匹配一定是最大匹配，但并非每个图都存在完美匹配。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最优匹配：最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。（KM（Kuhn and Munkres）算法，是对匈牙利算法的一种贪心扩展。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最小覆盖 二分图的最小覆盖分为最小顶点覆盖和最小路径覆盖：&lt;br>
①最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联&lt;br>
注：二分图的最小顶点覆盖数=二分图的最大匹配数&lt;/p>
&lt;p>②最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。&lt;br>
注：二分图的最小路径覆盖数=|V|-二分图的最大匹配数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最大独立集:最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集=|V|-二分图的最大匹配数。最大独立集S 与 最小覆盖集T 互补&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/ling_wang/article/details/79830980" target="_blank" rel="noopener"
>这个当然是抄的&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="1-二分图最大匹配">1. 二分图最大匹配&lt;/h4>
&lt;p>就是找到最多的匹配个数. 经典模型为稳定婚姻问题.&lt;/p>
&lt;p>二分图匹配本质上是一个网络流问题,只要再左边一列的左边加一个源点,右边一列右边再加一个汇点,跑最大流就好了.但是对于二分图来说其实不必要这个样子,可以简单一点.&lt;/p>
&lt;p>接下来是板子. 其实代码并不是很难, 难在发现这是一个二分图,再把模型建起来.这一点在网络流里面也是一个巨大的问题.233&lt;/p>
&lt;p>算法为匈牙利算法.主要思想就是先随便匹配,遇到有重合的就考虑拆掉原来的,再给原来的重新配一个.知道再也配不到为止.(一个无比凶残的算法)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Luogu P3386
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1e6&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span> { &lt;span style="color:#66d9ef">int&lt;/span> to, next; } edge[maxn &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_edge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> pre[maxn], vis[maxn], tim, ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (vis[v] &lt;span style="color:#f92672">==&lt;/span> tim) &lt;span style="color:#66d9ef">continue&lt;/span>; &lt;span style="color:#75715e">//神奇的常数优化,不需要memset了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> vis[v] &lt;span style="color:#f92672">=&lt;/span> tim;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pre[v] &lt;span style="color:#f92672">||&lt;/span> dfs(pre[v])) { &lt;span style="color:#75715e">// 自己未被匹配 || 可以腾出一个位置; 这个写得顺序也是一个常数优化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pre[v] &lt;span style="color:#f92672">=&lt;/span> u; &lt;span style="color:#75715e">// 重新匹配成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> read(), m &lt;span style="color:#f92672">=&lt;/span> read(), e &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> e; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ui &lt;span style="color:#f92672">=&lt;/span> read(), vi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ui &lt;span style="color:#f92672">&amp;gt;&lt;/span> n &lt;span style="color:#f92672">||&lt;/span> vi &lt;span style="color:#f92672">&amp;gt;&lt;/span> m) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add_edge(ui, vi);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tim &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dfs(i)) ans &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, ans);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-二分图最大带权匹配最优匹配">2. 二分图最大带权匹配(最优匹配)&lt;/h4>
&lt;p>就是给每一个匹配加一个权值,然后求最大匹配,同时使权值最优.&lt;/p>
&lt;p>同样可以跑网络流. 不过主要使KM算法.这个东西可以用,但是似乎从来没有刻意去考过, 估计也暂时不将去考.&lt;/p>
&lt;p>鉴于我自己只是了解大概思想, 板子就没有了.&lt;/p>
&lt;h2 id="6-各种奇怪算法">6. 各种奇怪算法&lt;/h2>
&lt;h3 id="1-差分约束">1. 差分约束&lt;/h3>
&lt;p>有一大堆形如
$$
x{i} - x{j} \leq c_{k}
$$
的不等式, 因为它们长得非常像SPFA / DJ中的三角形不等式, 于是乎可以用图论方法来求解这一堆东西的关系.&lt;/p>
&lt;p>如果出现小于, 就在后面-1就好了, (至于double请自求多福), 如果是大于等于之类的, 打个负号然后考场上现场瞎编就好了.&lt;/p>
&lt;p>如果存在负环, 表明不满足条件 (貌似很多题里面只要有环就不成立, 到时候随机应变就好了)&lt;/p>
&lt;p>如果跑出来是个inf, 就表明没有任何的限制.&lt;/p>
&lt;p>dis的结果就是每一条约束链的最小花费, (一组解?)&lt;/p>
&lt;p>下面是个板子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10001&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">t_edge&lt;/span>{ &lt;span style="color:#66d9ef">int&lt;/span> to, next, w; } edge[maxn &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_e&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; edge[cnt].w &lt;span style="color:#f92672">=&lt;/span> w; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> dis[maxn], vis[maxn], flg;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spfa&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[s]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dis[v] &lt;span style="color:#f92672">&amp;lt;&lt;/span> dis[s] &lt;span style="color:#f92672">+&lt;/span> edge[i].w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">=&lt;/span> dis[s] &lt;span style="color:#f92672">+&lt;/span> edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[v]) spfa(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> { flg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> read(); m &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> op, ai, bi, ci;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> op &lt;span style="color:#f92672">=&lt;/span> read(); ai &lt;span style="color:#f92672">=&lt;/span> read(); bi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span>(op) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ci &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add_e(bi, ai, ci);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ci &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add_e(ai, bi, &lt;span style="color:#f92672">-&lt;/span>ci);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add_e(ai, bi, &lt;span style="color:#ae81ff">0&lt;/span>); add_e(bi, ai, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spfa(i); &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(flg &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Yes&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-负环">2. 负环&lt;/h3>
&lt;p>深搜或者SPFA都可以用来判负环&lt;/p>
&lt;p>至于正环, 随便写一写就好了&lt;/p>
&lt;p>上代码&lt;/p>
&lt;p>大法师:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// luogu-judger-enable-o2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3001&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">t_edge&lt;/span>{ &lt;span style="color:#66d9ef">int&lt;/span> to, next, w; } edge[maxn &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[maxn], cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_e&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> edge[cnt].next &lt;span style="color:#f92672">=&lt;/span> head[u]; edge[cnt].to &lt;span style="color:#f92672">=&lt;/span> v; edge[cnt].w &lt;span style="color:#f92672">=&lt;/span> w; head[u] &lt;span style="color:#f92672">=&lt;/span> cnt &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> dis[maxn], vis[maxn], flg;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">spfa&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[s]; i; i &lt;span style="color:#f92672">=&lt;/span> edge[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> edge[i].to;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dis[v] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dis[s] &lt;span style="color:#f92672">+&lt;/span> edge[i].w) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">=&lt;/span> dis[s] &lt;span style="color:#f92672">+&lt;/span> edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[v]) spfa(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> { flg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (t &lt;span style="color:#f92672">--&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> read(); m &lt;span style="color:#f92672">=&lt;/span> read(); &lt;span style="color:#66d9ef">int&lt;/span> ui, vi, wi;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(vis, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(vis));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(head, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(head));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(dis, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dis));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ui &lt;span style="color:#f92672">=&lt;/span> read(); vi &lt;span style="color:#f92672">=&lt;/span> read(); wi &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (wi &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) add_e(ui, vi, wi);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> { add_e(ui, vi, wi); add_e(vi, ui, wi); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spfa(i); &lt;span style="color:#66d9ef">if&lt;/span> (flg) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(flg &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;YE5&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;N0&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>百分数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;bits/stdc++.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define IL inline
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define RI register int
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define N 100086
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define clear(a) memset(a,0,sizeof a)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define rk for(RI i=1;i&amp;lt;=n;i++)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IL &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> f&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#66d9ef">char&lt;/span> s&lt;span style="color:#f92672">=&lt;/span>getchar();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(s&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>&lt;span style="color:#f92672">||&lt;/span>s&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>){&lt;span style="color:#66d9ef">if&lt;/span>(s&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>)f&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;s&lt;span style="color:#f92672">=&lt;/span>getchar();}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(s&lt;span style="color:#f92672">&amp;lt;=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>s&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>){x&lt;span style="color:#f92672">=&lt;/span>x&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#f92672">+&lt;/span>s&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>;s&lt;span style="color:#f92672">=&lt;/span>getchar();}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x&lt;span style="color:#f92672">*=&lt;/span>f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> n,m,T;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">code&lt;/span>{&lt;span style="color:#66d9ef">int&lt;/span> u,v,w;}edge[N];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> vis[N];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> head[N],tot,dis[N],cnt[N];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IL &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x,&lt;span style="color:#66d9ef">int&lt;/span> y,&lt;span style="color:#66d9ef">int&lt;/span> z){edge[&lt;span style="color:#f92672">++&lt;/span>tot].u&lt;span style="color:#f92672">=&lt;/span>head[x];edge[tot].v&lt;span style="color:#f92672">=&lt;/span>y;edge[tot].w&lt;span style="color:#f92672">=&lt;/span>z;head[x]&lt;span style="color:#f92672">=&lt;/span>tot;}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IL &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">spfa&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> now)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rk vis[i]&lt;span style="color:#f92672">=&lt;/span>false,dis[i]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2147483647&lt;/span>,cnt[i]&lt;span style="color:#f92672">=&lt;/span>false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push(now);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[now]&lt;span style="color:#f92672">=&lt;/span>true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[now]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>q.empty())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> u&lt;span style="color:#f92672">=&lt;/span>q.front();q.pop();vis[u]&lt;span style="color:#f92672">=&lt;/span>false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(cnt[u]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>n)&lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(RI i&lt;span style="color:#f92672">=&lt;/span>head[u];i;i&lt;span style="color:#f92672">=&lt;/span>edge[i].u)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(dis[edge[i].v]&lt;span style="color:#f92672">&amp;gt;&lt;/span>dis[u]&lt;span style="color:#f92672">+&lt;/span>edge[i].w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[edge[i].v]&lt;span style="color:#f92672">=&lt;/span>dis[u]&lt;span style="color:#f92672">+&lt;/span>edge[i].w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>vis[edge[i].v])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push(edge[i].v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[edge[i].v]&lt;span style="color:#f92672">=&lt;/span>true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt[edge[i].v]&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(cnt[edge[i].v]&lt;span style="color:#f92672">&amp;gt;=&lt;/span>n)&lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read(T);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(T&lt;span style="color:#f92672">--&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read(n),read(m);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tot&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;clear(head);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(RI i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,u,v,w;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read(u),read(v),read(w);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(w&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)add(u,v,w);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> add(u,v,w),add(v,u,w);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts(spfa(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;YE5&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#e6db74">&amp;#34;N0&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3--最小环">3. 最小环&lt;/h3>
&lt;p>可以用Floyd来求, 似乎dj也可以做. 不过网上似乎只有Floyd的做法, 于是乎抄写一波.&lt;/p>
&lt;h3 id="4-反图">4. 反图&lt;/h3>
&lt;p>这个主要是用来解决不能到达终点的情况的. 很多时候正反跑一遍 或者直接反着跑就会奇迹再现&lt;/p>
&lt;h3 id="5-欧拉路">5. 欧拉路&lt;/h3>
&lt;h3 id="6-哈密顿路">6. 哈密顿路&lt;/h3>
&lt;p>不管了&lt;/p>
&lt;h3 id="7-倍增">7. 倍增&lt;/h3>
&lt;p>这个可以用来优化图上 / 树上的长度问题. 具体写得话, 随缘了.&lt;/p>
&lt;p>&lt;strong>记得不要把数组开太小&lt;/strong>. 还有这个玩意儿有点耗空间. (不过这几年不卡空间就是了)&lt;/p>
&lt;h2 id="7一些奇特的东西">7.一些奇特的东西&lt;/h2>
&lt;h3 id="1dfs序和dfs树">1.DFS序和DFS树&lt;/h3>
&lt;p>咕咕咕&amp;hellip;&lt;/p>
&lt;h2 id="8-一些奇葩题">8. 一些奇葩题&lt;/h2>
&lt;ol>
&lt;li>POJ3613 看起来是图论题的矩阵快速幂&lt;/li>
&lt;li>NOIP2013 华容道: 非常牛逼的一条图论建模&lt;/li>
&lt;/ol></description></item><item><title>NOIP退役整理 3 数据结构</title><link>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate><guid>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="noip退役整理-3-数据结构">NOIP退役整理 3 数据结构&lt;/h1>
&lt;blockquote>
&lt;p>看完保证你, 退役!&lt;/p>
&lt;p>感觉NOIP的数据结构并不是很多的说&amp;hellip;233&lt;/p>
&lt;/blockquote>
&lt;h2 id="0-并查集">0. 并查集&lt;/h2>
&lt;h2 id="1-树状数组">1. 树状数组&lt;/h2>
&lt;p>随便贴一个区间加的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define re register int
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define lowbit(x) (x &amp;amp; -x)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5e5&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> lld;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> lld &lt;span style="color:#a6e22e">read&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lld x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#66d9ef">char&lt;/span> c; &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> c &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">if&lt;/span> (c &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>) f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; x &lt;span style="color:#f92672">=&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((c &lt;span style="color:#f92672">=&lt;/span> getchar()) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;9&amp;#39;&lt;/span>) x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>; &lt;span style="color:#66d9ef">return&lt;/span> f &lt;span style="color:#f92672">?&lt;/span> x : &lt;span style="color:#f92672">~&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lld a[maxn], n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span>(lld x, lld k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; x &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; x &lt;span style="color:#f92672">+=&lt;/span> lowbit(x)) a[x] &lt;span style="color:#f92672">+=&lt;/span> k;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> lld &lt;span style="color:#a6e22e">get&lt;/span>(lld x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lld r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; x; x &lt;span style="color:#f92672">-=&lt;/span> lowbit(x)) r &lt;span style="color:#f92672">+=&lt;/span> a[x];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> read(); m &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lld now, last &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (re i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> now &lt;span style="color:#f92672">=&lt;/span> read(); Add(i, now &lt;span style="color:#f92672">-&lt;/span> last);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last &lt;span style="color:#f92672">=&lt;/span> now;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (re i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lld op &lt;span style="color:#f92672">=&lt;/span> read(), x &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (op &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lld y &lt;span style="color:#f92672">=&lt;/span> read(), k &lt;span style="color:#f92672">=&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Add(x, k); Add(y &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%lld&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, get(x));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-线段树">2. 线段树&lt;/h2>
&lt;p>随便写写就好&lt;/p>
&lt;h2 id="3st表">3.ST表&lt;/h2>
&lt;p>主要用来解决RMQ(区间最值问题)的一种算法, 主要思想竟然是&lt;strong>动态规划&lt;/strong>(区间动规)和倍增.支持&lt;code>O(nlog(n))&lt;/code>预处理, &lt;code>O(1)&lt;/code>查询, 而且常数非常小, &lt;del>跑得跟记者一样快&lt;/del>但是不支持修改,极大地限制了它的运用范围.&lt;/p>
&lt;p>方程:
$$
f[i,j] = max(f[i,j-1], f[i + 2^{j-1}, j-1]) \
其中f[i,j]表示a[i]到a[2^j-1]区间内的最大值
$$
求解的时候
$$
k = log_2(r - l + 1)\
ans = max(f[l, k], f[r - 2^k + 1, k])
$$
板子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初始化部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (log[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) log[i] &lt;span style="color:#f92672">=&lt;/span> log[i &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//递推log,在询问较多时可以卡卡常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) st[i][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> dat[i]; &lt;span style="color:#75715e">//dp初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">22&lt;/span>; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> j) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st[i][j] &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(st[i][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>], st[i&lt;span style="color:#f92672">+&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//查询
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">query_max&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> l, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> log[r &lt;span style="color:#f92672">-&lt;/span> l &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>max(st[i][k], st[r &lt;span style="color:#f92672">-&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> k) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][k]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-平衡树大法">4. 平衡树大法!!!&lt;/h2>
&lt;p>这个不会用到的. 只是个人兴趣而已&lt;/p>
&lt;h2 id="5-trie">5. Trie&lt;/h2>
&lt;h2 id="6-平板电视extpb_dshpp">6. 平板电视(ext/pb_ds/*.hpp)&lt;/h2>
&lt;h2 id="7-差分-前缀和">7. 差分 前缀和&lt;/h2>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/Taunt_/article/details/78478526" target="_blank" rel="noopener"
>这个玩意儿写得不错, 抄下来了.&lt;/a>&lt;/p>
&lt;h3 id="前缀和">前缀和&lt;/h3>
&lt;h4 id="1一维前缀和">1.一维前缀和&lt;/h4>
&lt;p>对于数组A[], 前缀和SUM[i]表示的就是A[1]+A[2]+…+A[i].&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) sum[i] &lt;span style="color:#f92672">=&lt;/span> sum[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> a[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> l, &lt;span style="color:#66d9ef">int&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum[r] &lt;span style="color:#f92672">-&lt;/span> sum[l&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2二维前缀和">2.二维前缀和&lt;/h4>
&lt;p>对于二维数组, 前缀和SUM[i][k]表示的是所有A[i’][k’](1&amp;lt; = i’&amp;lt;=i,i &amp;lt;= k’&amp;lt;=k)的和.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum[i][j] &lt;span style="color:#f92672">=&lt;/span> sum[i][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> sum[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">-&lt;/span> sum[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> a[i][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x1, &lt;span style="color:#66d9ef">int&lt;/span> y1, &lt;span style="color:#66d9ef">int&lt;/span> x2, &lt;span style="color:#66d9ef">int&lt;/span> y2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum[x1][y1] &lt;span style="color:#f92672">-&lt;/span> sum[x1][y2 &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-&lt;/span> sum[x2 &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][y1] &lt;span style="color:#f92672">+&lt;/span> sum[x2 &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][y2 &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3k时的优化">3.%k时的优化&lt;/h4>
&lt;p>（p - q）% k= 0 ==&amp;gt; p % k = q % k
统计q % k 和 p % k 相等的数
详细见T1&lt;/p>
&lt;h3 id="差分">差分&lt;/h3>
&lt;h4 id="1一维差分">1.一维差分&lt;/h4>
&lt;p>我们对[L,R]区间进行加num操作，在C[L]处加上num，在C[R+1]处减去num&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> l,&lt;span style="color:#66d9ef">int&lt;/span> r,&lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[l] &lt;span style="color:#f92672">+=&lt;/span> num, dis[r &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val[i] &lt;span style="color:#f92672">=&lt;/span> val[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> dis[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2二维差分">2.二维差分&lt;/h4>
&lt;p>其实也挺简单，和二维前缀和一样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x1, &lt;span style="color:#66d9ef">int&lt;/span> y1, &lt;span style="color:#66d9ef">int&lt;/span> x2, &lt;span style="color:#66d9ef">int&lt;/span> y2, &lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sumx1 &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sumx1 &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sumx2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sumx2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sumi &lt;span style="color:#f92672">+=&lt;/span> sumi &lt;span style="color:#f92672">+&lt;/span> sumi&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> sumi&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3树上差分">3.树上差分&lt;/h4>
&lt;h5 id="1点差分">(1)点差分&lt;/h5>
&lt;p>对 u 到 v 的路径上的点 +num
用来求 - 已知路径求树上所有节点被路径覆盖次数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[u] &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[lca(u,v)] &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[f[lca(u,v)]] &lt;span style="color:#f92672">-=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2边差分">(2)边差分&lt;/h5>
&lt;p>对 u 到 v 的路径上的边 +num
用来求 - 已知路径求被所有路径覆盖的边
dis[i] 表示以i节点为儿子的边&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u, &lt;span style="color:#66d9ef">int&lt;/span> v, &lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[u] &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[v] &lt;span style="color:#f92672">+=&lt;/span> num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[lca(u,v)] &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span>num;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后dfs遍历一遍&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> head[u]; i; i &lt;span style="color:#f92672">=&lt;/span> e[i].next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> e[i].v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(v &lt;span style="color:#f92672">!=&lt;/span> fx) { &lt;span style="color:#75715e">//fx 为倍增数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dfs(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dis[x] &lt;span style="color:#f92672">+=&lt;/span> dis[v];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>NOIP退役整理 1 数学相关</title><link>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate><guid>https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</guid><description>&lt;h1 id="noip退役整理-1--数学相关">NOIP退役整理 1 数学相关&lt;/h1>
&lt;blockquote>
&lt;p>看完保证你,退役&lt;/p>
&lt;p>这篇笔记里从不写证明&lt;/p>
&lt;/blockquote>
&lt;p>[TOC]&lt;/p>
&lt;h3 id="0更加基础的算法">0.更加基础的算法&lt;/h3>
&lt;p>这里贴几个最最最最基础的算法&lt;/p>
&lt;h4 id="1n求因数">1.√n求因数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, fac[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">get_factor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> x; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fac[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">!=&lt;/span> x &lt;span style="color:#f92672">/&lt;/span> i) fac[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">/&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2gcd">2.gcd&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">gcd&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> b &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> a : gcd(b, a &lt;span style="color:#f92672">%&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3n分解质因数">3.√n分解质因数&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; prime[maxn], index[maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">prime_factor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prime[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> i, index[cnt] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (n &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) x &lt;span style="color:#f92672">/=&lt;/span> i, index[cnt] &lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) prime[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> x, index[cnt] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="1-裴蜀定理-bezout">1. 裴蜀定理 (Bezout)&lt;/h3>
&lt;p>$$
ax + by = m
$$&lt;/p>
&lt;p>对于这样一个不定方程,当且仅当&lt;code>gcd(a,b) | m&lt;/code>的时候,有无数多个整数解.特别的,对于 &lt;code>ax + by = 1&lt;/code>, 当且仅当a和b互质时有如上结论.&lt;/p>
&lt;p>另: 对于任意多个未知数和任意多个系数, 这个结论也是成立的. 也就是
$$
a_{1}x_{1} + a_{2}x_{2} + \cdots + a_{n}x_{n} = d \\
其中d = (a_{1}, a_{2}, \cdots,a_{n})
$$
这样一个式子.&lt;/p>
&lt;p>似乎简单的用法就是推出系数和后面的解的关系,然后用&lt;code>gcd&lt;/code>或者&lt;code>整数相关的东西&lt;/code>瞎搞.&lt;/p>
&lt;p>例题:&lt;/p>
&lt;ol>
&lt;li>BZOJ 1441. 显然就是推广结论的裸题&lt;/li>
&lt;li>&amp;lt;JSOI 2009 瓶子和燃料&amp;gt; 虽然感觉和Bezout没有什么关系&amp;hellip;个人认为,这就是个结论题, 似乎用辗转相减更好理解一点&lt;/li>
&lt;li>&amp;lt;HAOI2011 向量&amp;gt; 这个比较难,要多推几步.也是一条Bezout定理.(从某个聚铑博客里发现的题) (这个我不会写)&lt;/li>
&lt;li>NOIP2014 Day2T3 解方程. 这个似乎就是直接枚举(因为1e6好像可以过去),然后Bezout定理去检验.(话说这题好皮啊&amp;hellip;)(然而我也不会写)&lt;/li>
&lt;/ol>
&lt;h3 id="2拓展欧几里得-ex_gcd">2.拓展欧几里得 (Ex_Gcd)&lt;/h3>
&lt;h4 id="1基本内容">1.基本内容&lt;/h4>
&lt;p>这个算是一个比较基础的算法,用来解线性同余方程.&lt;/p>
&lt;p>这个方程大概长这个样子:
$$
ax \equiv b\pmod {m}
$$
我们需要求整数解.&lt;/p>
&lt;p>把这个玩意儿变个形, 就得到了
$$
ax + my = b
$$
这不就是个二元不定方程吗.这个可以用exgcd来解.显然, 由Bezout定理可知, 如果有整数解,那就一定有无数个这样的解. 当且仅当&lt;code>(a,m) | b&lt;/code>时有整数解&lt;/p>
&lt;p>所以在解方程之前需要判定合法. 也就是判断&lt;code>(a, m)|b&lt;/code>是否成立.&lt;/p>
&lt;p>先上代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">ex_gcd&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> d, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (b &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, d &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ex_gcd(b, a &lt;span style="color:#f92672">%&lt;/span> b, d, y, x); &lt;span style="color:#75715e">// 划重点. x和y不要打反了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> y &lt;span style="color:#f92672">-=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> (a &lt;span style="color:#f92672">/&lt;/span> b); &lt;span style="color:#75715e">//这个括号一定要打。否则会先乘溢出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解出来以后,这只是一个解.&lt;/p>
&lt;p>所有的解可以由一种构造方法得到, 也就是通解.&lt;/p>
&lt;p>$$
x_{i} = x_{0} + i * b/(a,m),i\in Z\\
y_{i} = y_{0} - i * b/(a,m),i\in Z
$$&lt;/p>
&lt;p>还有最小整数解:&lt;/p>
&lt;p>$$
x_{min} = (x*b/d \bmod (m / d) + m / d) \bmod (m/d) \\
其中d = (a, m);
$$&lt;/p>
&lt;p>似乎还可以这么写: (不是很清楚这两个有什么区别) 总而言之,求逆元用下面的,最小整数解用上面的&lt;/p>
&lt;p>$$
x_{min} = (x \bmod m + m) \bmod m
$$&lt;/p>
&lt;h4 id="2-中国剩余定理">2. 中国剩余定理&lt;/h4>
&lt;p>用来解线性同余方程组.背结论好了.&lt;/p>
&lt;p>$$
设m_1, m_2, m_3, \cdots, m_n 是两两互质的数\\
设 m = \Pi_{i=1}^nm_i\\
M_i = \frac{m}{m_i}\\
t_i是同余方程 M_i*t_i \equiv 1 \pmod m_i的一个解\\
$$&lt;/p>
&lt;p>$$
则对于任意n个整数a_1,a_2,\cdots,a_n,\\
\begin{equation}
\left\{
\begin{array}{lr}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\cdots \\
x \equiv a_n \pmod {m_n}
\end{array}
\right.
\end{equation} \\
该方程组有整数解, 为x = \Sigma_{i=1}^{n}a_iM_it_i
$$
同样的,这也只是一个特解. 最小整数解需要%一下.&lt;/p>
&lt;p>终于到例题了:&lt;/p>
&lt;ol>
&lt;li>Poj1061 青蛙的约会. 经典老题&lt;/li>
&lt;li>NOIP2012 同余方程. 裸的拓欧.&lt;/li>
&lt;li>没了. 附赠:&lt;a class="link" href="http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html" target="_blank" rel="noopener"
>一个不错的讲解&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="3各种筛-把你打成筛子">3.各种筛 (把你打成筛子)&lt;/h3>
&lt;p>这个相信大家都很清楚是什么. 就当板子放在这里.&lt;/p>
&lt;h4 id="1素数筛">1.素数筛&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">get_prime&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(vis, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(vis));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[i] &lt;span style="color:#f92672">=&lt;/span> prime[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> cnt; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (prime[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> vis[i] &lt;span style="color:#f92672">||&lt;/span> prime[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> n &lt;span style="color:#f92672">/&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[i &lt;span style="color:#f92672">*&lt;/span> prime[j]] &lt;span style="color:#f92672">=&lt;/span> prime[j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>顺手判素数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_prime&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> x; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2欧拉筛">2.欧拉筛&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">get_phi&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(vis, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(vis));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>vis[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[i] &lt;span style="color:#f92672">=&lt;/span> prime[&lt;span style="color:#f92672">++&lt;/span> cnt] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phi[i] &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> cnt; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (prime[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> vis[i] &lt;span style="color:#f92672">||&lt;/span> prime[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> n &lt;span style="color:#f92672">/&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vis[i &lt;span style="color:#f92672">*&lt;/span> prime[j]] &lt;span style="color:#f92672">=&lt;/span> prime[j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phi[i &lt;span style="color:#f92672">*&lt;/span> prime[j]] &lt;span style="color:#f92672">=&lt;/span> phi[i] &lt;span style="color:#f92672">*&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> prime[j] &lt;span style="color:#f92672">?&lt;/span> prime[j] &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> prime[j]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>求一个phi. 长得和分解质因数一毛一样&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_phi&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">/&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> (i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (n &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) n &lt;span style="color:#f92672">/=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">/&lt;/span> n &lt;span style="color:#f92672">*&lt;/span> (n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>顺便一提, phi(n)表示小于等于n的素数个数&lt;/p>
&lt;p>积性函数什么的反正考不到我也不会,就不管了.&lt;/p>
&lt;p>大概的表是 0, 1, 2, 2, 4, 2, 6, 4, 10 &amp;hellip;&amp;hellip; 这个可以打表想到&lt;/p>
&lt;p>例题: Poj3090.可以由暴力算法观察结果得出,这个是个欧拉函数(反正当时做的时候是打表出来的).至于具体证明,呵呵&lt;/p>
&lt;h3 id="4逆元">4.逆元&lt;/h3>
&lt;p>逆元就是用来做除法取模的东西. 一个数处以另一个数等于被除数乘上除数的逆元.(因为在取模的时候,除法不满足结合律, 所以要用逆元)我们有多种方法求逆元,直接给出代码.&lt;/p>
&lt;h4 id="1exgcd">1.exgcd&lt;/h4>
&lt;p>这个其实就是线性同余方程右边是1的情况下的解, 很明显它是唯一的,而且可以用exgcd解.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_inv&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x, y, d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ex_gcd(n, p, x, y, d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (x&lt;span style="color:#f92672">%&lt;/span>p&lt;span style="color:#f92672">+&lt;/span>p)&lt;span style="color:#f92672">%&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>复杂度 &lt;code>O(log(n))&lt;/code>&lt;/p>
&lt;h4 id="2费马小定理">2.费马小定理&lt;/h4>
&lt;p>这个只有在a,p互素的时候才能用&lt;/p>
&lt;p>由
$$
a^{p-1} \equiv 1 \pmod {p}, p是素数
$$
可以随便瞎推得
$$
inv(i) = i^{p-2} \pmod{p}, p是素数
$$
因为用了一个快速幂,所以复杂度是&lt;code>O(log(n))&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">get_inv_fm&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> p &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">%=&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; k; k &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">*&lt;/span> x &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> x &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实还有什么Euler定理,当n垂直于a的时候,a^φ(n) 同余于 1(在模n意义下).这样的玩意儿&lt;/p>
&lt;h4 id="3线性递推">3.线性递推&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">get_inv_arr&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> p){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inv[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inv[i] &lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)(p &lt;span style="color:#f92672">-&lt;/span> p&lt;span style="color:#f92672">/&lt;/span>i) &lt;span style="color:#f92672">*&lt;/span> inv[p &lt;span style="color:#f92672">%&lt;/span> i] &lt;span style="color:#f92672">%&lt;/span> p; &lt;span style="color:#75715e">//防溢出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个没什么好说的,反正不长,背下来就好.&lt;/p>
&lt;h3 id="5组合相关">5.组合相关&lt;/h3>
&lt;h4 id="1基本内容-1">1.基本内容&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>加法, 乘法原理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>排列数&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>$$
P_{n}^{m} = \frac{n!}{(n-m)!}
$$&lt;/p>
&lt;ul>
&lt;li>组合数&lt;/li>
&lt;/ul>
&lt;p>$$
C_{n}^{m} = \frac{n!}{m!(n-m)!} = \frac{P_{n}^{m}}{m!}
$$&lt;/p>
&lt;ul>
&lt;li>相关计算性质&lt;/li>
&lt;/ul>
&lt;p>$$
C_{n}^{m} = C_{n}^{n-m} \\
C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} \\
\Sigma_{i = 0}^{n}C_{n}^{i} = 2^{n}
$$&lt;/p>
&lt;p>这些东西可以用来递推或者化简.&lt;/p>
&lt;p>虽然不知道是什么,但是还是写一下多重集的组合数吧233
$$
对于一个多重集S = {n_{1} * a_{1},n_2*a_2,\dots,n_k * a_k} \\
设整数r&amp;lt;=n_i(i\in[1,k]),从S中取出r个元素的不同多重集数量是C_{k+r-1}^{k-1}
$$&lt;/p>
&lt;p>有时候需要求组合数,接下来给出相关代码&lt;/p>
&lt;ol>
&lt;li>
&lt;p>求一个组合数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">comb&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> m, &lt;span style="color:#66d9ef">int&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, m_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i) n_1 &lt;span style="color:#f92672">=&lt;/span> n_1 &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> m; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> m; &lt;span style="color:#f92672">--&lt;/span> i) m_1 &lt;span style="color:#f92672">=&lt;/span> m_1 &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n_1 &lt;span style="color:#f92672">*&lt;/span> get_inv(m_1, p) &lt;span style="color:#f92672">%&lt;/span> p; &lt;span style="color:#75715e">//假装我们这里有一个求逆元的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个比较慢,&lt;code>O(n)&lt;/code>的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>求很多个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//假设我们有了所有阶乘的取模的值和其逆元的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">return&lt;/span> fac[n] &lt;span style="color:#f92672">*&lt;/span> fac_inv[m] &lt;span style="color:#f92672">*&lt;/span> fac[n &lt;span style="color:#f92672">-&lt;/span> m] &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>二项式定理(杨辉三角形)&lt;/li>
&lt;/ul>
&lt;p>就是那个noip2011 day2t1.
$$
(a+b)^{n} = \Sigma_{i = 0}^{n}C_{n}^{i}a^{i}b^{n-i}
$$&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comb[i][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> comb[i][i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> k; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comb[i][j] &lt;span style="color:#f92672">=&lt;/span> (comb[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">+&lt;/span> comb[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][j&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">%&lt;/span> hhr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2lucas定理">2.Lucas定理&lt;/h4>
&lt;p>$$
C_{n}^{m} \equiv C_{n \bmod p}^{m \bmod p} * C_{n/p}^{m/p} \pmod {p}
$$&lt;/p>
&lt;p>注意,这里的p是&lt;strong>素数&lt;/strong>, 如果是合数的情况,似乎是可以分解来做. 我给的地址里面有讲到.&lt;/p>
&lt;p>唯一的~~例题似乎是BJZOJ1951的古代猪文.比较难,还要合并线性同余方程组(中国剩余定理).不会写&lt;/p>
&lt;p>带Lucas定理的求组合数. 据说在模数比较大的时候不需要Lucas(来自某位dalao)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ll;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> ll &lt;span style="color:#a6e22e">fast_pow&lt;/span>(ll a, ll b, ll &lt;span style="color:#f92672">&amp;amp;&lt;/span>p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ll ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; a &lt;span style="color:#f92672">%=&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; b; b &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (b &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">*&lt;/span> a &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">*&lt;/span> a &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ll &lt;span style="color:#a6e22e">Comb&lt;/span>(ll n, ll m, ll &lt;span style="color:#f92672">&amp;amp;&lt;/span>p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">&amp;gt;&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ll ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ll a &lt;span style="color:#f92672">=&lt;/span> (n &lt;span style="color:#f92672">-&lt;/span> m &lt;span style="color:#f92672">+&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ll b &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">*&lt;/span> (a &lt;span style="color:#f92672">*&lt;/span> fast_pow(b, p&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>, p) &lt;span style="color:#f92672">%&lt;/span> p) &lt;span style="color:#f92672">%&lt;/span> p; &lt;span style="color:#75715e">// 费马小定理逆元
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ll &lt;span style="color:#a6e22e">Lucas&lt;/span>(ll n, ll m, ll &lt;span style="color:#f92672">&amp;amp;&lt;/span>p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (m &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Comb(n &lt;span style="color:#f92672">%&lt;/span> p, m &lt;span style="color:#f92672">%&lt;/span> p, p) &lt;span style="color:#f92672">*&lt;/span> Lucas(n &lt;span style="color:#f92672">/&lt;/span> p, m &lt;span style="color:#f92672">/&lt;/span> p, p) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实还有拓展Lucas定理&amp;hellip;不管了.&lt;/p>
&lt;p>赠送:&lt;a class="link" href="https://blog.csdn.net/acdreamers/article/details/8037918" target="_blank" rel="noopener"
>一个很好的文章&lt;/a>&lt;/p>
&lt;h4 id="3容斥原理">3.容斥原理&lt;/h4>
&lt;p>这个东西说简单也很简单, 但是不是非常好说明.那么一大堆数学公式不但难打,而且看着也嫌烦. &lt;strong>举个例子&lt;/strong>,就是那个高一数学做的集合题, 那个什么参加乒乓球, 篮球还有什么足球的同学一共多少个什么的东西.这个东西在竞赛中的应用大概是把一类计数类问题进行转换,转换成比较便于计算的形式,然后得出结果,通常是什么逆向思维.也有分类之后算总和的时候进行容斥以得出正确的结论.&lt;/p>
&lt;p>因为我自己写得比较烂,理解也非常浅陋,下面贴几个Blog:&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/m0_37286282/article/details/78869512" target="_blank" rel="noopener"
>1&lt;/a>&lt;/p>
&lt;h4 id="4隔板法">4.隔板法&lt;/h4>
&lt;p>&lt;strong>隔板法&lt;/strong>就是在n个元素间的(n-1)个空中插入k个板,可以把n个元素分成k+1组的方法.&lt;/p>
&lt;p>这个东西讲起来比较麻烦&amp;hellip;2333继续放blog(其实是我不会)&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/sdz20172133/article/details/81431066" target="_blank" rel="noopener"
>1&lt;/a>&lt;/p>
&lt;h3 id="6矩阵相关">6.矩阵相关&lt;/h3>
&lt;p>矩阵的基本计算就不说了.&lt;/p>
&lt;p>矩阵考的最多的就是用矩阵来加速多项式的递推计算,也就是矩阵快速幂&lt;/p>
&lt;h4 id="1矩阵快速幂">1.矩阵快速幂&lt;/h4>
&lt;p>先上板子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">matrix&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ll dat[maxn][maxn];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matrix(&lt;span style="color:#66d9ef">int&lt;/span> sz1, &lt;span style="color:#66d9ef">int&lt;/span> sz2) &lt;span style="color:#f92672">:&lt;/span> n(sz1), m(sz2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(dat, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dat));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">friend&lt;/span> matrix &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (matrix a, matrix b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matrix &lt;span style="color:#a6e22e">c&lt;/span>(a.n, a.m);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a.n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a.m; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.dat[i][j] &lt;span style="color:#f92672">=&lt;/span> a.dat[i][j] &lt;span style="color:#f92672">+&lt;/span> b.dat[i][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">friend&lt;/span> matrix &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (matrix a, matrix b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matrix &lt;span style="color:#a6e22e">c&lt;/span>(a.n, b.m);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> c.n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> c.m; &lt;span style="color:#f92672">++&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a.m; &lt;span style="color:#f92672">++&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.dat[i][j] &lt;span style="color:#f92672">=&lt;/span> (c.dat[i][j] &lt;span style="color:#f92672">+&lt;/span> a.dat[i][k] &lt;span style="color:#f92672">*&lt;/span> b.dat[k][j] &lt;span style="color:#f92672">%&lt;/span> p) &lt;span style="color:#f92672">%&lt;/span> p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> matrix &lt;span style="color:#a6e22e">fast_pow&lt;/span>(matrix a, ll k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matrix ans(a.n, a.m);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> ans.n; &lt;span style="color:#f92672">++&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans.dat[i][i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; k; k &lt;span style="color:#f92672">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (k &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) ans &lt;span style="color:#f92672">=&lt;/span> ans &lt;span style="color:#f92672">*&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">*&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2矩阵加速递推">2.矩阵加速递推&lt;/h4>
&lt;p>对于一个递推式,我们可以把它放在某一个矩阵里面.然后它的每一次递推操作可以使用矩阵运算来解决,套上快速幂就会像记者一样.难点主要在于构建单位矩阵.&lt;/p>
&lt;p>以Fibonacci为例:&lt;/p>
&lt;p>我们有
$$
F[n] = F[n-1] + F[n-2]
$$
然后把它放到一个1*2的矩阵里面(我喜欢横着的)
$$
\left[
\begin{matrix}
F[n-1] &amp;amp; F[n]
\end{matrix}
\right] \\
\left[
\begin{matrix}
F[n-2] &amp;amp; F[n-1]
\end{matrix}
\right]
$$
我们希望从上面一个推到下面一个, 于是乎由于&lt;code>F[n-1] = 0 * F[n-2] + 1 * F[n-1]&lt;/code>, &lt;code>F[n] = 1 * F[n-1] + 1 * F[n-2]&lt;/code>,可以得出如下单位矩阵
$$
\left[
\begin{matrix}
0 &amp;amp; 1 \\
1 &amp;amp; 1 \\
\end{matrix}
\right]
$$
我们只要把这个矩阵做上n-1次乘法就可以得到结果了.&lt;/p>
&lt;p>例题很多,就不一一列举了.&lt;/p>
&lt;h3 id="7线性基虽然可能不考">7.线性基(虽然可能不考)&lt;/h3>
&lt;p>这个比较简单，用来求一堆数异或起来的最值问题。主要的做法就是把这一堆数字的二进制给存起来，然后去一个一个异或。用到了向量的思想，不多说，背板子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxbit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">63&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">linear_base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> linear_base() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memset(dat, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(dat));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> dat[maxbit &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> maxbit; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1LL&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>dat[i]){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dat[i] &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">^=&lt;/span> dat[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">get_min&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> maxbit; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dat[i]) &lt;span style="color:#66d9ef">return&lt;/span> dat[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">get_max&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">register&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> maxbit; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((ret &lt;span style="color:#f92672">^&lt;/span> dat[i]) &lt;span style="color:#f92672">&amp;gt;&lt;/span> ret) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">^=&lt;/span> dat[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>附赠:&lt;a class="link" href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener"
>一个很好的文章&lt;/a>&lt;/p>
&lt;h3 id="8概率期望碰到就放弃系列">8.概率期望(碰到就放弃系列)&lt;/h3>
&lt;h4 id="1基本内容-2">1.基本内容&lt;/h4>
&lt;h4 id="2期望dp">2.期望DP&lt;/h4>
&lt;h3 id="9神奇的东西">9.神奇的东西&lt;/h3>
&lt;h4 id="1题目收集">1.题目收集&lt;/h4>
&lt;ol>
&lt;li>Luogu: 斐波那契公约数 gcd(F[n], F[m]) = F[gcd(n,m)]&lt;/li>
&lt;li>Luogu: P4388 phi&lt;/li>
&lt;/ol>
&lt;h4 id="2gcd相关性质">2.GCD相关性质&lt;/h4>
&lt;p>并不清楚有什么&lt;/p>
&lt;h4 id="3几个数列">3.几个数列&lt;/h4>
&lt;h5 id="1-catalan">1. Catalan&lt;/h5>
&lt;p>$$
Cat_n = \frac{C_{2n}^{n}}{n + 1}
$$&lt;/p>
&lt;p>几个常见的情况:&lt;/p>
&lt;ol>
&lt;li>合法括号匹配序列数(n左n右 -&amp;gt; Cat(n))&lt;/li>
&lt;li>合法出栈序列数(n个数 -&amp;gt; Cat(n))&lt;/li>
&lt;li>n个节点构成的不同二叉树的数量&lt;/li>
&lt;/ol>
&lt;p>给个表:1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012&amp;hellip;&amp;hellip;&lt;/p>
&lt;h5 id="2-fibonacci">2. Fibonacci&lt;/h5>
&lt;p>这个就不说了&lt;/p>
&lt;h5 id="3欧拉函数">3.欧拉函数&lt;/h5>
&lt;p>前面有&lt;/p>
&lt;h5 id="4约数个数">4.约数个数&lt;/h5>
&lt;h4 id="4-数论分块">4. 数论分块&lt;/h4>
&lt;p>这个详见余数求和那道题&lt;/p>
&lt;h4 id="5一些结论">5.一些结论&lt;/h4>
&lt;p>$$
(x + 1)^p \equiv x^p + 1 \pmod{p}
$$&lt;/p>
&lt;p>可以用来证明Lucas定理(对于OI来说没什么用)
$$
对于a \perp b, 形如k*a + b的素数有无数个
$$
虽然不知道有什么用&lt;/p>
&lt;h3 id="10致谢">10.致谢&lt;/h3>
&lt;p>百度 cnblogs csdn luogu &amp;lt;算法竞赛进阶指南&amp;gt; &amp;lt;信息学奥赛一本通 提高&amp;gt; &amp;lt;具体数学&amp;gt;&lt;/p></description></item></channel></rss>