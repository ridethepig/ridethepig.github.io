<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>期中随笔</title>
    <link href="/2019/11/16/qi-zhong-sui-bi/"/>
    <url>/2019/11/16/qi-zhong-sui-bi/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这应该会是一坨非常混乱的文字</p></blockquote><p>不知不觉高三已经过去了四分之一，我也不知道我是怎么过来的。今天考完了期中，正因为没有什么特别的感想，所以才会想让自己有些什么感想。毕竟是无比平凡的、卑微的人生，平时也没有什么波澜壮阔的事情可以记述吧。</p><p>在一开始，我必须表示一下我对高三的迷惘。我貌似完全不知道高三应该是个什么样子，现在唯一的感觉就是花在代码上的时间变少了。或许每一届、每个班甚至是每个人的高三都是不同的吧，高三可能并没有它应该的样子，它可能只是一段比较忙碌的时间。所有听说的、书里说的高三，都在这半个学期里变得模糊。高二时老师讲的故事，似乎没有什么实感，不知道是老师们把高三神化了，还是这一届和他们就是这么的不同。按照初中的感觉来看，貌似比较像是前者。高一教师节回去看老师的时候（我自己不是那种和老师关系比较好的那种学生，也因为家长圈子的原因被排除在某个集团之外），阴差阳错的就我一个人去了。当时跟我斗智斗勇过的老班就表示，“真是一届不如一届了啊”（九斤老太太乱入），“其实你们那一届真的是很好的学生啊”。不过谁知道呢，在其位，谋其政，只有自己的高三才是最真实的那个吧。虽然不能犯经验主义错误，但是我还是觉得，就像初三一样，过去了，感觉也没什么。不知道明年的这个时候我是不是会有同样的想法。</p><p>过到高三，我反而觉得有点小轻松了（当然除了接下来要说到的语文数学这种垃圾），其原因主要在于考试变多了。我一向喜欢考试，具体说来是考试之前和考试之中，因为考试之后会面临家长问责和同学之间无休无止的比较。俗话说，君子周而不比，小人比而不周，真不知道为什么这些人这么热衷于这种毫无意义的、汲汲于名利的事情，搞得我也不由得紧张起来。然而考试的其余两个部分就十分快乐了，可以在第一天晚上复习的时候摸一会鱼，可以早上多睡一节课，还可以中午悠闲一点，实在是平日里的苦逼生活的“偷的浮生两日闲”，不对，这怎么能叫做偷呢，这显然是对我考试之后承受的苦难的应有补偿。除了考试多，或许我们班同学过于努xū力wěi，反衬出我的闲？不太清楚，不过这也和我没有多大关系就是了，但是他们会让这个班变得不太和谐，我不是很喜欢。</p><p>说到班级，我除了这个班提供的师资，其余一概不喜欢，也不想要。这个班人多，逼仄得让我甚至想要做掉几个让教室空旷一点。（唯一的好处可能是冬天有免费空调效应，省了空调费？）每天晚自习就算开窗通风也会有一股奇怪的人肉的味道，让人头昏（或许东京餐馆会比较喜欢？），更何况经常闷一个晚自习。这个班异常虚伪，尤其是后排，除了几个共享华为的，其余都处于一种半公开的对峙状态，竞争的氛围让我想吐。更让我感到悲愤的是，我自己也不知不觉中被同化了，也会时不时参与到他们的“虚伪”的行为之中：总是害怕自己落后，自己不够用功，时常强行围观别人在做什么，说着违心的话，表面称赞实则是不甘，看到别人不如自己会嘲笑窃喜……简直病态到了极点。我已经开始尝试让自己变得更加随性一点，避免和他们一样陷入无畏的竞争恐慌之中，但是我不知道我能不能抵挡住环境的影响，毕竟“环境塑造了我们，决定了我们的可能性”（萨特）。我想要真正的孤独，而不是在表面的和谐合群背后的隔绝。现在只有从食堂回来的路，每每那时的落叶和傍晚，才能给我这样的孤独，回到班上，我就被迫变成自己所厌恶的那个样子，谈着一些无关紧要的话，一起笑着一些不知道怎么回事的东西，享受着劣质茶叶班简陋的“快乐”。但是我却无法拒绝，每次都会忘记深夜的自我厌恶，“开心”地笑着。真是个可悲的人。</p><p>至于学习，这种至关次要的话题，当然要少抱怨几句。数学天天爆炸，语文从来没考号过，英语逐渐失去优势，物化徘徊在A线边缘，差不多就是这样。所谓书到用时方恨少，从来就不是一句空话。高一高二欠下来的债，可能到高考都还不清。但是我对于这件事，并不是特别的后悔，真正后悔的是把自己一生仅有一次的高中生活浪费在竞赛这种无聊的事情上，而没有早一点认清事实，去追求自己正真的所爱。如果我把竞赛的时间投入到更加令我着迷的事情上（比如计算机系统，比如社会学），我想我应该会走过一段充实的青春，并且不会在某个时候愤怒地写下这样的、失败者的、无用的抱怨与悔恨。可惜青春已经腐朽，沉舟侧畔，是千舟的碎片。我只有带着这样的悔恨，告诫自己和那些还没有后悔的人，只有真正的“into”一样东西，它才值得坚持下去。而不是为了那零星的、甚至根本是虚假希望，以为自己还差一点就能成功，从而失去了更加美好的东西。明天又是noip，希望我的后死者们，无悔。</p><p>今天只能写这么多了，剩下的，就下次再说吧。我可能会写一些关于天才的看法（雾）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年8月踩坑记录</title>
    <link href="/2019/08/18/2019-nian-8-yue-cai-keng-ji-lu/"/>
    <url>/2019/08/18/2019-nian-8-yue-cai-keng-ji-lu/</url>
    
    <content type="html"><![CDATA[<h2 id="Rust相关"><a href="#Rust相关" class="headerlink" title="Rust相关"></a>Rust相关</h2><p>首先说结论：没事别用这玩意。</p><p>语法简直毒瘤，令正常人难以接受。<br>各种毒瘤机制概念让这门语言看起来很安全其实很智障，我宁愿在C语言里面指针满天飞也不要看到rust里面神tm所有权和生命周期。<br>编译器简直比妈还烦，各种不通过。<br>包管理器还算可以但是国内镜像不知道为什么用不了。<br>IDE支持简直吃*，甚至不如拿notepad++写。</p><p>虽然我必须承认它的内存管理和运行速度(actix的跑分令人震惊)一流，但是人生苦短，何必用rust？</p><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><h3 id="lock文件简直毒瘤"><a href="#lock文件简直毒瘤" class="headerlink" title="lock文件简直毒瘤"></a>lock文件简直毒瘤</h3><p>突然不知道为什么taobao源用不了了，查了半天发现lock文件里面把registry一起固化了，wtf？！于是删掉以后一个小时的Install几分钟就结束了。</p><h3 id="cnpm出了锅"><a href="#cnpm出了锅" class="headerlink" title="cnpm出了锅"></a>cnpm出了锅</h3><p>不知道为什么在安装的时候cnpm创建了许多无效的link，然后VSCode插件就一直找不到模块。然后改成npm重新install一遍就立马好了。。。</p><h3 id="Simple-is-Best"><a href="#Simple-is-Best" class="headerlink" title="Simple is Best"></a>Simple is Best</h3><p>electron的各种模板配置了半天就是有几个module装不好。<br>于是手动init一个，在npm install一波，就很靠谱。</p><h3 id="VSCode的插件文档"><a href="#VSCode的插件文档" class="headerlink" title="VSCode的插件文档"></a>VSCode的插件文档</h3><p>简直跟WindowsApi和DotNet Framework的文档比不起来，有损微软文档的名誉。不仅没有几行示例代码，而且还不告诉一个函数在哪个空间里面，导致我找一个clipboard就找了半天。后来还是在别人的代码里面翻到的。记一下，clipboard在<code>vscode.env</code>里面</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>系统日常</title>
    <link href="/2019/05/25/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%B8%B8/"/>
    <url>/2019/05/25/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="系统日常工具"><a href="#系统日常工具" class="headerlink" title="系统日常工具"></a>系统日常工具</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>有时候会发现Linux下面的软链接和硬链接还是十分有用的，于是想Windows下面是不是也有这个东西，居然甚至有。</p><h3 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title="软链接（符号链接）"></a>软链接（符号链接）</h3><p>NTFS只支持对目录的软链接，微软把它称作 junction。但是对于文件的软链接，微软也有提供解决方案，那就是快捷方式(Shortcut，.lnk 文件)。不过软链接和快捷方式不是一个层次上的东西，前者是底层文件系统的功能，后者是应用层的功能。Windows 下目录的快捷方式用 dir 看起来是个文件。</p><p>junction 的命令语是：</p><div class="hljs"><pre><code class="hljs powershell">junction  LinkDirectory ExistingDirectory</code></pre></div><p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/junction" target="_blank" rel="noopener">下载地址</a></p><p>例如<code>junction d:\link c:\winnt</code>将为<code>c:\winnt</code>建立一个链接目录 <code>d:\link</code>，C和D分区都要是 NTFS 格式，在资源管理器和 <code>dir</code> 列示中 <code>d:\link</code> 都以目录的面目存在的。<code>d:\link</code> 就像是 <code>c:\winnt</code>的一个引用一般，删除 <code>d:\link</code> 目录中的内容也就是删除了 <code>c:\winnt</code> 中的内容，但删除 <code>d:\link</code> 本身是不会影响到 <code>c:\winnt</code> 的。</p><p>相应的，在程序中也有一个 API 函数 <code>CreateSymbolicLink</code>支持创建软链接，不过来得太晚了，要 Windows VISTA 和 Windows Server 2008 那样的版本才支持，先还是别想了，API 原型是：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">BOOL WINAPI <span class="hljs-title">CreateSymbolicLink</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  __in  LPCWSTR lpSymlinkFileName,</span></span><span class="hljs-function"><span class="hljs-params">  __in  LPCWSTR lpTargetFileName,</span></span><span class="hljs-function"><span class="hljs-params">  __in  DWORD dwFlags</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-comment">/*</span><span class="hljs-comment">参数：</span><span class="hljs-comment">lpSymlinkFileName 要创建的符号链接名称.</span><span class="hljs-comment">lpTargetFileName 符号链接所对应目标的名称.</span><span class="hljs-comment">dwFlags 标识目标是文件还是目录. 取值0x0 代表是文件，SYMBOLIC_LINK_FLAG_DIRECTORY或0x1 代表是目录</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>语法</p><div class="hljs"><pre><code class="hljs powershell">fsutil hardlink create NewFileName ExistingFileName</code></pre></div><p>参数</p><div class="hljs"><pre><code class="hljs plain">create 建立现有文件和新文件之间的 NTFS 硬链接。NTFS 硬链接与 POSIX 硬链接相似。NewFileName 指定要将创建硬链接的文件。ExistingFileName 指定要从中创建硬链接的文件。</code></pre></div><p>这个东西要求在一个分区里面，如果不是很清楚为什么，自己百度</p><p>当然，如果你想在自己的程序里创建硬链接，那也是很容易的，只需要一个很简单的 API 函数:</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">CreateHardLink</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    LPCTSTR lpFileName,</span></span><span class="hljs-function"><span class="hljs-params">    LPCTSTR lpExistingFileName,</span></span><span class="hljs-function"><span class="hljs-params">    LPSECURITY_ATTRIBUTES lpSecurityAttributes</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><p>适用于 Win2000 及以上版本的系统，最后一个参数的用途保留，必须为 NULL。</p><p>正常使用软连接比较方便。</p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>进入设置搜索clipboard，然后打开剪切板记录，最后<code>Win+V</code>会出现奇迹</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>周记2019-05-18</title>
    <link href="/2019/05/18/%E5%91%A8%E8%AE%B02019-05-18/"/>
    <url>/2019/05/18/%E5%91%A8%E8%AE%B02019-05-18/</url>
    
    <content type="html"><![CDATA[<h1 id="周记2019-05-18"><a href="#周记2019-05-18" class="headerlink" title="周记2019-05-18"></a>周记2019-05-18</h1><p>闲着无聊又开始写周记了…这种事情本来就是无所谓有也无所谓无的.</p><p>最近还真的是忙到爆炸, 每天作业写不完, 感觉自从小高考结束以来, 作业就一天天增多, 身形日益憔悴枯槁. 不管它了, 这种伤心的事情还是少提比较好. </p><p>不过话说回来,最近也没啥想做的事情, 因为手头上的事情已经够我做的了. </p><p>首先呢, 大概是我开始减肥了, 主要是因为夏天要来了, 太胖会热得难受. 这是一个艰苦漫长的过程, 会导致每天更加的不想动. 外加这些天的诡异天气, 空气相对湿度可达80%左右,也真的是很无奈了, 每天坐着也是一身难受.</p><p>然后应该就说一下新坑(然而不幸的是, 我的旧坑才填了一点点). 最近因为重启一次十分钟, 所以干脆把系统重装了一遍. 感觉Windows10的重装体验越来越棒了, 这次甚至用语音完成了整个设置过程2333…感觉新系统要做的好一点,于是采取了一些措施, 比如使用专业的卸载器保证卸载干净, 还有拒绝了绝大部分国内软件,发现其实FDM比XL差不了多少,还不流氓. 至于新坑, 就是感觉自己需要手动管理自己的环境变量, 准备做一个以组为单位的环境变量管理工具, 并支持备份导入等常用功能, 自用还不太需要界面好看, 好用就行了. 旧坑(就是那个Pdf2Txt扫描器)进行的并不是很顺利(虽然把后台写完了, C++万岁), 不过我可以用”长期项目”来安qi慰pian自己, 主要是还没有时间处理Pdf控件的整合问题, 有可能还得自己动手吧封装的外部控件给整合进来, 感觉现在的设计极差.</p><p>最后是, 排球. 这真是一项令人厌恶的运动, 它不仅砸碎了我一个杯子, 昨天还给我的头来了一下, 简直是F***. 最近的排球比赛也真是毒瘤至极, 释放了学生们无处安放的青春……</p><p>就酱紫吧.</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记2019-03-11</title>
    <link href="/2019/03/31/%E5%91%A8%E8%AE%B02019-03-11/"/>
    <url>/2019/03/31/%E5%91%A8%E8%AE%B02019-03-11/</url>
    
    <content type="html"><![CDATA[<h1 id="周记2019-03-11"><a href="#周记2019-03-11" class="headerlink" title="周记2019-03-11"></a>周记2019-03-11</h1><p>最近发生了各种奇奇怪怪的事情，先是结束了终末的春游，然后又控制台一日游，下个星期还要月考，简直令人匪夷所思。</p><p>一件一件说吧。</p><p>春游自然是寂寞的一人のjourney了，还偏偏是去了DisneyLand这种Rich in Couples的鬼地方，着实令人心中好不快意。不过玩得还是很高兴的，和LittleHH先跑完了所有的印章收集，然后趁着人少的时候去刷项目，剩下来的时间就坐下来瓜皮。因为学校的集合时间要求，导致没有看完烟火表演，有点遗憾吧。最后一个人走在班级的后面，游乐园外的广场上，在Shanghai的夜空下，远离了繁华喧嚣，卿卿我我，感觉一个人也没什么不好的。貌似在很多番的倒数几集里面都有类似的意境，不过是两个人和一个人的区别，也没什么大不了的。另外一个感悟就是：学校旅行嘛，总会有一个和你一样孤独的人和你机缘巧合分到一间房间的。<br>第二天的沙家浜就<strong>很无聊了</strong>。不想说什么，又热又累。尽是古建筑公司在建所谓的“古建筑”，呵呵。TQQ大佬表示：到今天，还有多少人能够虔诚地来“红色之旅”呢？But who cares?</p><p>至于控制台一日游，周四彩排之前，被英语老师临时抓到那边去负责课本剧的PPT相关的事情，然后就是我了2333。LHH说我是最好说话的一个，因为我总是无条件答应它们换PPT的要求，还自行去催PPT。周六早上才是真的懵，7点20到控制台，预计是8点开始，结果那边话筒出锅，信号源爆炸，舞台插座电源不通，还有人要换ppt？！更加窒息的是人手严重不足，外加某个毒瘤工程师去度假了？！！！我也不太清楚。过程中大概出了几个锅，貌似唯一由我导致的是第二个班的ppt我点快了，有一段音乐没放出来。然而不知道为什么第一个班非要喷我说视频放得差，我很好奇放个视频为什么会有好坏之分，甚至也没有人告诉我什么时候放、怎么放，就随便瞎喷，还说破坏了它们作品的完整性，简直一派胡言。也算是了解了，控制台不出锅是不可能的，只不过是被多少人喷和被喷成什么样子的区别罢了，感觉这次貌似后半场还不错。LHH表示控制台从不背锅，被喷多了，也就一笑了之了。真是锻炼心理素质。以后估计也没什么机会到控制台了，不过学生会的成员还是比较温暖的，居然有Starbucks供应。</p><p>以及感觉我的blog要迁移到hugo了，hexo过于窒息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&#39;别了,政史地生&#39;</title>
    <link href="/2019/03/15/%E5%88%AB%E4%BA%86-%E6%94%BF%E5%8F%B2%E5%9C%B0%E7%94%9F/"/>
    <url>/2019/03/15/%E5%88%AB%E4%BA%86-%E6%94%BF%E5%8F%B2%E5%9C%B0%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>明天就是所谓的小高考了，感觉白忙一场。不加分，也不知道还有啥用，没有马克思我照样买咖啡，没有卡尔文循环我照样吃饭，不知道几百年前发生了什么我依然向前看，顶多地理有点用，可以出去玩。</p><p>但还是就这么复习了，后天也就结束了。</p><p>有些人努力了，有些人没有。有些人轻松4A，有些人家徒4B（嗯，就是我）。</p><p>如果说还有什么不安的话，那应该是，我不知道我在仅仅一年以后还会不会记得我学了什么，会不会记得我也曾认真地学过这些课程；更不用说当我忘记了函数和解几的时候还会留下点什么。</p><p>常说最重要的是在忘记一切所学的东西之后还留下些什么。但我的答案是：可能啥也不剩了。</p><p>不要说对大四门的老师有什么感激，可能最大的慰藉就是在高考之前，我仍然可以说出哪一年发明汽船，仍然可以用辩证法侃侃而谈，仍然可以算一算遗传，仍然可以看出背斜成山……</p><p>从大四门的神坛跌落，它们即将不复存在。</p><p>课代表的日子也就此结束了，可能是最后一次了。</p><p>即将说再见了，政史地生。</p><blockquote><p>Should old acquaintance be forgot,<br>   and never brought to mind?<br>Should old acquaintance be forgot,<br>   and auld lang syne?</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>高考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幸运加成</title>
    <link href="/2019/03/04/%E5%AD%A6%E6%B5%8B%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/"/>
    <url>/2019/03/04/%E5%AD%A6%E6%B5%8B%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p align="center"> <font color="#C04652" size=10>学测</font></p><p align="center"><font color = "#40A9B3" size=14>强制</font></p><p align="center"><font size = 11 color="#C37448">幸运</font><font size = 5 color="#C5AD4B">加成!</font> <font color = "#55C241">#_#</font></p><p align="center"><font size = 11 color="#C04652">&nbsp;A<sup><font color="#C37448" size="5">4</font></sup></font> &nbsp; &nbsp; &nbsp;<font size = 5 color="#C5AD4B"><u><b><i>预定!!!</i></b></u></font> <font color = "#55C241">&nbsp;&nbsp;(^_^)</font></p>]]></content>
    
    
    
    <tags>
      
      <tag>高考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zeroc Ice相关</title>
    <link href="/2019/02/17/Zeroc-Ice%E7%9B%B8%E5%85%B3/"/>
    <url>/2019/02/17/Zeroc-Ice%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目打算把计算密集的部分分开来做，以后也比较好扩展什么的。于是就想到了用socket。本来时打算自己写socket服务器的，但感觉实践一下RPC也没什么不好的，于是就开始找RPC的框架。不幸的是，所有文档完善的框架都只支持Java，所有多语言的框架文档就很吃X，极其郁闷。<br>最后在Thrift和Ice之间纠结了一下还是选择了Ice。(主要是它的文档相对好一点，Thrift就只剩下Demo了)</p></blockquote><h2 id="What’s-Zeroc-Ice-简介Zeroc-Ice"><a href="#What’s-Zeroc-Ice-简介Zeroc-Ice" class="headerlink" title="What’s Zeroc Ice 简介Zeroc Ice"></a>What’s Zeroc Ice 简介Zeroc Ice</h2><p>Zeroc ICE = Zeroc Internet Communication Engin,是一个RPC(Remote Procedure Call)框架,本质上就是对WebAPI的另一种封装.不同于http的API,RPC主要是直接从socket走,比http要快一个级别.至于具体的RPC的执行过程,自己问GOOOOOOOGLE吧,关于RPC的介绍可比关于ZerocICE的介绍要多几个数量级. Zeroc ICE的介绍主要看它的documentation,写的真的是非常的棒,除了它真的比较长,其余堪比MSDN.不过这也是它本身的强大功能和复杂性所必然导致的,没有个半年估计是学不完的.</p><p>不过在小项目里面,这个就真的只是一个RPC框架,但是这个东西貌似还可以做分布式,还有一大堆管理组件和容错以及并发机制,感觉十分的强大.</p><p>我反正只用到了一点点东西.主要是基础的RPC功能和自动线程池.</p><h2 id="Tips-提醒"><a href="#Tips-提醒" class="headerlink" title="Tips 提醒"></a>Tips 提醒</h2><p>待续…</p>]]></content>
    
    
    
    <tags>
      
      <tag>后端综合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF 开发札记</title>
    <link href="/2019/02/11/WPF-%E5%BC%80%E5%8F%91%E6%9C%AD%E8%AE%B0/"/>
    <url>/2019/02/11/WPF-%E5%BC%80%E5%8F%91%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>高中的最后一个项目，用WPF来做的。算是尽了对M$的信仰了。碰到了一些坑，也找到了一些很好的轮子，在此mark</p></blockquote><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="内存泄漏2333"><a href="#内存泄漏2333" class="headerlink" title="内存泄漏2333"></a>内存泄漏2333</h3><p>我居然碰上了C#内存泄漏！！！！！</p><p>虽然说是内存泄漏，不过估计是bitmap的资源不知道怎么搞得崩了，貌似没有释放掉。貌似那个是个大佬写的轮子，<a href="http://www.cnblogs.com/zhouyinhui/archive/2010/08/20/1804762.html" target="_blank" rel="noopener">链接</a>。不知道为什么，我尝试去修这个东西，不过因为写的有点复杂，就放弃了。那个还是我第一次用内存快照分析对象，感觉比较强大。WPF的完善的截图控件本来就不多，还碰上个内存泄漏的，于是我就改设计了。</p><h3 id="dll-调用"><a href="#dll-调用" class="headerlink" title="dll 调用"></a>dll 调用</h3><p>首先是注意位数。经常搞混release/debug，x86/x64。调错了直接爆炸。</p><p>不过还是得说M$做的Native调用还是很良心的，比Java的那一套要舒服的多。</p><h3 id="bitmap系列"><a href="#bitmap系列" class="headerlink" title="bitmap系列"></a>bitmap系列</h3><p>写到这块的时候再一次真切地感受到了我对Windows简直一无所知。整个Win32 API 和 .NET Framework实在是太庞大了，貌似大家不停的造轮子有相当一部分是因为他们不知道M$已经写好了。。。</p><p>WPF里面貌似没有Bitmap(要引用WinForm的程序集)。不过有什么各种bitmap的包装，多的要命。</p><h4 id="截取部分图片"><a href="#截取部分图片" class="headerlink" title="截取部分图片"></a>截取部分图片</h4><p><code>CroppedBitmap</code>可以用来截取一个<code>BitmapSource</code>对象的一部分，作为一个新的<code>BitmapSource</code>返回出来。</p><p><strong>大坑</strong></p><p>从<code>ImageSource</code>向下转型到<code>BitmapSource</code>的时候，会出现<del>TMD</del>问题，不知道为什么它的分辨率崩掉了。<del>后来看了一眼，发现<code>ImageSource</code>压根就没有<code>DpiX</code>和<code>DpiY</code>这两个属性woc？？？郁闷至极。干脆就不从<code>ImageSource</code>走，直接加载图片然后向上转，再贴到<code>Image</code>里面，安全。</del><br>后来发现，其实是Wpf某些毒瘤机制的锅。在计算截图的时候，应该使用PixelWidth/Height属性，而不是Width和Height属性。CNM！！！！</p><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>我是用surface pro做开发机的，遇上了high dpi和缩放的问题2333333。暂时还没有找到什么解决方案，不过现在想想好像还用不到这个。</p><h2 id="轮子"><a href="#轮子" class="headerlink" title="轮子"></a>轮子</h2><h3 id="canvas矩形框"><a href="#canvas矩形框" class="headerlink" title="canvas矩形框"></a>canvas矩形框</h3><p>类似于截图的时候可以拖动缩放的框子。网上有不少现成的轮子，这个用WPF自带的控件实现的，感觉不错，不过定制性不佳(可能是我太菜了)。</p><p><a href="https://www.codeproject.com/Articles/22952/WPF-Diagram-Designer-Part-1" target="_blank" rel="noopener">Link</a></p><h3 id="Pdf控件"><a href="#Pdf控件" class="headerlink" title="Pdf控件"></a>Pdf控件</h3><p>这个大部分是要收费的，要么就是只有那个毒瘤的ActiveX的Adobe做的控件，功能还很垃圾。开源控件不多，有个Pdfium(Google开源的C++库)的.Net封装，不过对WPF非常不友好，WPF的封装甚至不如WPF开WinFromHost好用。我也懒得自己再调它写好的Wrapper，干脆换一个。最后暂时决定用MoonPdf这个东西，是用PDF页面截图的方式实现的控件。貌似它最后还是用的是Pdfium这个dll(233333333)。我大概魔改了一下，准备直接在上面铺一个Canvas什么的。</p><p>还是想要吐槽一下那些毒瘤的卖控件的家伙，尤其是那个什么grapecity。。。</p><p><a href="https://github.com/pvginkel/PdfiumViewer" target="_blank" rel="noopener">Link:PdfiumViewr</a><br><a href="https://github.com/reliak/moonpdf" target="_blank" rel="noopener">Link:MoonPdf</a></p><h3 id="界面库"><a href="#界面库" class="headerlink" title="界面库"></a>界面库</h3><p>“每一个学不好英语的人都有一个学好英语的梦想。”<br>这个是我在期末考试的时候听到考场外面一个人一边跑一边大叫着说的。</p><p>其实写界面也是一个道理吧。我就是那个写不好前端的人。不过界面库可以帮助我实现梦想。那天看到了这个MaterialDesign的Xaml界面库，做的是真的良心。</p><p><a href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit" target="_blank" rel="noopener">Link</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出WPF笔记</title>
    <link href="/2019/02/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWPF%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/02/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWPF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在写高中最后，也是最宏大的一个个人项目，要用到WPF，于是就打算系统地学习一下WPF。因为不可能全部记住，所以把一些记不住但是可能比较重要的东西记下来。</p></blockquote><p>基本的XAML语法和基本的控件概念用法就不说了。</p><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><ol><li>统一使用<code>x:Name</code>来给xaml对象命名</li><li><code>x:FieldModifier</code>用来在xaml里面修饰<em>实例化</em>的对象的访问限制级别(与下面的ClassModifier像区别)</li><li><code>x:Class</code>和<code>x:ClassModifier</code>这两个东西基本不用管他们</li><li>有些东西放到资源那一节里面吧</li></ol><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><blockquote><p>待续。。。。。。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018年终总结</title>
    <link href="/2019/01/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2019/01/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>年终总结总是最麻烦的事情, 估计要写好久, 于是从今天晚上就先开始吧 ————2019-01-29</p></blockquote><h1> <font color="#c04652">2018年年终总结</font><sup><font size="1">重磅大标题</font></sup> </h1><p>一年又结束了， 不知怎得，高中已经过了一半了。这一年里，发生了不少事情，说大不大说小不小。每逢年关岁末，总会不知怎的生发出一些愁情，这些事情也便全都涌上心头了。有些事情说了不好，不说也难受。正如史铁生著名的那句，<code>“要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。”</code> 大概是这样的感觉吧。</p><p>后来想想，还是说吧。与其自己难受，不如说出来，让看到它的人们难受。</p><p>大概从什么地方说起呢？高一下的记忆早已模糊了，不过痛心的事情总还是记忆尤新的。首先是选科吧。不知道以后想干什么，就会比较容易受到别人的影响。当时主要是纠结选化学还是生物的问题。无论是家长还是某些毒瘤人士都说选化学好，以后上大学有好处，但是从现在的角度看来，还是先考上个什么大学比较现实，至少不要因为选修的原因而影响大学录取。现在的现实是，我的化学拿个A都困难，更别说是A+了。如果当时选的是生物，估计就完全不需要管选修科目了。选择总是难免而艰难的，尤其是关系到人生路线的那种选择，选错了，会遗憾好久，直到终结。至于上文的毒瘤人士，我知道就好，别人知道了不好。<br>然后是竞赛。虽然之前关于竞赛写了很多，但是这里还是要写上去的。今年的竞赛，也是几年以来的竞赛，让我切身体会到：人是有极限的，无论哪条路都是艰难的，我是不适合竞赛的，我是不喜欢竞赛的。现在的我依然庆幸自己已经放弃了竞赛，依然在后悔自己没有早点放弃，因而错过了生活中无数闲暇美好的东西，很多应该细细品味的书。人说吃一堑长一智，然而我吃的是不是太撑了一点呢？</p><p>学校生活什么的，最无聊了。一个个装弱、互膜，一个个偷学、竞争，一个个虚伪至极。什么鬼班级，什么鬼同学。草。只有这个时候，才会怀念竞赛生活，至少大家还比较真诚。在这个班里，我还收获了真正讨厌的同学，头一次感到人情的无奈，社会生物的无奈。为此，我还头一回买了耳塞。冷笑。算是彻底打破我对好成绩和好人格的等价观念。<br>不过这个班的老师倒还不错，除了政治，都比较可爱。<br>最重要的是，我对天分和努力这两样东西有了更深层次的理解，不过这使我更加不想努力了，在努力之后依然比不过天才们的感觉，还是很不爽的，相信这种感觉以后会更加强烈。</p><p>说一说未来吧。无论我们如何叹惋于过去，明天总将到来。唯一的区别是，它照在哪里：床头还是？头。<br>特别喜欢鲁迅先生的一句话，“希望是本无所谓有，无所谓无的。”在这个充满激情澎湃标语的国家，在这个看似洋溢着活力的国家，我们真的有希望吗？这样一个需要不停自己给自己洗脑的国家，能有什么希望？最近一直在看李零先生的杂文集，也看了章怡和以及其他一些，又一直被政治作业折磨着，不由地对这个国家感到绝望，更对自己无力逃离而无奈。我们没有任何发声的权力，没有自由访问网络的能力，只有所谓的自由，那血淋淋的廿四个字里的自由。所有的官僚主义，压在我们身上的十万群山，资本驱动的利益社会，浮夸风和形式主义，依然存在甚至藏得更深，甚至无法揭露，无人听闻。一想到自己终究有一天会被这样的社会，这样的环境所吞没、同化，突然就失去了动力，无法继续前行。苏联，就算从17年算起，到91年，一共74年。这个国家呢？今年七十了。我们拭目以待。<br>高考还在继续，我还是要在矛盾中前行，在这个乌烟瘴气的社会里，在腐朽残酷的制度里，在早已死去的学校里，在虚伪的学生群里，坚强的活下去；无论是否有人能够真诚地陪伴，无论最终成绩如何。</p><p>还有半个小时就明年了，我先去□一会。<br>禁放爆竹的唯一好处，是我现在可以在这个平凡的夜晚安静片刻。</p><p>2019.02.04 23:31</p>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于</title>
    <link href="/2019/01/25/about/"/>
    <url>/2019/01/25/about/</url>
    
    <content type="html"><![CDATA[<p><strong>Welcome</strong> to Prisrak Smalin’s blog!<br>欢迎来到Prisrak Smalin的blog！</p><p>Post: Senior 3 Student<br>Domain: OS, Full-stack</p><p>在下高三党<br>主要方向是操作系统和全栈开发</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>幸运加成</title>
    <link href="/2019/01/11/%E6%9C%9F%E6%9C%AB%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/"/>
    <url>/2019/01/11/%E6%9C%9F%E6%9C%AB%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p align="center"> <font color="#C04652" size=10>期末</font></p><p align="center"><font color = "#40A9B3" size=4>强制</font></p><p align="center"><font size = 11 color="#C37448">幸运</font><font size = 5 color="#C5AD4B">加成!</font> <font color = "#55C241">#_#</font></p><p>前来还愿！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记2018-12-22</title>
    <link href="/2018/12/22/%E5%91%A8%E8%AE%B02018-12-22/"/>
    <url>/2018/12/22/%E5%91%A8%E8%AE%B02018-12-22/</url>
    
    <content type="html"><![CDATA[<h1 id="周记-2018-12-22"><a href="#周记-2018-12-22" class="headerlink" title="周记 2018-12-22"></a>周记 2018-12-22</h1><p>之前因为各种各样的考试停更了两周, 几个小时之前刚刚考完月考(月考爆炸就不多说什么了), 趁着Cloning repository 的时候来写一点东西(话说那个repo还真的是好大啊, 作者不知道在干什么). </p><p>之前的VSC插件项目写完了, 没少看MS的文档, 其实还是很良心的, 只不过这个方面国内的资料比较少. 写的是一个7成品, 虽然还是没有到可以用的地步, 不过已经不想再调试了. 下个项目已经提上日程, 这个插件的话如果哪天嫌手动发blog烦了, 可以稍微再修一下. 至于下一个项目, 打算再思考一会再post出来. 依然是一个实用工具.</p><p>最近打算再开一个小说的坑, 鉴于我大部分的时间还是在学校里, 所以它自然是写在我的摘抄本的后面了. 前几天在听歌的时候想到的. </p><p>至于学校生活, 自然无聊而虚伪的. 周围的巨佬们依然在一边相互膜来膜去, 一边死命偷学. 我能基本完成作业就算是好的了. 时不时有一点有趣的新闻传出来, 也不过是谁又分了之类的东西. 为现代中学生的无聊生活感到抱歉. 完全不知道我们为什么要为了高考这种无聊的东西而拼命. 很快就要圣诞节了, 又到了白色相簿的季节了, 只不过我没有gf, 天也没有下雪, 不过如果能够看到白学现场, 那也是很好的. </p><p>最近发现了一个暂时能用的项目管理软件, UWP的, 叫<code>Project Studio</code>.</p><p>不过没有什么轻巧好用的流程图软件, 要么要很多很多Dollars, 要么就是太TMD大了. </p><p>这个Repository的作者真的TMD毒瘤, 非要把一堆二进制文件放到Repo里面, 为难我这种网络环境不好的Code Farmer.</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记2018-12-01</title>
    <link href="/2018/12/01/%E5%91%A8%E8%AE%B02018-12-01/"/>
    <url>/2018/12/01/%E5%91%A8%E8%AE%B02018-12-01/</url>
    
    <content type="html"><![CDATA[<h1 id="周记2018-12-01"><a href="#周记2018-12-01" class="headerlink" title="周记2018-12-01"></a>周记2018-12-01</h1><p>本来不打算写的, 因为今天打算把VSC插件的基础架构写出来, 比较的时间紧张. 不过趁着生成项目是时间来稍微说一两句.</p><p>又是无聊的一个星期, 每天就是在看书和写作业之中度过. 鉴于上个周末找到了想看到Light Novel, 所以不算过的太无聊. 在地上的时候, 就靠着一本微积分和一本朱光潜勉强度日. 作为一个理科班的学生, 自然需要提升语文素养了…</p><p>今天不得不说是多灾多难的一天, 早上既写了作文, 还考了周练, 周练还考得特别差. 感觉十分绝望. 迄今为止我还是非常好奇我是怎么被分进这个班的233333. </p><p>最近几天雾霾严重, 整个人都不是很好, 前几天还因为下雾看不见然后骑车摔残了. </p><p>还有什么毒瘤的文名城检查, 要背那个什么价值观还有什么毒瘤的文明礼仪, 我自然是什么也不会, 不过貌似连小学生和幼儿园小朋友都受到了这种东西的荼毒, 不经觉得一丝无奈: 这个国家已经变成这个样子了吗? 不想说什么. 至于如果被问到了, 那我应该会先甩出素质n连, 然后告诉他们我啥都不知道, 然后仰天长啸, 扬长而去. </p><p>至于我的开发计划, 今天已经把插入header部分基本做好了, 也知道了不少奇奇怪怪的API和它们的调用方式, M$的文档做得一直很好(虽然没有看过Google的, 毕竟GFW). M$在GitHub上面VS Code的issues里面也有不少好东西, 实在查不到的的时候可以去那个地方翻一下. 不过这种东西的调试就比较的呵呵了, 毕竟是JS系列的东西(虽然我用了Typescript). 也大概了解了什么JS那一套毒瘤玩意儿, 简直是对编程语言的侮辱. 下个星期会把这一部分完善一下, 然后准备写命令行交互的部分. 还要先把configuration部分的设计在下个星期先想一下. </p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记2018-11-24</title>
    <link href="/2018/11/24/%E5%91%A8%E8%AE%B02018-11-24/"/>
    <url>/2018/11/24/%E5%91%A8%E8%AE%B02018-11-24/</url>
    
    <content type="html"><![CDATA[<h1 id="周记-2018-11-24"><a href="#周记-2018-11-24" class="headerlink" title="周记 2018-11-24"></a>周记 2018-11-24</h1><blockquote><p>这是第二篇周记, 只要以后周末可以碰到电脑, 估计都可以来写一点东西</p></blockquote><p>又到了周末了. 又是苦难的一周. 自从竞赛退役之后, 学校课课程也渐渐艰难了起来, 每天比竞赛要累不少(估计这也是为什么我竞赛崩掉了的原因吧). 感觉还是数学最难, 化学物理次之, 话说我还是一个理科的吗2333. 每天在睡觉和作业之间循环, 感觉非常不好. 我为什么要去学校???我也不知道啊. 完全没有理想, 只想着把作业写完, 然后在不知不觉中睡去. 或许在这一点上, 我和fsr很相似吧. </p><p>最开心的事情竟然是今天中午, 田dp请我和范大爷吃饭…退役的饭, 其实吃的还挺开心的. 下周说不定我还要请别人吃饭. </p><p>至于开发计划, 真的比较的难受了, 完全没有什么时间去做. 项目目标还是大概改造VS code, 但是工期可能要一直拖到寒假. </p><p>另外最近一直在看作文, 感觉自己甚至比较适合去写小说, 而不是正儿八经的议论文, 因为社会的黑暗是论述不玩的, 但是这个古怪的社会有要求我们去歌颂它的美好, 我只能苦笑. 虽然我不是很喜欢语文老师, 但是在批评这一个方面我还是十分赞同它的, 毕竟一味的歌颂和鼓励并不能使得这个社会发生任何的进步, 反而是批评才能够让它不断前行. 可悲的是, 我们只能在无伤大雅的地方随便议论, 终究是要看命题人和阅卷组的意思的. </p><p>其实还有一个工具比较想做一下的, 就是pdf的ocr, 现在的软件要么就是识别不出来, 要么就是要钱. 所以自己想要做一个集成工具, 专门用来识别并排版文字较多的pdf, 基本上中文+英文就够用了, (估计GitHub上面会有, 但是找不到啊2333), 但是应该会比较花时间吧… (因为我的图形界面相关的所有东西都做不好) 数据集是有的, 不过算力只有一个四代i低压版…</p><p>今天发现了好多好看的小说, 感觉下个星期每天都找到了生活的动力.</p><p>另外从这周开始, 要学习双拼. 据说学会了打字会变快. </p><p>(updated 11.25 22:49)</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>周记2018-11-17</title>
    <link href="/2018/11/17/%E5%91%A8%E8%AE%B02018-11-17/"/>
    <url>/2018/11/17/%E5%91%A8%E8%AE%B02018-11-17/</url>
    
    <content type="html"><![CDATA[<h2 id="周记-2018-11-17"><a href="#周记-2018-11-17" class="headerlink" title="周记 2018-11-17"></a>周记 2018-11-17</h2><blockquote><p>第一次写这种奇怪的东西, 不过已经说过会每周写东西, 那么我还是从小事做起吧.</p></blockquote><p>这周是期中考试周, 因为考试前根本没有复习, 所以考砸了是理所应当的, 就连老班都在说这种话, 我也是醉了. 虽然期中考试还是十分重要的, 不过现在也无所谓了, 反而是NOIP有没有国一比较能够激起我内心的波澜, 感觉CCF也快出成绩了. 因为是没有认证努力去做的事情, 就算做得很差也不会伤心, 不知道是不是一个好性格呢…</p><p>刚刚收到了NOIP退役souvenir: ikbc的C-87红轴黑色机械键盘, 内心十分高兴, 正在噼里啪啦地用新的机械键盘打出这些文字, 声音真的很好听, 虽然只是一个入门级别的机械… 人生第一块机械键盘, 希望能够用到大学毕业. (不过前提是我能够考上大学就是看了)</p><p>这个星期真正的上学日只有两天, 隔壁的fsr居然来上学了2333, 今天还照常和它在外面一起吃了一顿饭, 它说它要退役了, 因为貌似它Day2有两题写挂了, 这让我稍微有一点虚(话说我到现在为止都不敢去网上自测, 打算一直赖到CCF正是出成绩)</p><p>接下来的一个短期计划大概是写几个VSCode的extensions, 最终目的是为了获得一个比较舒服的Blog写作环境, 因为Typora貌似不支持插件扩展, 也没有什么比较方便的一键发布Hexo博客的工具, 于是打算自己写一个; 顺便感受一下Javascript的后端开发流程, 防止以后需要用到全栈技能. 长期的项目暂时还没有想好, 这星期增加了一个: 一个类似于Typora但是可扩展的Markdown编辑器(估计还是要用Electron这种东西来写). 但是鉴于VSCode的markdown写作体验还是可以的, 所以打算先试着去自己调教一番再作定论, 毕竟自己造轮子还是意见非常消耗精力的事情.</p><p>Yzzx貌似自己要搭建一个校内的OJ, 那天还把我喊过去做顾问什么的23333. 不过因为那个跟OI关系不是很大, 我还是去了, 顺便了解了yzzx校园网络系统的很多内幕, 也看到了高级的服务器, 算是很值得了.</p><p>明天开始我的周日造成就彻底泡汤了, 要补课… 说到补课, 还是想要骂一下sd语文老师, 凭什么我搞竞赛就歧视我, 居然认为不能进国家队就不应该高竞赛… tmd一辈子能见到一个国家队队员就已经很nb了好吗…</p><p>这周的周记大概就是这样.</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP正式退役宣言</title>
    <link href="/2018/11/11/NOIP%E6%AD%A3%E5%BC%8F%E9%80%80%E5%BD%B9%E5%AE%A3%E8%A8%80/"/>
    <url>/2018/11/11/NOIP%E6%AD%A3%E5%BC%8F%E9%80%80%E5%BD%B9%E5%AE%A3%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP-正式退役宣言"><a href="#NOIP-正式退役宣言" class="headerlink" title="NOIP 正式退役宣言"></a>NOIP 正式退役宣言</h1><h3 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h3><p>初二起4年OI, 占据了我编程岁月的相当一部分时光. 现在想起来, 其实有点后悔. 人们都说青春无悔, 然而青春实际上是充满着悔恨和嗟叹的. 从想要开发游戏, 到被带进竞赛的坑, 其实莫名奇妙, 我自己并不知道这一系列的选择代表了什么, 现在看了, 它们代表着失败和悔恨. 如果可以重新来过, 我选择享受每一天的阳光, 享受计算机科学和算法本身的优美, 没有智障的题面, 没有毒瘤的数据, 也没有时间限制, 排名先后, 分数和自招. </p><p>当然, 在无聊的竞赛之余, 我还学习了Python &amp; C#语言, 操作系统 &amp; 编译原理, 也学会了很多计算机相关的专业知识, 它们给我带来了无尽的乐趣, 让我认识到计算机科学世界的广博, 支撑着我度过竞赛岁月. 希望后来者们不要局限于竞赛, 除了竞赛, 要记得计算机还有很多更加有趣和有用的方面.</p><p>我很感谢那些从初一起就陪伴我的同学们, 无论是中途退出, 还是早早退役, 感谢你们陪我打RA3, 陪我在冬令营课上刷知乎, 陪我刷题, 向我讲解题目. 值得庆幸的是, 这一切并不依赖于竞赛的载体, 我们拥有竞赛之外的更多的东西: 游戏, 番剧, 食物, 搞笑……这或许是竞赛生活中为数不多了乐趣了. 也是竞赛留给我的唯一收获. 竞赛败坏了我的编程习惯, 带偏了我的思维, 浪费了我的青春, 这是人生之痛, 但苦难同时也是救赎.</p><p>这里特别的感谢FSR大人, 以及您所讲过的算法, 题目, 以及有趣的番剧和精彩的RA3对决. 希望以后仍然有机会一起讨论这些, 虽然不是很想提及竞赛. 祝您早日金牌.</p><p>至于老师, 感谢本校的总教练laoni, 感谢您的关心和培养, 虽然没有能够取得好成绩, 辜负期望了. 同时也感谢隔壁jdzx的chenzhong老师, 感谢初中时候指导我学习了中级算法, 并且耐心地解决我的问题. 是您使得我可以较为轻松地进阶提高组的比赛.</p><p>同时也隔空感谢一下前些日子在czyz集训时的同学们. 你们应该已经取得好成绩了吧. 另外还有隔壁的tjh巨佬, 同届的OI选手, 也算是相互勉励(%)了吧.</p><h3 id="当下"><a href="#当下" class="headerlink" title="当下"></a>当下</h3><p>此时也没有什么太多的感触了, 只是觉得比较的轻松, 可以睡一个好觉了. 虽然成绩还不清楚, 虽然明天还有期中考试, 但是不管怎样, 都已经结束了. 此时突然想要找个人聊一聊. 不过各位可能都在复习期中 / 到处浪吧…</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>正如昨天写到的, 我对于这样的竞赛已经感到十分失望了. 并不想要多说什么, 只是以后不会再有以后了. CCF(China Collecting-money Foundation)再也收不到我的血汗钱了. ACM-ICPC除非在弱校, 否则不会去参加了. 就连大学选择计算机专业的可能性也将为一成了. 希望这次做得能够决绝一点, 不要像高一差5分退役的时候怀抱幻想了. 青春没有重来, 人生充满后悔. 然而我们还是希望下次能够做得更好, 总是在绝望中, 骗自己去怀抱希望. </p><p>至于以后, 直到高三毕业, 都会用周末和假期的闲暇时间, 用心打磨一个项目, 或许是一个实用工具, 也或许是一个大型后端工程. 以前都太浮躁了, 没有能够把一个项目做好, 这次希望可以. 指导感兴趣的同学也是可以的, 只不过不会忽悠他们去学竞赛了. </p><p>以后我的博客里应该还会再出现一篇NOIP相关的文章, 不过那得等到出成绩之后了. </p><p>以后不能每天碰到电脑了, 可能会一周甚至两周一更吧. 主要内容主要会是学校生活, 项目开发经历以及技术原理解析和科技新闻一类的东西, 虽然我也不觉得会有人能够看到它们. </p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>就这么结束了呢. 怀着悔恨, 不甘, 无助的心情, 去面对永无黎明的黑暗. “信竟没有明天”, 用RA3苏联第6关的话来说, 大概是这样的感觉吧.</p><p>就这么结束吧. さようなら。</p><p>Prisrak · Smalin (Maoliang_Li)</p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP Day2考前看 君の名は</title>
    <link href="/2018/11/10/NOIP-Day2%E8%80%83%E5%89%8D%E7%9C%8B-%E5%90%9B%E3%81%AE%E5%90%8D%E3%81%AF/"/>
    <url>/2018/11/10/NOIP-Day2%E8%80%83%E5%89%8D%E7%9C%8B-%E5%90%9B%E3%81%AE%E5%90%8D%E3%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP-Day2考前看-君の名は"><a href="#NOIP-Day2考前看-君の名は" class="headerlink" title="NOIP Day2考前看 君の名は"></a>NOIP Day2考前看 君の名は</h1><blockquote><p>这还行</p><p>暴力 GG 滚粗 退役</p><p>然后去搬砖, 享受奋斗的社会主义人生</p></blockquote><p>之前看到了去年NOIP小学奥数那张毒瘤图, 突发奇想地打算在NOIP之前看一波&lt;你的名字&gt;, 于是乎今天下午, 在确认直接提前一天退役以后, 跟同学一起看了这个前年的番. 总体感觉是: woc, 这居然是一个大制作. 本来以为这还是类似于言叶之庭的作画, 没想到居然画面如此之精良. </p><p>看的时候是一边吐槽一边看的, 外加旁边还有两个放鬼畜加打游戏的, 所以观感不是很好, 但觉得如果在电影院看的话, 效果应该是很好的. 尤其是画的彗星的场面, 非常的漂亮. </p><p>情节本身不多说, 写得很好, 虽然一开始看得有一点懵逼, 毕竟是时空交错的剧情, 导致到后来就不知道是谁在说话了, 最后似乎是新海诚第一次发糖, 虽然不是特别甜… 比较可惜的是没有能够一个人享受剧情, 作为一个剧情导向的死宅, 我更加觉得有点浪费. 导致看完内心毫无波澜… 本来是非常凄美的爱情故事, 然而在看完一大波鬼畜和吐槽之后, 就完全无感了, 比较难受. </p><p>音乐无论是作曲还是配制, 都非常的到位, 之前在听歌的时候就能感觉到场面的宏大开阔, 当bgm响起的时候实在是激动万分. (洋次郎自然是没话说的呀) 后来本着尊重演职人员的态度, 顺手看了一眼CV, woc, 简直是太强了: 信长, 上百石萌音, 连香菜都来客串了……</p><p><del>可惜并没有什么可爱的妹子一起看的说…</del></p><p>至于看完了有什么想法的话, 可能没有. 估计是因为老了, 这样的番看多了, 也就不觉得有什么触动, 所以也越来越难被感动. 现在已经害怕看恋爱番了…一个是怕出现那样的情况, 还有一个是自己会觉得有一丝忧伤…当别人成为人生赢家的时候, 然而我还在写着毫无算法可言的代码, 看着鬼畜的时候, 偶尔也会觉得人生的灰暗吧. 当然还有旁边坐着一个老司机的忧伤. </p><p>话说日本的传统文化可以玩好多东西, 然而不知道为什么中国那些古董就一点也不文艺呢, 而是有一种木头的感觉.</p><p>希望明天RP++. (话说我今天考场上跟就跟看这个番的时候一样懵逼) 同时也祝和我分享此番的同志zjy RP++</p><p>一边听着过气的歌一边写下的无聊感言</p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP 考试记</title>
    <link href="/2018/11/10/NOIP-%E8%80%83%E8%AF%95%E8%AE%B0/"/>
    <url>/2018/11/10/NOIP-%E8%80%83%E8%AF%95%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP-考试记"><a href="#NOIP-考试记" class="headerlink" title="NOIP 考试记"></a>NOIP 考试记</h1><h3 id="3"><a href="#3" class="headerlink" title="-3"></a>-3</h3><p>今天早上又去学校打了一场模拟赛, 感觉比较郁闷. 最近心态似乎还是比较爆炸, 又爆零了. T1因为评测机辣鸡导致暴力居然T掉了, 本机可以过3个点. T2居然把MST的并查集写错了. T3因为比赛环境比较的毒瘤, 就没有写暴力就交了. 总共浪掉了110. 毒瘤至极, 我自己也不想说什么. </p><p>几个要注意一下的:</p><ol><li>写组合数不要暴力写, 记得打一下组合数的表, 顺便还少了一个log的逆元</li><li>看清题目,  不要太想当然. </li></ol><p>估计也还是因为不够重视吧. 今天的炸零. 也只能这么安慰一下自己了. 其实还是暴露出来更多的一些问题, 比如如何保证暴力能拿分, 确保拿到分. 去年的时候由于各种码力加成, 就不用担心什么暴力写不出来之类的问题. 今年水平稍微提高了, 暴力水平反而下降了, 各种手滑出大锅. 再有就是如何能够比较全面的考虑一个问题, 有几题以为想到正解, 然后直接炸零.</p><p>估计这几天本来想写的20道题就写不完了, 事到如今也只能相信自己了. 还剩两天, 估计就只能把NOIP几天暴力和模拟的原题写一写了. 然后再复习一下基本算法, 剩下时间就全部交给DP了, 毕竟连续几年都是一天一条DP, 把人气死, 尤其是我这种DP巨弱的选手. </p><h3 id="2"><a href="#2" class="headerlink" title="-2"></a>-2</h3><p>虽然今天早上打算认真听课, 但是还是忍不住上完了主课去看了一眼. 今天的题其实还是比较平和的. T1可以暴力卡常40pt. 然而正解是除法分块优化除法求和来暴力枚举. 有两个初三的jl立马就想到了, 我今天晚上才理解这个东西, 感觉真的是要入土了. T2的话, 15min出正解, 没写, 估计写了会挂掉. T3是个原题, 毒瘤树形dp, 不多说什么, 也不是不可做就是了. 反正感觉因该第一天不去才对的说. 2333</p><p>几个要注意一下的:</p><ol><li><p>看到带取模的数学题, 记得把<br>$$<br>a \bmod p<br>$$<br>变成<br>$$<br>a - \lfloor\frac{a}{p}\rfloor * p<br>$$</p></li><li><p>除法分块??</p></li></ol><p>今天算是稍微回复了一点码力, 不过还是非常的眼瞎, 各种打错. 明天打算再做两道NOIP原题, 其他的不管了, 看看骗分导论, 学一波模拟退火, 就去GG退役了. 今天也好颓废啊, 甚至想要NOIP前夜放君の名来着2333.(不知道有没有人跟我一起看) 今天莫名其妙心态不错</p><h3 id="1"><a href="#1" class="headerlink" title="-1"></a>-1</h3><p>哇, 明天就去南京了, 心情有点小复杂, 感觉这一年又白活了. 今天主要是打板子和学习玄学算法, 还有好多的板子没有去打, 话说如果不是NOIP就不知道自己其实还有好多东西没有去学. (所以又浪了一年) 更多的话, 就留到明天晚上再说吧.</p><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><p>Day0结束了. 最后一天的佛脚真的是抱的可以, 一天打了十几个板子, 外加十个DP板子, 简直就跟TMD什么都没有学过一样. 除了感觉自己白学一年, 就没有什么别的感触了. 现在其实一会感觉很慌, 一会又感觉稳的不行. 反正, 就这样吧, 希望这种东西, 本事无所谓有, 也无所谓无的. 现在最重要的似乎是睡一觉以及保证自己的肚子不要出锅. 赶紧睡了, 没有竞赛的黎明正在等待着我.</p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>今天居然出现了3条原题??? (我不想和你说什么, 因为我只是一只CCF) 导致已知上百号人当场AK, 无数人250+. 没有骗满分的我留下了蒟蒻的泪水. T1居然还是抄的以前的NOIP??? 然而我考场上并没有想到怎么写, 于是胡诌了一个递归分治, 大样例和自己的毒瘤数据都过了, 应该没有什么大问题. 有人说会被卡掉, 不过不管了. 期望得分: 70 - 100. T2不知道是个什么, 一眼看出背包可做, 然后就写了个80分做法. 满分做法没有调对. 期望得分: 80. T3是个二分答案+树形dp, 然而考场上不会写check函数, 就立马凉凉. 写了35分部分分, 另外的20部分分没有调出来. 所以今天的期望得分再185 - 215之间.不算太差, 但绝对算不上是满意, 已经凉透了. 我彻底对CCF和信息学奥赛失望了, 连最基本的出题态度都已经丧失的竞赛还有什么希望吗? 虽然大佬们可能AK得非常开心, 但是对于中等水平的选手绝对不是什么开心的事情, 辛辛苦苦来参加复赛, 做到的却是陈旧的题目, 更可悲的是我竟然不知道T2T3是原题. 不想复习了. 已经提前退役了, 我已经把Luogu上的签名改成了退役选手, 也公开了所有代码. 再见了, NOIP. 虽然明天还是会去强撑着把它考完. </p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP退役整理 3 数据结构</title>
    <link href="/2018/11/08/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2018/11/08/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP退役整理-3-数据结构"><a href="#NOIP退役整理-3-数据结构" class="headerlink" title="NOIP退役整理 3 数据结构"></a>NOIP退役整理 3 数据结构</h1><blockquote><p>看完保证你, 退役!</p><p>感觉NOIP的数据结构并不是很多的说…233</p></blockquote><h2 id="0-并查集"><a href="#0-并查集" class="headerlink" title="0. 并查集"></a>0. 并查集</h2><h2 id="1-树状数组"><a href="#1-树状数组" class="headerlink" title="1. 树状数组"></a>1. 树状数组</h2><p>随便贴一个区间加的</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> re register int</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowbit(x) (x &amp; -x)</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> lld;<span class="hljs-function"><span class="hljs-keyword">inline</span> lld <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    lld x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;lld a[maxn], n, m;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(lld x, lld k)</span> </span>&#123;    <span class="hljs-keyword">for</span> (; x &lt;= n; x += lowbit(x)) a[x] += k;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> lld <span class="hljs-title">get</span><span class="hljs-params">(lld x)</span> </span>&#123;    lld r = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; x; x -= lowbit(x)) r += a[x];    <span class="hljs-keyword">return</span> r;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n = read(); m = read();    lld now, last = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (re i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;        now = read(); Add(i, now - last);        last = now;    &#125;    <span class="hljs-keyword">for</span> (re i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;        lld op = read(), x = read();        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;            lld y = read(), k = read();            Add(x, k); Add(y + <span class="hljs-number">1</span>, -k);        &#125;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, get(x));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="2-线段树"><a href="#2-线段树" class="headerlink" title="2. 线段树"></a>2. 线段树</h2><p>随便写写就好</p><h2 id="3-ST表"><a href="#3-ST表" class="headerlink" title="3.ST表"></a>3.ST表</h2><p>主要用来解决RMQ(区间最值问题)的一种算法, 主要思想竟然是<strong>动态规划</strong>(区间动规)和倍增.支持<code>O(nlog(n))</code>预处理, <code>O(1)</code>查询, 而且常数非常小, <del>跑得跟记者一样快</del>但是不支持修改,极大地限制了它的运用范围.</p><p>方程:<br>$$<br>f[i,j] = max(f[i,j-1], f[i + 2^{j-1}, j-1]) \<br>其中f[i,j]表示a[i]到a[2^j-1]区间内的最大值<br>$$<br>求解的时候<br>$$<br>k = log_2(r - l + 1)\<br>ans = max(f[l, k], f[r - 2^k + 1, k])<br>$$<br>板子</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化部分</span><span class="hljs-keyword">for</span> (<span class="hljs-built_in">log</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>, <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) <span class="hljs-built_in">log</span>[i] = <span class="hljs-built_in">log</span>[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">//递推log,在询问较多时可以卡卡常</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) st[i][<span class="hljs-number">0</span>] = dat[i]; <span class="hljs-comment">//dp初始化</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">22</span>; ++ j) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; ++ i) &#123;st[i][j] = <span class="hljs-built_in">std</span>::max(st[i][j<span class="hljs-number">-1</span>], st[i+(<span class="hljs-number">1</span>&lt;&lt;j<span class="hljs-number">-1</span>)][j<span class="hljs-number">-1</span>]);&#125;&#125;<span class="hljs-comment">//查询</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; l, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp; r)</span> </span>&#123;<span class="hljs-keyword">int</span> k = <span class="hljs-built_in">log</span>[r - l + <span class="hljs-number">1</span>];<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::max(st[i][k], st[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);&#125;</code></pre></div><h2 id="4-平衡树大法"><a href="#4-平衡树大法" class="headerlink" title="4. 平衡树大法!!!"></a>4. 平衡树大法!!!</h2><p>这个不会用到的. 只是个人兴趣而已</p><h2 id="5-Trie"><a href="#5-Trie" class="headerlink" title="5. Trie"></a>5. Trie</h2><h2 id="6-平板电视-ext-pb-ds-hpp"><a href="#6-平板电视-ext-pb-ds-hpp" class="headerlink" title="6. 平板电视(ext/pb_ds/*.hpp)"></a>6. 平板电视(ext/pb_ds/*.hpp)</h2><h2 id="7-差分-前缀和"><a href="#7-差分-前缀和" class="headerlink" title="7. 差分 前缀和"></a>7. 差分 前缀和</h2><p><a href="https://blog.csdn.net/Taunt_/article/details/78478526" target="_blank" rel="noopener">这个玩意儿写得不错, 抄下来了.</a></p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="1-一维前缀和"><a href="#1-一维前缀和" class="headerlink" title="1.一维前缀和"></a>1.一维前缀和</h4><p>对于数组A[], 前缀和SUM[i]表示的就是A[1]+A[2]+…+A[i].</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="hljs-number">-1</span>] + a[i];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;    <span class="hljs-keyword">return</span> sum[r] - sum[l<span class="hljs-number">-1</span>];&#125;</code></pre></div><h4 id="2-二维前缀和"><a href="#2-二维前缀和" class="headerlink" title="2.二维前缀和"></a>2.二维前缀和</h4><p>对于二维数组, 前缀和SUM[i][k]表示的是所有A[i’][k’](1&lt; = i’&lt;=i,i &lt;= k’&lt;=k)的和.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;            sum[i][j] = sum[i][j<span class="hljs-number">-1</span>] + sum[i<span class="hljs-number">-1</span>][j] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + a[i][j];        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span> </span>&#123;    <span class="hljs-keyword">return</span> sum[x1][y1] - sum[x1][y2 - <span class="hljs-number">1</span>] - sum[x2 - <span class="hljs-number">1</span>][y1] + sum[x2 - <span class="hljs-number">1</span>][y2 - <span class="hljs-number">1</span>];&#125;</code></pre></div><h4 id="3-k时的优化"><a href="#3-k时的优化" class="headerlink" title="3.%k时的优化"></a>3.%k时的优化</h4><p>（p - q）% k= 0 ==&gt; p % k = q % k<br>统计q % k 和 p % k 相等的数<br>详细见T1</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h4 id="1-一维差分"><a href="#1-一维差分" class="headerlink" title="1.一维差分"></a>1.一维差分</h4><p>我们对[L,R]区间进行加num操作，在C[L]处加上num，在C[R+1]处减去num </p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> num)</span> </span>&#123;    dis[l] += num, dis[r + <span class="hljs-number">1</span>] -= num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        val[i] = val[i<span class="hljs-number">-1</span>] + dis[i];    &#125;&#125;</code></pre></div><h4 id="2-二维差分"><a href="#2-二维差分" class="headerlink" title="2.二维差分"></a>2.二维差分</h4><p>其实也挺简单，和二维前缀和一样</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2, <span class="hljs-keyword">int</span> num)</span> </span>&#123;    sumx1 += num;    sumx1 -= num;    sumx2 + <span class="hljs-number">1</span> -= num;    sumx2 + <span class="hljs-number">1</span> += num;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            sumi += sumi + sumi<span class="hljs-number">-1</span> - sumi<span class="hljs-number">-1</span>;        &#125;    &#125;&#125;</code></pre></div><h4 id="3-树上差分"><a href="#3-树上差分" class="headerlink" title="3.树上差分"></a>3.树上差分</h4><h5 id="1-点差分"><a href="#1-点差分" class="headerlink" title="(1)点差分"></a>(1)点差分</h5><p>对 u 到 v 的路径上的点 +num<br>用来求 - 已知路径求树上所有节点被路径覆盖次数</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> num)</span> </span>&#123;    dis[u] += num;    dis[v] += num;    dis[lca(u,v)] -= num;    dis[f[lca(u,v)]] -= num;&#125;</code></pre></div><h5 id="2-边差分"><a href="#2-边差分" class="headerlink" title="(2)边差分"></a>(2)边差分</h5><p>对 u 到 v 的路径上的边 +num<br>用来求 - 已知路径求被所有路径覆盖的边<br>dis[i] 表示以i节点为儿子的边</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> num)</span> </span>&#123;    dis[u] += num;    dis[v] += num;    dis[lca(u,v)] -= <span class="hljs-number">2</span> *num;&#125;</code></pre></div><p>最后dfs遍历一遍</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i; i = e[i].next) &#123;        <span class="hljs-keyword">int</span> v = e[i].v;        <span class="hljs-keyword">if</span>(v != fx) &#123;    <span class="hljs-comment">//fx 为倍增数组 </span>            dfs(v);            dis[x] += dis[v];        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP退役整理 2 图论</title>
    <link href="/2018/11/08/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/"/>
    <url>/2018/11/08/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP退役整理-2-图论"><a href="#NOIP退役整理-2-图论" class="headerlink" title="NOIP退役整理 2 图论"></a>NOIP退役整理 2 图论</h1><blockquote><p>看完保证你, 退役!</p><p>继续没有任何证明的笔记</p></blockquote><p>[TOC]</p><h2 id="0-基础的算法"><a href="#0-基础的算法" class="headerlink" title="0. 基础的算法"></a>0. 基础的算法</h2><h3 id="1-链式前向星"><a href="#1-链式前向星" class="headerlink" title="-1. 链式前向星"></a>-1. 链式前向星</h3><p>最最最最重要的存图方法.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span> <span class="hljs-keyword">int</span> next, to, w; &#125; edge[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;    <span class="hljs-keyword">int</span> v = edge[cnt].to;    <span class="hljs-comment">//...</span>&#125;</code></pre></div><h3 id="0-百分数-BFS-和电风扇-DFS"><a href="#0-百分数-BFS-和电风扇-DFS" class="headerlink" title="0. 百分数(BFS)和电风扇(DFS)"></a>0. 百分数(BFS)和电风扇(DFS)</h3><p>这个我不想说什么. 不过什么DFS的手工栈估计也是不会考,我虽然会写但是只用过一次还炸了</p><h3 id="1-拓扑排序"><a href="#1-拓扑排序" class="headerlink" title="1.拓扑排序"></a>1.拓扑排序</h3><p>拓扑序是一个比较重要的顺序,可以用来做各种事情,比如在图上递推, 或者直接解题什么的.</p><p>主要就是在DAG上分析依赖关系. 还可以判环.主要思想就是:每次找入度为0的节点,找到后删除该节点和该节点的出度边.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// deg[]是入度. vis[]呵呵. 以下默认使用链星. (生成树除外)</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Topo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;    vis[u] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;        <span class="hljs-keyword">int</span> v = edge[i].to;        deg[v] --;        <span class="hljs-keyword">if</span> (!deg[v]) Topo(v);    &#125;&#125;<span class="hljs-comment">//main</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;    <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; !deg[i]) Topo(i);&#125;</code></pre></div><p>可以在这个主要模板上做各种操作. 判环的话, 记一个color标记(比如:记正在访问为-1, 已经访问为1, 没有访问为0), 如果祖先节点没有返回但是子孙节点又访问到了它, 于是就有环了.</p><p>其实还有BFS的写法.估计不考, 就不管了.<a href="https://blog.csdn.net/baodream/article/details/80368764" target="_blank" rel="noopener">随便找了一个板子</a></p><h2 id="1-最短路"><a href="#1-最短路" class="headerlink" title="1.最短路"></a>1.最短路</h2><h3 id="1-Dijkstra"><a href="#1-Dijkstra" class="headerlink" title="1. Dijkstra"></a>1. Dijkstra</h3><p>先膜一波: %%%Dijkstra%%%</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::priority_queue;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x7fffffff</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span>((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span>((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">T_Edge</span>&#123;</span> <span class="hljs-keyword">int</span> to, next, w; &#125; edge[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">T_Node</span> &#123;</span>    <span class="hljs-keyword">int</span> i, d;    T_Node(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b): i(a), d(b) &#123; &#125;    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (T_Node a, T_Node b) &#123;        <span class="hljs-keyword">return</span> a.d &gt; b.d;    &#125;&#125;;priority_queue&lt;T_Node&gt; pq;<span class="hljs-keyword">int</span> n, m, s;<span class="hljs-keyword">int</span> dis[maxn + <span class="hljs-number">10</span>], vis[maxn + <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n = read(); m = read(); s = read();    <span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> ui, vi, wi;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i)&#123;        ui = read(); vi = read(); wi = read();        AddEdge(ui, vi, wi);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;        dis[i] = inf;    &#125;    <span class="hljs-function">T_Node <span class="hljs-title">now</span><span class="hljs-params">(s, <span class="hljs-number">0</span>)</span></span>;    now.i = s; now.d = dis[s]  = <span class="hljs-number">0</span>;    pq.push(now);    <span class="hljs-keyword">while</span> (!pq.empty()) &#123;        now = pq.top(); pq.pop();        <span class="hljs-keyword">int</span> u = now.i;        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;        vis[u] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;            <span class="hljs-keyword">int</span> v = edge[i].to;            <span class="hljs-keyword">if</span> (!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[i].w) &#123;                dis[v] = dis[u] + edge[i].w;                pq.push(T_Node(v, dis[v]));            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, dis[i]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>这个的复杂度是严格<code>O(nlog(n))</code>的.(其实跑n遍dj比一遍floyd要快(不考虑常数) // 笑)</p><h3 id="2-SPFA"><a href="#2-SPFA" class="headerlink" title="2. SPFA"></a>2. SPFA</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*...*/</span>&#125;<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span> <span class="hljs-keyword">int</span> next, to, w; &#125; edge[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<span class="hljs-keyword">int</span> vis[maxn], dis[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-keyword">int</span> q[maxn];     <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(q));    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span>;    q[l] = s, dis[s] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;        <span class="hljs-keyword">int</span> u = q[l ++];        vis[u] = [<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;            <span class="hljs-keyword">int</span> &amp;v = edge[i].to;            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + edge[i].w) &#123;                dis[v] = dis[u] + edge[i].w;                <span class="hljs-keyword">if</span> (!vis[v]) vis[v] = <span class="hljs-number">1</span>, q[++r] = v;                            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//main</span></code></pre></div><p>这个写起来比较方便, 虽然有可能会被卡掉.</p><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3. Floyd"></a>3. Floyd</h3><p>这个的主要思想是DP. 所以也是可以在上面加个一位瞎搞的. 复杂度很高, <code>O(n^3)</code></p><p>状态转移方程<br>$$<br>D[k,i,j] 表示经过几个编号不超过k的节点,从i到j的最短路.我们把这个k作为一个中转点一样的东西 \<br>显然, D[k, i, j] = min(D[k-1, i, j], D[k-1, i, k] + D[k-1, k, j]) \<br>再显然,k这一维可以被推掉 \<br>就变成了: D[i, j] = min(D[i, j], D[i,k] + D[k,j])<br>$$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//init</span><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(d));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) d[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//自己到自己</span><span class="hljs-comment">// read in...</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++ k) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;            d[i][j] = <span class="hljs-built_in">std</span>::min(d[i][j], d[i][k] + d[k][j]);        &#125;    &#125;&#125;</code></pre></div><p>这个玩意儿似乎可以用来求最小环, 最后再写吧</p><p>然而更加牛逼的是, 这个玩意儿的求解过程比较类似于矩阵乘法, 有些看似不可做的题目可以用类似于这样的矩阵快速幂跑.</p><h3 id="4-相关题目"><a href="#4-相关题目" class="headerlink" title="4. 相关题目"></a>4. 相关题目</h3><ol><li>Luogu P1144 最短路计数. 在跑Dj/ Spfa的时候随便统计一下</li><li>Luogu P2384 把加法换成了乘法, 保证你退役2333. 其实打个log就好了</li><li>Luogu P1613 在Floyd上加一维乱搞</li></ol><h3 id="5-我是不是应该皮一把k短路"><a href="#5-我是不是应该皮一把k短路" class="headerlink" title="5. 我是不是应该皮一把k短路"></a>5. 我是不是应该皮一把k短路</h3><p>A*可做. 复杂度上界<code>O(nklog(nk)</code></p><p>我不会写红红火火恍恍惚惚</p><h2 id="2-生成树"><a href="#2-生成树" class="headerlink" title="2.生成树"></a>2.生成树</h2><h3 id="1-Kruskal"><a href="#1-Kruskal" class="headerlink" title="1. Kruskal"></a>1. Kruskal</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;<span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> fa[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> fa[x] == x ? fa[x] : fa[x] = findfa(fa[x]);&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> from, to, w;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (Edge a, Edge b) &#123;<span class="hljs-keyword">return</span> a.w &lt; b.w;&#125;&#125; edge[maxn];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> n = read(); <span class="hljs-keyword">int</span> m = read();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) edge[i].from = read(), edge[i].to = read(), edge[i].w = read();<span class="hljs-built_in">std</span>::sort(edge + <span class="hljs-number">1</span>, edge + m + <span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) fa[i] = i;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<span class="hljs-keyword">int</span> fau;<span class="hljs-keyword">if</span> ((fau = findfa(edge[i].from)) != findfa(edge[i].to))&#123;fa[edge[i].to] = fau;ans += edge[i].w;cnt ++;&#125;&#125;<span class="hljs-keyword">if</span> (cnt &lt; n<span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fuck"</span>); <span class="hljs-comment">//如果边数不对就说明生成失败了</span><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans);&#125;</code></pre></div><h3 id="2-Prim-不讲"><a href="#2-Prim-不讲" class="headerlink" title="2. Prim 不讲"></a>2. Prim 不讲</h3><p>这个基本用不到. 只有在稠密图上才会优于KS.</p><h3 id="3-变种生成树"><a href="#3-变种生成树" class="headerlink" title="3. 变种生成树"></a>3. 变种生成树</h3><ul><li><p>最大生成树就把排序的顺序改一下就好了.</p></li><li><p>次大/小生成树有点难写.</p><p>先求最小生成树T,枚举添加不在T中的边,则添加后一定会形成环,找到环上边值第二大的边,把它删掉,计算当前生成树的权值,取所有枚举修改的生成树的最小值,即为次小生成树.这种方法的实现更为简单,首先求最小生成树T,然后从每个结点u,遍历最小生成树T,用一个二维的数组max[u][v]记录结点u到结点v的路径上边的最大值,然后枚举不在T中的边(u,v),计算T-max[u][v]+w(u,v)的最小值,即为次小生成树的权值 ,这种方法的时间复杂度为<code>O(n^2+e)</code>.</p><p>因为没什么题,就不多说了.</p></li></ul><p>考生成树的时候,一般是Day2T1的难度.基本上不会有什么特别的地方,一旦看出来能敲对就可以了.题目都比较弱智,不贴了</p><h2 id="3-Tarjan"><a href="#3-Tarjan" class="headerlink" title="3.Tarjan"></a>3.Tarjan</h2><p>先膜一波为敬: %%%Tarjan%%%</p><h3 id="1-强连通分量"><a href="#1-强连通分量" class="headerlink" title="1. 强连通分量"></a>1. 强连通分量</h3><p>概念就不说了. 主要用来缩点,缩完以后就把一个有环图变成DAG,就可以随便瞎搞了.</p><p>求这个玩意儿,其实有另外一个奇葩的跑两边的算法.(在接受FanDalao的指导之前,我一直写的是那个k打头的算法).</p><p>先上板子</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> low[maxn], dfn[maxn], stk[maxn], instk[maxn], tim, top, scc[maxn], num;<span class="hljs-comment">// scc[u]代表u属于的强连通分量的编号</span><span class="hljs-comment">// low[u]代表u能到达的最小的dfn,似乎也就是最老的祖先</span><span class="hljs-comment">// dfn代表的似乎是dfs序列</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;dfn[u] = low[u] = ++tim;instk[stk[++top] = u] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;<span class="hljs-keyword">int</span> &amp;v = edge[i].to;<span class="hljs-keyword">if</span> (!dfn[v]) &#123;Tarjan(v);low[u] = <span class="hljs-built_in">std</span>::min(low[u], low[v]);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[v]) &#123;low[u] = <span class="hljs-built_in">std</span>::min(low[u], dfn[v]);&#125;&#125;<span class="hljs-keyword">if</span> (low[u] == dfn[u]) &#123; <span class="hljs-comment">//完了,又回到自己了</span>num ++;<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">int</span> v = stk[top --]; instk[v] = <span class="hljs-number">0</span>,scc[v] = num;<span class="hljs-keyword">if</span> (v == u) <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></div><p>还是有一些有趣的题目的.不过感觉都比较趋同,缩点-&gt;搞一搞连通性,最短路,出度入度-&gt;没了</p><h3 id="2-割点和桥"><a href="#2-割点和桥" class="headerlink" title="2. 割点和桥"></a>2. 割点和桥</h3><p>概念不说.</p><p>割点</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> sz = <span class="hljs-number">0</span>;    dfn[u] = low[u] = ++cnt;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u];i;i = edge[i].next)    &#123;        <span class="hljs-keyword">int</span> v = edge[i].to;        <span class="hljs-keyword">if</span> (dfn[v]) low[u] = min(low[u],dfn[v]);        <span class="hljs-keyword">else</span>        &#123;            sz ++;            dfs(v,root);            <span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u]) iscut[u] = <span class="hljs-literal">true</span>;            low[u] = min(low[u],low[v]);        &#125;    &#125;    <span class="hljs-keyword">if</span> (u == root &amp;&amp; sz &lt; <span class="hljs-number">2</span>)        iscut[u] = <span class="hljs-literal">false</span>;&#125;<span class="hljs-comment">// may be more beautiful</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;<span class="hljs-keyword">int</span> sz = <span class="hljs-number">0</span>; dfn[u] = low[u] = ++tim;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next ) &#123;<span class="hljs-keyword">int</span> &amp;v = edge[i].to;<span class="hljs-keyword">if</span> (!dfn[v])  &#123;sz ++;point(v, rt);<span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u]) iscut[u] = <span class="hljs-number">1</span>;low[u] = <span class="hljs-built_in">std</span>::min(low[u], low[v]);&#125;<span class="hljs-keyword">else</span> &#123;low[u] = <span class="hljs-built_in">std</span>::min(low[u], dfn[v]);&#125;&#125;<span class="hljs-keyword">if</span> (u == rt &amp;&amp; sz &lt; <span class="hljs-number">2</span>) iscut[u] = <span class="hljs-number">0</span>;&#125;</code></pre></div><p>桥 //正确性不明</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bridge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;low[u] = dfn[u] = ++tim;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next)&#123;<span class="hljs-keyword">int</span> &amp;v = edge[i].to;<span class="hljs-keyword">if</span> (!dfn[v]) &#123;bridge(v, u);low[u] = <span class="hljs-built_in">std</span>::min(low[u], low[v]) ;<span class="hljs-keyword">if</span> (low[v] &gt; dfn[u]) &#123; <span class="hljs-comment">// "&gt;"</span>isbridge[u][v] = <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fa != v) &#123;low[u] = <span class="hljs-built_in">std</span>::min(low[u], dfn[v]);&#125;&#125;&#125;</code></pre></div><p>似乎没有什么题目。</p><h3 id="3-双联通分量"><a href="#3-双联通分量" class="headerlink" title="3. 双联通分量"></a>3. 双联通分量</h3><p>“点双连通图的定义等价于任意两条边都同在一个简单环中,而边双连通图的定义等价于任意一条边至少在一个简单环中.”这个是从网上抄的.”不同双连通分量最多只有一个公共点,即某一个割顶,任意一个割顶都是至少两个点双连通的公共点.不同边双连通分量没有公共点,而桥不在任何一个边双连通分量中,点双连通分量一定是一个边双连通分量.”</p><p>这个东西的求解跟上面的割点和桥差不多,虽然我没写过.(有一条HNOI2012)</p><p>过天把代码补上</p><h2 id="4-LCA"><a href="#4-LCA" class="headerlink" title="4. LCA"></a>4. LCA</h2><p>“对呀对呀..求LCA有六种方法,你知道吗?” –fan乙己 %%%%%%</p><h3 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1. 暴力"></a>1. 暴力</h3><p>我表示不会写. 这个应该跟倍增差不多思想.就是对于两个点,轮流向上面跳,直到碰起来这个样子.</p><h3 id="2-ST表-RMQ"><a href="#2-ST表-RMQ" class="headerlink" title="2. ST表/RMQ"></a>2. ST表/RMQ</h3><p>这个跟tarjan一样不是很常用.就不打了,省的浪费时间和记忆力</p><h3 id="3-倍增"><a href="#3-倍增" class="headerlink" title="3. 倍增"></a>3. 倍增</h3><p>最最最常用而且很好写的lca.大家都在写它.(虽然很容易被卡掉,但是NOIP级别的还没有毒瘤到去卡这个)</p><p>主要思想就是先预处理出每个点的深度,然后对于两个点的深度差倍增的向上跳,因为是倍增所以比一般的跳快一点.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;<span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span> <span class="hljs-keyword">int</span> next, to; &#125; edge[maxn&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123; edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; &#125;<span class="hljs-keyword">int</span> deep[maxn], l[maxn][<span class="hljs-number">30</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123; <span class="hljs-comment">//预处理</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; ++ i) &#123;l[u][i] = l[l[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;<span class="hljs-keyword">int</span> v = edge[i].to;<span class="hljs-keyword">if</span> (v == l[u][<span class="hljs-number">0</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 什么,儿子变成父亲了233</span>l[v][<span class="hljs-number">0</span>] = u; <span class="hljs-comment">// v的父亲是u,就是从v向上跳2^0,即1步到达u</span>deep[v] = deep[u] + <span class="hljs-number">1</span>;dfs(v);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">if</span> (deep[u] &lt; deep[v]) u ^= v ^= u ^= v;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<span class="hljs-keyword">if</span> (deep[l[u][i]] &gt;= deep[v]) &#123;u = l[u][i];&#125;&#125;<span class="hljs-comment">//把u和v跳到同一高度</span><span class="hljs-keyword">if</span>  (u == v) <span class="hljs-keyword">return</span> u; <span class="hljs-comment">//到了一个点上,说明这两个点具有祖先关系</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; -- i)<span class="hljs-keyword">if</span> (l[u][i] != l[v][i])<span class="hljs-comment">//一起跳</span>u = l[u][i], v = l[v][i];<span class="hljs-keyword">return</span> l[u][<span class="hljs-number">0</span>];&#125;<span class="hljs-keyword">int</span> n,m,s;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        n = read(); m = read(); s = read();        <span class="hljs-keyword">int</span> tmp1,tmp2;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n<span class="hljs-number">-1</span>;i ++)    &#123;        tmp1 = read(); tmp2 = read();        AddEdge(tmp1,tmp2); AddEdge(tmp2,tmp1);    &#125;    deep[s] = <span class="hljs-number">1</span>; dfs(s);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; i++)    &#123;        tmp1 = read(); tmp2 = read();        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,getlca(tmp1,tmp2));    &#125;&#125;</code></pre></div><h3 id="4-树链剖分"><a href="#4-树链剖分" class="headerlink" title="4. 树链剖分"></a>4. 树链剖分</h3><p>树剖是前置技能.不说.</p><p>主要思想是把u和v所在链的顶端跳到一起</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span> <span class="hljs-keyword">int</span> next, to; &#125; edge[maxn&lt;&lt;<span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123; edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; &#125;<span class="hljs-keyword">int</span> sz[maxn], son[maxn], top[maxn], deep[maxn], fa[maxn];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;sz[u] = <span class="hljs-number">1</span>, son[u] = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;<span class="hljs-keyword">int</span> &amp;v = edge[i].to;<span class="hljs-keyword">if</span> (v == fa[u]) <span class="hljs-keyword">continue</span>;fa[v] = u, deep[v] = deep[u] + <span class="hljs-number">1</span>;dfs1(v);<span class="hljs-keyword">if</span> (!son[u] || sz[v] &gt; sz[son[u]]) son[u] = v;sz[u] += sz[v];&#125;&#125; <span class="hljs-comment">//处理儿子</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> tp)</span> </span>&#123;top[u] = tp;<span class="hljs-keyword">if</span> (son[u]) dfs2(son[u], tp);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;<span class="hljs-keyword">int</span> &amp;v = edge[i].to;<span class="hljs-keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v);&#125;&#125;<span class="hljs-comment">//处理链顶</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<span class="hljs-keyword">if</span> (deep[top[u]] &lt; deep[top[v]]) u ^= v ^= u ^= v;u = fa[top[u]];&#125;<span class="hljs-keyword">if</span> (deep[u] &gt; deep[v]) u ^= v ^= u ^= v;<span class="hljs-keyword">return</span> u;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> n = read(), m = read(), s = read();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<span class="hljs-keyword">int</span> u = read(), v = read();AddEdge(u, v); AddEdge(v, u);&#125;dfs1(s); dfs2(s, s);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<span class="hljs-keyword">int</span> ui = read(), vi = read();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getlca(ui, vi));&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="5-离线Tarjan"><a href="#5-离线Tarjan" class="headerlink" title="5. 离线Tarjan"></a>5. 离线Tarjan</h3><p>不是很常用.贴一个久远的板子.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">3e6</span>+<span class="hljs-number">50</span>;<span class="hljs-keyword">int</span> n,m,s,cnt1 = <span class="hljs-number">1</span>, cnt2 = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> head1[maxn], head2[maxn], ans[maxn], fa[maxn];<span class="hljs-keyword">bool</span> vis[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t_edge</span>&#123;</span>    <span class="hljs-keyword">int</span> next, to;&#125;edge[maxn];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t_query</span>&#123;</span>    <span class="hljs-keyword">int</span> next, to, num, vis;&#125;query[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddQuery</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("testdata.in","r",stdin);</span>    n = read(), m = read(), s = read();    <span class="hljs-comment">//scanf("%d%d%d",&amp;n,&amp;m,&amp;s);</span>    <span class="hljs-keyword">int</span> ui,vi;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n<span class="hljs-number">-1</span>; ++i)    &#123;        <span class="hljs-keyword">int</span> ui = read(),vi = read();        <span class="hljs-comment">//scanf("%d%d",&amp;ui,&amp;vi);</span>        AddEdge(ui,vi); AddEdge(vi,ui);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)    &#123;    <span class="hljs-keyword">int</span> ui = read(),vi = read();        <span class="hljs-comment">//scanf("%d%d",&amp;ui,&amp;vi);</span>        AddQuery(ui,vi,i);AddQuery(vi,ui,i);    &#125;    <span class="hljs-comment">//fclose(stdin);</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)    fa[i] = i;    dfs(s);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m; ++i)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    edge[cnt1].next = head1[u];    edge[cnt1].to = v;    head1[u] = cnt1 ++;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddQuery</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> num)</span></span><span class="hljs-function"></span>&#123;    query[cnt2].next = head2[u];    query[cnt2].to = v;    query[cnt2].num = num;    head2[u] = cnt2 ++;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">3</span>) + (x &lt;&lt; <span class="hljs-number">1</span>) + c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">return</span> f ? x : -x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">father</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (fa[x] != x) fa[x] = father(fa[x]);    <span class="hljs-keyword">return</span> fa[x];&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    fa[father(x)] = father(y);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    vis[u] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head1[u]; i ; i = edge[i].next)    &#123;        <span class="hljs-keyword">int</span> &amp;v = edge[i].to;        <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;        dfs(v);        combine(v,u);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head2[u]; i ; i = query[i].next)    &#123;        <span class="hljs-keyword">int</span> &amp;v = query[i].to;        <span class="hljs-keyword">if</span> (vis[v] &amp;&amp; !query[i].vis)        &#123;            ans[query[i].num] = father(v);            query[i].vis = <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="6-笛卡尔树"><a href="#6-笛卡尔树" class="headerlink" title="6. 笛卡尔树"></a>6. 笛卡尔树</h3><p>这个不会写, 巨难</p><h2 id="5-二分图"><a href="#5-二分图" class="headerlink" title="5. 二分图"></a>5. 二分图</h2><h3 id="1-二分染色"><a href="#1-二分染色" class="headerlink" title="1. 二分染色"></a>1. 二分染色</h3><p>这个算法似乎还是考过的,主要用来判断一个图是否是二分图,还可以顺带做一些操作.看到有某些互斥操作或者两边分的比较明显的就可以考虑二分图相关的东西.染色很简单,暴力遍历一边就结束了.</p><p>题目:</p><ol><li>Luogu P1155. 其实也可以不用二分图.也比较不好想到是二分图</li><li>Luogu P1330. 这个比较明显. </li></ol><p>蒟蒻表示自己基本只刷过luogu…没有什么别的题库.tcl</p><h3 id="2-二分图匹配"><a href="#2-二分图匹配" class="headerlink" title="2. 二分图匹配"></a>2. 二分图匹配</h3><p>这个里面有许多奇奇怪怪的概念:  </p><ol><li><p>定义：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>匹配点：匹配边上的两点</p></li><li><p>极大匹配(Maximal Matching)：是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。</p></li><li><p>最大匹配(maximum matching)：是所有极大匹配当中边数最大的一个匹配,设为M。选择这样的边数最大的子集称为图的最大匹配问题。</p></li><li><p>完美匹配（完备匹配）：一个图中所有的顶点都是匹配点的匹配，即2|M| = |V|。完美匹配一定是最大匹配，但并非每个图都存在完美匹配。</p></li><li><p>最优匹配：最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。（KM（Kuhn and Munkres）算法，是对匈牙利算法的一种贪心扩展。）</p></li><li><p>最小覆盖 二分图的最小覆盖分为最小顶点覆盖和最小路径覆盖：<br>①最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联<br>注：二分图的最小顶点覆盖数=二分图的最大匹配数</p><p>②最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。<br>注：二分图的最小路径覆盖数=|V|-二分图的最大匹配数</p></li><li><p>最大独立集:最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集=|V|-二分图的最大匹配数。最大独立集S 与 最小覆盖集T 互补</p></li><li><p><a href="https://blog.csdn.net/ling_wang/article/details/79830980" target="_blank" rel="noopener">这个当然是抄的</a></p></li></ol><h4 id="1-二分图最大匹配"><a href="#1-二分图最大匹配" class="headerlink" title="1. 二分图最大匹配"></a>1. 二分图最大匹配</h4><p>就是找到最多的匹配个数. 经典模型为稳定婚姻问题.</p><p>二分图匹配本质上是一个网络流问题,只要再左边一列的左边加一个源点,右边一列右边再加一个汇点,跑最大流就好了.但是对于二分图来说其实不必要这个样子,可以简单一点.</p><p>接下来是板子. 其实代码并不是很难, 难在发现这是一个二分图,再把模型建起来.这一点在网络流里面也是一个巨大的问题.233</p><p>算法为匈牙利算法.主要思想就是先随便匹配,遇到有重合的就考虑拆掉原来的,再给原来的重新配一个.知道再也配不到为止.(一个无比凶残的算法)</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// Luogu P3386</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;<span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span> <span class="hljs-keyword">int</span> to, next; &#125; edge[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt ++;&#125;<span class="hljs-keyword">int</span> pre[maxn], vis[maxn], tim, ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;<span class="hljs-keyword">int</span> &amp; v = edge[i].to;<span class="hljs-keyword">if</span> (vis[v] == tim) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//神奇的常数优化,不需要memset了</span>vis[v] = tim;<span class="hljs-keyword">if</span> (!pre[v] || dfs(pre[v])) &#123; <span class="hljs-comment">// 自己未被匹配 || 可以腾出一个位置; 这个写得顺序也是一个常数优化</span>pre[v] = u; <span class="hljs-comment">// 重新匹配成功</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> n = read(), m = read(), e = read();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= e; ++ i) &#123;<span class="hljs-keyword">int</span> ui = read(), vi = read();<span class="hljs-keyword">if</span> (ui &gt; n || vi &gt; m) <span class="hljs-keyword">continue</span>;add_edge(ui, vi);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;tim ++;<span class="hljs-keyword">if</span> (dfs(i)) ans ++;&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="2-二分图最大带权匹配-最优匹配"><a href="#2-二分图最大带权匹配-最优匹配" class="headerlink" title="2. 二分图最大带权匹配(最优匹配)"></a>2. 二分图最大带权匹配(最优匹配)</h4><p>就是给每一个匹配加一个权值,然后求最大匹配,同时使权值最优.</p><p>同样可以跑网络流. 不过主要使KM算法.这个东西可以用,但是似乎从来没有刻意去考过, 估计也暂时不将去考.</p><p>鉴于我自己只是了解大概思想, 板子就没有了.</p><h2 id="6-各种奇怪算法"><a href="#6-各种奇怪算法" class="headerlink" title="6. 各种奇怪算法"></a>6. 各种奇怪算法</h2><h3 id="1-差分约束"><a href="#1-差分约束" class="headerlink" title="1. 差分约束"></a>1. 差分约束</h3><p>有一大堆形如<br>$$<br>x{i} - x{j} \leq c_{k}<br>$$<br> 的不等式, 因为它们长得非常像SPFA / DJ中的三角形不等式, 于是乎可以用图论方法来求解这一堆东西的关系. </p><p>如果出现小于, 就在后面-1就好了, (至于double请自求多福), 如果是大于等于之类的, 打个负号然后考场上现场瞎编就好了.</p><p>如果存在负环, 表明不满足条件 (貌似很多题里面只要有环就不成立, 到时候随机应变就好了)</p><p>如果跑出来是个inf, 就表明没有任何的限制. </p><p>dis的结果就是每一条约束链的最小花费, (一组解?)</p><p>下面是个板子</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10001</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t_edge</span>&#123;</span> <span class="hljs-keyword">int</span> to, next, w; &#125; edge[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++;&#125;<span class="hljs-keyword">int</span> dis[maxn], vis[maxn], flg;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">return</span>;    vis[s] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[s]; i; i = edge[i].next) &#123;        <span class="hljs-keyword">int</span> v = edge[i].to;        <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (dis[v] &lt; dis[s] + edge[i].w) &#123;            dis[v] = dis[s] + edge[i].w;            <span class="hljs-keyword">if</span> (!vis[v]) spfa(v);            <span class="hljs-keyword">else</span> &#123; flg = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>; &#125;        &#125;    &#125;    vis[s] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    n = read(); m = read();    <span class="hljs-keyword">int</span> op, ai, bi, ci;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;        op = read(); ai = read(); bi = read();        <span class="hljs-keyword">switch</span>(op) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:&#123;                ci = read();                add_e(bi, ai, ci);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;                ci = read();                add_e(ai, bi, -ci);                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;                add_e(ai, bi, <span class="hljs-number">0</span>); add_e(bi, ai, <span class="hljs-number">0</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;        spfa(i); <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(flg ? <span class="hljs-string">"No\n"</span> : <span class="hljs-string">"Yes\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="2-负环"><a href="#2-负环" class="headerlink" title="2. 负环"></a>2. 负环</h3><p>深搜或者SPFA都可以用来判负环</p><p>至于正环, 随便写一写就好了</p><p>上代码</p><p>大法师:</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// luogu-judger-enable-o2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">3001</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c; <span class="hljs-keyword">while</span> ((c = getchar()) &gt; <span class="hljs-string">'9'</span> || c &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) f = <span class="hljs-number">0</span>; x = c - <span class="hljs-number">48</span>;    <span class="hljs-keyword">while</span> ((c = getchar()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; c &lt;= <span class="hljs-string">'9'</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-number">48</span>; <span class="hljs-keyword">return</span> f ? x : ~x + <span class="hljs-number">1</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t_edge</span>&#123;</span> <span class="hljs-keyword">int</span> to, next, w; &#125; edge[maxn &lt;&lt; <span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> head[maxn], cnt = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add_e</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;    edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++;&#125;<span class="hljs-keyword">int</span> dis[maxn], vis[maxn], flg;<span class="hljs-keyword">int</span> n, m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">return</span>;    vis[s] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = head[s]; i; i = edge[i].next) &#123;        <span class="hljs-keyword">int</span> v = edge[i].to;        <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (dis[v] &gt; dis[s] + edge[i].w) &#123;            dis[v] = dis[s] + edge[i].w;            <span class="hljs-keyword">if</span> (!vis[v]) spfa(v);            <span class="hljs-keyword">else</span> &#123; flg = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>; &#125;        &#125;    &#125;    vis[s] = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> t = read();    <span class="hljs-keyword">while</span> (t --) &#123;        n = read(); m = read(); <span class="hljs-keyword">int</span> ui, vi, wi;        flg = <span class="hljs-number">0</span>; cnt = <span class="hljs-number">1</span>;         <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(head));        <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dis));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;            ui = read(); vi = read(); wi = read();            <span class="hljs-keyword">if</span> (wi &lt; <span class="hljs-number">0</span>) add_e(ui, vi, wi);            <span class="hljs-keyword">else</span> &#123; add_e(ui, vi, wi); add_e(vi, ui, wi); &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;            spfa(i); <span class="hljs-keyword">if</span> (flg) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">printf</span>(flg ? <span class="hljs-string">"YE5\n"</span> : <span class="hljs-string">"N0\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>百分数:</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IL inline</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RI register int</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100086</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> clear(a) memset(a,0,sizeof a)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rk for(RI i=1;i&lt;=n;i++)</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function">IL <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> f=<span class="hljs-number">1</span>;x=<span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> s=getchar();    <span class="hljs-keyword">while</span>(s&gt;<span class="hljs-string">'9'</span>||s&lt;<span class="hljs-string">'0'</span>)&#123;<span class="hljs-keyword">if</span>(s==<span class="hljs-string">'-'</span>)f=<span class="hljs-number">-1</span>;s=getchar();&#125;    <span class="hljs-keyword">while</span>(s&lt;=<span class="hljs-string">'9'</span>&amp;&amp;s&gt;=<span class="hljs-string">'0'</span>)&#123;x=x*<span class="hljs-number">10</span>+s-<span class="hljs-string">'0'</span>;s=getchar();&#125;    x*=f;&#125;<span class="hljs-keyword">int</span> n,m,T;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">code</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w;&#125;edge[N];<span class="hljs-keyword">bool</span> vis[N];<span class="hljs-keyword">int</span> head[N],tot,dis[N],cnt[N];<span class="hljs-function">IL <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span>&#123;edge[++tot].u=head[x];edge[tot].v=y;edge[tot].w=z;head[x]=tot;&#125;<span class="hljs-function">IL <span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now)</span></span><span class="hljs-function"></span>&#123;    rk vis[i]=<span class="hljs-literal">false</span>,dis[i]=<span class="hljs-number">2147483647</span>,cnt[i]=<span class="hljs-literal">false</span>;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    q.push(now);    vis[now]=<span class="hljs-literal">true</span>;    dis[now]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> u=q.front();q.pop();vis[u]=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>(cnt[u]&gt;=n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(RI i=head[u];i;i=edge[i].u)        &#123;            <span class="hljs-keyword">if</span>(dis[edge[i].v]&gt;dis[u]+edge[i].w)            &#123;                dis[edge[i].v]=dis[u]+edge[i].w;                <span class="hljs-keyword">if</span>(!vis[edge[i].v])                &#123;                    q.push(edge[i].v);                    vis[edge[i].v]=<span class="hljs-literal">true</span>;                    cnt[edge[i].v]++;                    <span class="hljs-keyword">if</span>(cnt[edge[i].v]&gt;=n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    read(T);    <span class="hljs-keyword">while</span>(T--)    &#123;        read(n),read(m);        tot=<span class="hljs-number">0</span>;clear(head);        <span class="hljs-keyword">for</span>(RI i=<span class="hljs-number">1</span>,u,v,w;i&lt;=m;i++)        &#123;            read(u),read(v),read(w);            <span class="hljs-keyword">if</span>(w&lt;<span class="hljs-number">0</span>)add(u,v,w);            <span class="hljs-keyword">else</span> add(u,v,w),add(v,u,w);        &#125;        <span class="hljs-built_in">puts</span>(spfa(<span class="hljs-number">1</span>)?<span class="hljs-string">"YE5"</span>:<span class="hljs-string">"N0"</span>);    &#125;&#125;</code></pre></div><h3 id="3-最小环"><a href="#3-最小环" class="headerlink" title="3.  最小环"></a>3.  最小环</h3><p>可以用Floyd来求, 似乎dj也可以做. 不过网上似乎只有Floyd的做法, 于是乎抄写一波.</p><h3 id="4-反图"><a href="#4-反图" class="headerlink" title="4. 反图"></a>4. 反图</h3><p>这个主要是用来解决不能到达终点的情况的. 很多时候正反跑一遍 或者直接反着跑就会奇迹再现</p><h3 id="5-欧拉路"><a href="#5-欧拉路" class="headerlink" title="5. 欧拉路"></a>5. 欧拉路</h3><h3 id="6-哈密顿路"><a href="#6-哈密顿路" class="headerlink" title="6. 哈密顿路"></a>6. 哈密顿路</h3><p>不管了</p><h3 id="7-倍增"><a href="#7-倍增" class="headerlink" title="7. 倍增"></a>7. 倍增</h3><p>这个可以用来优化图上 / 树上的长度问题. 具体写得话, 随缘了.</p><p><strong>记得不要把数组开太小</strong>. 还有这个玩意儿有点耗空间. (不过这几年不卡空间就是了)</p><h2 id="7-一些奇特的东西"><a href="#7-一些奇特的东西" class="headerlink" title="7.一些奇特的东西"></a>7.一些奇特的东西</h2><h3 id="1-DFS序和DFS树"><a href="#1-DFS序和DFS树" class="headerlink" title="1.DFS序和DFS树"></a>1.DFS序和DFS树</h3><p>咕咕咕…</p><h2 id="8-一些奇葩题"><a href="#8-一些奇葩题" class="headerlink" title="8. 一些奇葩题"></a>8. 一些奇葩题</h2><ol><li>POJ3613 看起来是图论题的矩阵快速幂</li><li>NOIP2013 华容道: 非常牛逼的一条图论建模</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOIP退役整理 1 数学相关</title>
    <link href="/2018/11/05/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/11/05/NOIP%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="NOIP退役整理-1-数学相关"><a href="#NOIP退役整理-1-数学相关" class="headerlink" title="NOIP退役整理 1  数学相关"></a>NOIP退役整理 1  数学相关</h1><blockquote><p>看完保证你,退役</p><p>这篇笔记里从不写证明</p></blockquote><p>[TOC]</p><h3 id="0-更加基础的算法"><a href="#0-更加基础的算法" class="headerlink" title="0.更加基础的算法"></a>0.更加基础的算法</h3><p>这里贴几个最最最最基础的算法</p><h4 id="1-√n求因数"><a href="#1-√n求因数" class="headerlink" title="1.√n求因数"></a>1.√n求因数</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, fac[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>  </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= x; ++ i) &#123;<span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;fac[++ cnt] = i; <span class="hljs-keyword">if</span> (i != x / i) fac[++ cnt] = x / i;&#125;&#125;&#125;</code></pre></div><h4 id="2-gcd"><a href="#2-gcd" class="headerlink" title="2.gcd"></a>2.gcd</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);&#125;</code></pre></div><h4 id="3-√n分解质因数"><a href="#3-√n分解质因数" class="headerlink" title="3.√n分解质因数"></a>3.√n分解质因数</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>; prime[maxn], index[maxn];<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prime_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; ++ i)        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;            prime[++ cnt] = i, index[cnt] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) x /= i, index[cnt] ++;    &#125;    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) prime[++ cnt] = x, index[cnt] = <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="1-裴蜀定理-Bezout"><a href="#1-裴蜀定理-Bezout" class="headerlink" title="1. 裴蜀定理 (Bezout)"></a>1. 裴蜀定理 (Bezout)</h3><p>$$<br>ax + by = m<br>$$</p><p>对于这样一个不定方程,当且仅当<code>gcd(a,b) | m</code>的时候,有无数多个整数解.特别的,对于 <code>ax + by = 1</code>, 当且仅当a和b互质时有如上结论.</p><p>另: 对于任意多个未知数和任意多个系数, 这个结论也是成立的. 也就是<br>$$<br>a_{1}x_{1} + a_{2}x_{2} + \cdots + a_{n}x_{n} = d \<br>其中d = (a_{1}, a_{2}, \cdots,a_{n})<br>$$<br>这样一个式子. </p><p>似乎简单的用法就是推出系数和后面的解的关系,然后用<code>gcd</code>或者<code>整数相关的东西</code>瞎搞.</p><p>例题:</p><ol><li>BZOJ 1441. 显然就是推广结论的裸题</li><li>&lt;JSOI 2009 瓶子和燃料&gt; 虽然感觉和Bezout没有什么关系…个人认为,这就是个结论题, 似乎用辗转相减更好理解一点</li><li>&lt;HAOI2011 向量&gt; 这个比较难,要多推几步.也是一条Bezout定理.(从某个聚铑博客里发现的题) (这个我不会写)</li><li>NOIP2014 Day2T3 解方程. 这个似乎就是直接枚举(因为1e6好像可以过去),然后Bezout定理去检验.(话说这题好皮啊…)(然而我也不会写)</li></ol><h3 id="2-拓展欧几里得-Ex-Gcd"><a href="#2-拓展欧几里得-Ex-Gcd" class="headerlink" title="2.拓展欧几里得 (Ex_Gcd)"></a>2.拓展欧几里得 (Ex_Gcd)</h3><h4 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h4><p>这个算是一个比较基础的算法,用来解线性同余方程.</p><p>这个方程大概长这个样子:<br>$$<br>ax \equiv b\pmod {m}<br>$$<br>我们需要求整数解.</p><p>把这个玩意儿变个形, 就得到了<br>$$<br>ax + my = b<br>$$<br>这不就是个二元不定方程吗.这个可以用exgcd来解.显然, 由Bezout定理可知, 如果有整数解,那就一定有无数个这样的解. 当且仅当<code>(a,m) | b</code>时有整数解</p><p>所以在解方程之前需要判定合法. 也就是判断<code>(a, m)|b</code>是否成立.</p><p>先上代码</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> &amp; d, <span class="hljs-keyword">int</span> &amp; x, <span class="hljs-keyword">int</span> &amp;y)</span> </span>&#123;    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, d = a;    &#125;    <span class="hljs-keyword">else</span> &#123;        ex_gcd(b, a % b, d, y, x); <span class="hljs-comment">// 划重点. x和y不要打反了</span>        y -= x * (a / b); <span class="hljs-comment">//这个括号一定要打。否则会先乘溢出</span>    &#125;&#125;</code></pre></div><p>解出来以后,这只是一个解.</p><p>所有的解可以由一种构造方法得到, 也就是通解.<br>$$<br>x_{i} = x_{0} + i<em>b/(a,m),i\in Z \<br>y_{i} = y_{0} - i</em>b/(a,m),i\in Z<br>$$<br>还有最小整数解:<br>$$<br>x_{min} = (x*b/d \bmod (m / d) + m / d) \bmod (m/d) \<br>其中d = (a, m); \<br>$$<br>似乎还可以这么写: (不是很清楚这两个有什么区别) 总而言之,求逆元用下面的,最小整数解用上面的<br>$$<br>x_{min} = (x \bmod m + m) \bmod m<br>$$</p><h4 id="2-中国剩余定理"><a href="#2-中国剩余定理" class="headerlink" title="2. 中国剩余定理"></a>2. 中国剩余定理</h4><p>用来解线性同余方程组.背结论好了.<br>$$<br>设m_1, m_2, m_3, \cdots, m_n 是两两互质的数\<br>设 m = \Pi_{i=1}^nm_i\<br>M_i = \frac{m}{m_i}\<br>t_i是同余方程 M_i*t_i \equiv 1 \pmod m_i的一个解\</p><p>$$</p><p>$$<br>则对于任意n个整数a_1,a_2,\cdots,a_n,\<br>\begin{equation}<br>\left{<br>\begin{array}{lr}<br>x \equiv a_1 \pmod{m_1} \<br>x \equiv a_2 \pmod{m_2} \<br>\cdots \<br>x \equiv a_n \pmod {m_n}<br>\end{array}<br>\right.<br>\end{equation} \<br>该方程组有整数解, 为x = \Sigma_{i=1}^{n}a_iM_it_i<br>$$<br>同样的,这也只是一个特解. 最小整数解需要%一下.</p><p>终于到例题了:</p><ol><li>Poj1061 青蛙的约会. 经典老题</li><li>NOIP2012 同余方程. 裸的拓欧.</li><li>没了. 附赠:<a href="http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html" target="_blank" rel="noopener">一个不错的讲解</a></li></ol><h3 id="3-各种筛-把你打成筛子"><a href="#3-各种筛-把你打成筛子" class="headerlink" title="3.各种筛 (把你打成筛子)"></a>3.各种筛 (把你打成筛子)</h3><p>这个相信大家都很清楚是什么. 就当板子放在这里.</p><h4 id="1-素数筛"><a href="#1-素数筛" class="headerlink" title="1.素数筛"></a>1.素数筛</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;vis[i] = prime[++ cnt] = i;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; ++ j)  &#123;<span class="hljs-keyword">if</span> (prime[j] &gt; vis[i] || prime[j] &gt; n / i) <span class="hljs-keyword">break</span>;vis[i * prime[j]] = prime[j];&#125;&#125;&#125;</code></pre></div><p>顺手判素数</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= x; ++ i) &#123;        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h4 id="2-欧拉筛"><a href="#2-欧拉筛" class="headerlink" title="2.欧拉筛"></a>2.欧拉筛</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_phi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<span class="hljs-keyword">if</span> (!vis[i]) &#123;vis[i] = prime[++ cnt] = i;phi[i] = i - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= cnt; ++ j)  &#123;<span class="hljs-keyword">if</span> (prime[j] &gt; vis[i] || prime[j] &gt; n / i) <span class="hljs-keyword">break</span>;vis[i * prime[j]] = prime[j];phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - <span class="hljs-number">1</span> : prime[j]);&#125;&#125;&#125;</code></pre></div><p>求一个phi. 长得和分解质因数一毛一样</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_phi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; ++ i) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;            ans = ans / i * (i - <span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i;        &#125;    &#125;    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) ans = ans / n * (n - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><p>顺便一提, phi(n)表示小于等于n的素数个数</p><p>积性函数什么的反正考不到我也不会,就不管了.</p><p>大概的表是 0, 1, 2, 2, 4, 2, 6, 4, 10 …… 这个可以打表想到</p><p>例题: Poj3090.可以由暴力算法观察结果得出,这个是个欧拉函数(反正当时做的时候是打表出来的).至于具体证明,呵呵</p><h3 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4.逆元"></a>4.逆元</h3><p>逆元就是用来做除法取模的东西. 一个数处以另一个数等于被除数乘上除数的逆元.(因为在取模的时候,除法不满足结合律, 所以要用逆元)我们有多种方法求逆元,直接给出代码.</p><h4 id="1-exgcd"><a href="#1-exgcd" class="headerlink" title="1.exgcd"></a>1.exgcd</h4><p>这个其实就是线性同余方程右边是1的情况下的解, 很明显它是唯一的,而且可以用exgcd解.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-keyword">int</span> x, y, d;ex_gcd(n, p, x, y, d);<span class="hljs-keyword">return</span> (x%p+p)%p;&#125;</code></pre></div><p>复杂度 <code>O(log(n))</code></p><h4 id="2-费马小定理"><a href="#2-费马小定理" class="headerlink" title="2.费马小定理"></a>2.费马小定理</h4><p>这个只有在a,p互素的时候才能用</p><p>由<br>$$<br>a^{p-1} \equiv 1 \pmod {p}, p是素数<br>$$<br>可以随便瞎推得<br>$$<br>inv(i) = i^{p-2} \pmod{p}, p是素数<br>$$<br>因为用了一个快速幂,所以复杂度是<code>O(log(n))</code></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_inv_fm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-keyword">int</span> k = p - <span class="hljs-number">2</span>, ans = <span class="hljs-number">1</span>;x %= p;<span class="hljs-keyword">for</span> (; k; k &gt;&gt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) ans = ans * x % p;x = x * x % p;&#125;<span class="hljs-keyword">return</span> ans % p;&#125;</code></pre></div><p>其实还有什么Euler定理,当n垂直于a的时候,a^φ(n) 同余于 1(在模n意义下).这样的玩意儿</p><h4 id="3-线性递推"><a href="#3-线性递推" class="headerlink" title="3.线性递推"></a>3.线性递推</h4><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_inv_arr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> p)</span></span>&#123;inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;inv[i] =(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(p - p/i) * inv[p % i] % p;<span class="hljs-comment">//防溢出</span>&#125;&#125;</code></pre></div><p>这个没什么好说的,反正不长,背下来就好.</p><h3 id="5-组合相关"><a href="#5-组合相关" class="headerlink" title="5.组合相关"></a>5.组合相关</h3><h4 id="1-基本内容-1"><a href="#1-基本内容-1" class="headerlink" title="1.基本内容"></a>1.基本内容</h4><ul><li><p>加法, 乘法原理</p></li><li><p>排列数</p></li></ul><p>$$<br>P_{n}^{m} = \frac{n!}{(n-m)!}<br>$$</p><ul><li>组合数</li></ul><p>$$<br>C_{n}^{m} = \frac{n!}{m!(n-m)!} = \frac{P_{n}^{m}}{m!}<br>$$</p><ul><li>相关计算性质</li></ul><p>$$<br>C_{n}^{m} = C_{n}^{n-m} \<br>C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} \<br>\Sigma_{i = 0}^{n}C_{n}^{i} = 2^{n}<br>$$</p><p>这些东西可以用来递推或者化简.</p><p>虽然不知道是什么,但是还是写一下多重集的组合数吧233<br>$$<br>对于一个多重集S = {n_{1}<em>a_{1},n_2</em>a_2,\dots,n_k*a_k} \<br>设整数r&lt;=n_i(i\in[1,k]),从S中取出r个元素的不同多重集数量是C_{k+r-1}^{k-1}<br>$$</p><p>有时候需要求组合数,接下来给出相关代码</p><ol><li><p>求一个组合数</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">comb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<span class="hljs-keyword">int</span> n_1 = <span class="hljs-number">1</span>, m_1 = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= n - m + <span class="hljs-number">1</span>; -- i) n_1 = n_1 * i % p;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= m; -- i) m_1 = m_1 * i % p;<span class="hljs-keyword">return</span> n_1 * get_inv(m_1, p) % p; <span class="hljs-comment">//假装我们这里有一个求逆元的函数</span>&#125;</code></pre></div><p>这个比较慢,<code>O(n)</code>的</p></li><li><p>求很多个</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">//假设我们有了所有阶乘的取模的值和其逆元的值</span><span class="hljs-keyword">return</span> fac[n] * fac_inv[m] * fac[n - m] % p;</code></pre></div></li></ol><ul><li>二项式定理(杨辉三角形)</li></ul><p>就是那个noip2011 day2t1.<br>$$<br>(a+b)^{n} = \Sigma_{i = 0}^{n}C_{n}^{i}a^{i}b^{n-i}<br>$$</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++ i) &#123;comb[i][<span class="hljs-number">0</span>] = comb[i][i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= k; ++ i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;comb[i][j] = (comb[i<span class="hljs-number">-1</span>][j] + comb[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) % hhr;&#125;&#125;</code></pre></div><h4 id="2-Lucas定理"><a href="#2-Lucas定理" class="headerlink" title="2.Lucas定理"></a>2.Lucas定理</h4><p>$$<br>C_{n}^{m} \equiv C_{n \bmod p}^{m \bmod p} * C_{n/p}^{m/p} \pmod {p}<br>$$</p><p>注意,这里的p是<strong>素数</strong>, 如果是合数的情况,似乎是可以分解来做. 我给的地址里面有讲到.</p><p>唯一的~~例题似乎是BJZOJ1951的古代猪文.比较难,还要合并线性同余方程组(中国剩余定理).不会写</p><p>带Lucas定理的求组合数. 据说在模数比较大的时候不需要Lucas(来自某位dalao)</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">fast_pow</span><span class="hljs-params">(ll a, ll b, ll &amp;p)</span> </span>&#123;ll ans = <span class="hljs-number">1</span>; a %= p;<span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ans = ans * a % p;a = a * a % p;&#125;<span class="hljs-keyword">return</span> ans % p;&#125;<span class="hljs-function">ll <span class="hljs-title">Comb</span><span class="hljs-params">(ll n, ll m, ll &amp;p)</span> </span>&#123;<span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;ll ans = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;ll a = (n - m + i) % p;ll b = i % p;ans = ans * (a * fast_pow(b, p<span class="hljs-number">-2</span>, p) % p) % p; <span class="hljs-comment">// 费马小定理逆元 </span>&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">Lucas</span><span class="hljs-params">(ll n, ll m, ll &amp;p)</span> </span>&#123;<span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> Comb(n % p, m % p, p) * Lucas(n / p, m / p, p) % p;&#125;</code></pre></div><p>其实还有拓展Lucas定理…不管了.</p><p>赠送:<a href="https://blog.csdn.net/acdreamers/article/details/8037918" target="_blank" rel="noopener">一个很好的文章</a></p><h4 id="3-容斥原理"><a href="#3-容斥原理" class="headerlink" title="3.容斥原理"></a>3.容斥原理</h4><p>这个东西说简单也很简单, 但是不是非常好说明.那么一大堆数学公式不但难打,而且看着也嫌烦. <strong>举个例子</strong>,就是那个高一数学做的集合题, 那个什么参加乒乓球, 篮球还有什么足球的同学一共多少个什么的东西.这个东西在竞赛中的应用大概是把一类计数类问题进行转换,转换成比较便于计算的形式,然后得出结果,通常是什么逆向思维.也有分类之后算总和的时候进行容斥以得出正确的结论.</p><p>因为我自己写得比较烂,理解也非常浅陋,下面贴几个Blog:</p><p><a href="https://blog.csdn.net/m0_37286282/article/details/78869512" target="_blank" rel="noopener">1</a></p><h4 id="4-隔板法"><a href="#4-隔板法" class="headerlink" title="4.隔板法"></a>4.隔板法</h4><p><strong>隔板法</strong>就是在n个元素间的(n-1)个空中插入k个板,可以把n个元素分成k+1组的方法.</p><p>这个东西讲起来比较麻烦…2333继续放blog(其实是我不会)</p><p><a href="https://blog.csdn.net/sdz20172133/article/details/81431066" target="_blank" rel="noopener">1</a></p><h3 id="6-矩阵相关"><a href="#6-矩阵相关" class="headerlink" title="6.矩阵相关"></a>6.矩阵相关</h3><p>矩阵的基本计算就不说了.</p><p>矩阵考的最多的就是用矩阵来加速多项式的递推计算,也就是矩阵快速幂</p><h4 id="1-矩阵快速幂"><a href="#1-矩阵快速幂" class="headerlink" title="1.矩阵快速幂"></a>1.矩阵快速幂</h4><p>先上板子</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matrix</span> &#123;</span>ll dat[maxn][maxn]; <span class="hljs-keyword">int</span> n, m;matrix(<span class="hljs-keyword">int</span> sz1, <span class="hljs-keyword">int</span> sz2) : n(sz1), m(sz2) &#123;<span class="hljs-built_in">memset</span>(dat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dat));&#125;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> matrix <span class="hljs-keyword">operator</span> + (matrix a, matrix b) &#123;<span class="hljs-function">matrix <span class="hljs-title">c</span><span class="hljs-params">(a.n, a.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.n; ++ i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= a.m; ++ j) &#123;c.dat[i][j] = a.dat[i][j] + b.dat[i][j];&#125;&#125;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-keyword">inline</span> <span class="hljs-keyword">friend</span> matrix <span class="hljs-keyword">operator</span> * (matrix a, matrix b) &#123;<span class="hljs-function">matrix <span class="hljs-title">c</span><span class="hljs-params">(a.n, b.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= c.n; ++ i) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= c.m; ++ j) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= a.m; ++ k) &#123;c.dat[i][j] = (c.dat[i][j] + a.dat[i][k] * b.dat[k][j] % p) % p;&#125;&#125;&#125;<span class="hljs-keyword">return</span> c;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> matrix <span class="hljs-title">fast_pow</span><span class="hljs-params">(matrix a, ll k)</span> </span>&#123;<span class="hljs-function">matrix <span class="hljs-title">ans</span><span class="hljs-params">(a.n, a.m)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= ans.n; ++ i) &#123;ans.dat[i][i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">for</span> (; k; k &gt;&gt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) ans = ans * a;a = a * a;&#125;<span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><h4 id="2-矩阵加速递推"><a href="#2-矩阵加速递推" class="headerlink" title="2.矩阵加速递推"></a>2.矩阵加速递推</h4><p>对于一个递推式,我们可以把它放在某一个矩阵里面.然后它的每一次递推操作可以使用矩阵运算来解决,套上快速幂就会像记者一样.难点主要在于构建单位矩阵.</p><p>以Fibonacci为例:</p><p>我们有<br>$$<br>F[n] = F[n-1] + F[n-2]<br>$$<br>然后把它放到一个1*2的矩阵里面(我喜欢横着的)<br>$$<br>\left[<br>\begin{matrix}<br>F[n-1] &amp; F[n]<br>\end{matrix}<br>\right] \<br>\left[<br>\begin{matrix}<br>F[n-2] &amp; F[n-1]<br>\end{matrix}<br>\right]<br>$$<br>我们希望从上面一个推到下面一个, 于是乎由于<code>F[n-1] = 0 * F[n-2] + 1 * F[n-1]</code>, <code>F[n] = 1 * F[n-1]  + 1 * F[n-2]</code>,可以得出如下单位矩阵<br>$$<br>\left[<br>\begin{matrix}<br>0 &amp; 1 \<br>1 &amp; 1 \<br>\end{matrix}<br>\right]<br>$$<br>我们只要把这个矩阵做上n-1次乘法就可以得到结果了.</p><p>例题很多,就不一一列举了.</p><h3 id="7-线性基-虽然可能不考"><a href="#7-线性基-虽然可能不考" class="headerlink" title="7.线性基(虽然可能不考)"></a>7.线性基(虽然可能不考)</h3><p>这个比较简单，用来求一堆数异或起来的最值问题。主要的做法就是把这一堆数字的二进制给存起来，然后去一个一个异或。用到了向量的思想，不多说，背板子。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxbit = <span class="hljs-number">63</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linear_base</span> &#123;</span>linear_base() &#123;<span class="hljs-built_in">memset</span>(dat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dat));&#125;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dat[maxbit + <span class="hljs-number">1</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = maxbit; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<span class="hljs-keyword">if</span> (n &amp; (<span class="hljs-number">1L</span>L &lt;&lt; i)) &#123;<span class="hljs-keyword">if</span> (!dat[i])&#123;dat[i] = n;<span class="hljs-keyword">break</span>;&#125;n ^= dat[i];&#125;&#125;<span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get_min</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = maxbit; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<span class="hljs-keyword">if</span> (dat[i]) <span class="hljs-keyword">return</span> dat[i];&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get_max</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ret = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> i = maxbit; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<span class="hljs-keyword">if</span> ((ret ^ dat[i]) &gt; ret) &#123;ret ^= dat[i];&#125;&#125;<span class="hljs-keyword">return</span> ret;&#125;&#125;;</code></pre></div><p>附赠:<a href="https://blog.csdn.net/qaq__qaq/article/details/53812883" target="_blank" rel="noopener">一个很好的文章</a></p><h3 id="8-概率期望-碰到就放弃系列"><a href="#8-概率期望-碰到就放弃系列" class="headerlink" title="8.概率期望(碰到就放弃系列)"></a>8.概率期望(碰到就放弃系列)</h3><h4 id="1-基本内容-2"><a href="#1-基本内容-2" class="headerlink" title="1.基本内容"></a>1.基本内容</h4><h4 id="2-期望DP"><a href="#2-期望DP" class="headerlink" title="2.期望DP"></a>2.期望DP</h4><h3 id="9-神奇的东西"><a href="#9-神奇的东西" class="headerlink" title="9.神奇的东西"></a>9.神奇的东西</h3><h4 id="1-题目收集"><a href="#1-题目收集" class="headerlink" title="1.题目收集"></a>1.题目收集</h4><ol><li>Luogu: 斐波那契公约数 gcd(F[n], F[m]) = F[gcd(n,m)]</li><li>Luogu: P4388 phi</li></ol><h4 id="2-GCD相关性质"><a href="#2-GCD相关性质" class="headerlink" title="2.GCD相关性质"></a>2.GCD相关性质</h4><p>并不清楚有什么</p><h4 id="3-几个数列"><a href="#3-几个数列" class="headerlink" title="3.几个数列"></a>3.几个数列</h4><h5 id="1-Catalan"><a href="#1-Catalan" class="headerlink" title="1. Catalan"></a>1. Catalan</h5><p>$$<br>Cat_n = \frac{C_{2n}^{n}}{n + 1}<br>$$</p><p>几个常见的情况:</p><ol><li>合法括号匹配序列数(n左n右 -&gt; Cat(n))</li><li>合法出栈序列数(n个数 -&gt; Cat(n))</li><li>n个节点构成的不同二叉树的数量</li></ol><p>给个表:1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012……</p><h5 id="2-Fibonacci"><a href="#2-Fibonacci" class="headerlink" title="2. Fibonacci"></a>2. Fibonacci</h5><p>这个就不说了</p><h5 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3.欧拉函数"></a>3.欧拉函数</h5><p>前面有</p><h5 id="4-约数个数"><a href="#4-约数个数" class="headerlink" title="4.约数个数"></a>4.约数个数</h5><h4 id="4-数论分块"><a href="#4-数论分块" class="headerlink" title="4. 数论分块"></a>4. 数论分块</h4><p>这个详见余数求和那道题</p><h4 id="5-一些结论"><a href="#5-一些结论" class="headerlink" title="5.一些结论"></a>5.一些结论</h4><p>$$<br>(x + 1)^p \equiv x^p + 1 \pmod{p}<br>$$</p><p>可以用来证明Lucas定理(对于OI来说没什么用)<br>$$<br>对于a \perp b, 形如k*a + b的素数有无数个<br>$$<br>虽然不知道有什么用</p><h3 id="10-致谢"><a href="#10-致谢" class="headerlink" title="10.致谢"></a>10.致谢</h3><p>百度 cnblogs csdn luogu &lt;算法竞赛进阶指南&gt; &lt;信息学奥赛一本通 提高&gt; &lt;具体数学&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终末的集训记</title>
    <link href="/2018/11/03/%E7%BB%88%E6%9C%AB%E7%9A%84%E9%9B%86%E8%AE%AD%E8%AE%B0/"/>
    <url>/2018/11/03/%E7%BB%88%E6%9C%AB%E7%9A%84%E9%9B%86%E8%AE%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="终末的集训记"><a href="#终末的集训记" class="headerlink" title="终末的集训记"></a>终末的集训记</h1><blockquote><p>这次因为是在外面, 没有自己的笔记本, 于是乎就尝试了一下VSC的Markdown功能, 感觉除了预览比较慢, 还是很好用的.</p></blockquote><h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>今天已经11月3日了, 离NOIP开始还有6天, 离NOIP结束还有7天, 这是最后一次外出集训, 莫名奇妙感觉有点… 本来是盼望着要早点退役的,但是突然又有一点不舍. 凡事总会结束, 即使是本来已经习惯于一直继续下去的OI. </p><p>不知道最后的我会得到怎样一个成绩, 也不知道这样一个奖又能干什么, 于是我就这么浑浑噩噩地走到了最后一次NOIP的重点. 这究竟是黎明前夜, 还是落日黄昏, 我不知道. 我只知道, 我即将走到尽头. 那之后迎接我的或许是解放, 亦或许是更加残酷的地狱. 即便是在最后的几天里, 我的日子还在照常继续, 没有停课, 也还得继续交作业.</p><p>同行的人们已经变为最可恶的对手, 与我争分夺秒, 用虚伪的面具相互麻痹, 相互干扰, 大声喧闹着一边自我贬低, 一边言不由衷地互相吹捧, 活像一群傻逼. 更加可恨的是, 我也不由得身陷其中, 成为一名可悲的竞赛”蒟蒻”. 我自责, 却又无法脱离其中, 因为只有这样才能掩盖自己内心的不安, 他们也是一样的吧. 或许每个人都觉得自己是最不安的, 其实大家都彼此彼此. 在这样一个玄学考试的竞赛中, 心理优势或许至关重要吧.</p><p>即使是还未结束, 我就开始构想起NOIP结束之后的日子了. 首先, 当然了, 参加其中考试. 真是无比不巧的组合. 然后就是给自己买一块机械键盘, 不过要看考得怎么样了, 拿到一等奖就RMB300+, 否则300-. 至于长期计划, 希望能够参加一部分有趣的小项目, 也希望能够花一年半的时间用心打磨一个个人项目(感觉要么是一个实用工具, 要么就是那个OJ吧). 大学的ICPC肯定是不会再去参加了, 算法竞赛是我一生的苦痛, 原因已经在很久以前的一篇文章里面写到了.</p><p>就这样, 废话到此结束, 向终点迈进吧.</p><h3 id="正事-训练总结"><a href="#正事-训练总结" class="headerlink" title="正事(训练总结)"></a>正事(训练总结)</h3><h4 id="R1D1"><a href="#R1D1" class="headerlink" title="R1D1"></a>R1D1</h4><p>第一天爆0是我一贯的作风, 于是我就爆了. T1的结论没有想出来, 贪心还写错了, 于是爆炸… T2其实是一个大暴力, 因为手生写了比较长的时间, 然后心态比较崩坏, 主要是处理字符读入, 然后一个简单的判环. 关键是我tm判环写了1h. 最后因为输出大小写错误爆了, 否则AC. 还是要认真复制这种东西. T3写道最后实在没有时间就随便交了一个0分. T3是一个图论+DP的题, 有点综合性, 想清楚了以后其实很好写, 正图反图各跑一边最短路, 然后按dis贪心排序, 最后变成区间分组的DP. DP的优化可以写DDDL或者决策点, 不过STD的优化比较毒瘤, 它看出了枚举范围然后缩小范围, 卡过去了.</p><p>这一天主要是有一点不适应, 整体难度较NOIP Day1稍微偏小, 不过风格还是比较像的, 可能是致敬NOIP2018 TG吧.</p><h4 id="R1D2"><a href="#R1D2" class="headerlink" title="R1D2"></a>R1D2</h4><p>这一天预计210实际165. T1是个大模拟, 码农题. 因为最后手滑, 不知道什么时候多按了一个括号, 也有可能是键盘的原因, 就挂掉了40分. T2水题, 也就普及水准. T3比较毒瘤, 是一个数据结构维护枚举各种乱搞的题, 至今只会写<code>O(N^3)</code>暴力, (我的三分贪心指拿了5分, 有一个人随机化贪心拿了65). 其实也比较像NOIP2018.</p><p>这一天发挥的还可以.</p><h4 id="R2D1"><a href="#R2D1" class="headerlink" title="R2D1"></a>R2D1</h4><p>这一天比较绝望, 因为发现自己除了骗分啥都不会写, 然而还愣是骗分拿了rk10, 自己都不明觉厉. T1优化DP, 然而我连方程都想了40min, 还是太菜了. 优化用决策单调性跑斜率优化就好了. 不过STD给的比较强, 直接暴力离散化过去(观察数据范围可得). T2是一个带概率期望的模拟题. 特别变态, 首先是期望的转移就不是特别会写, 在加上代码量比较大, 就骗了30分, 至今没有写出来. T3简直毒瘤, 容斥要算老半天, 记忆化搜索似乎可以A掉, 很巧妙, 也很好理解, 考场上没有想到实在是不应该. </p><p>这一天后来想想也不是不能再多一点分, 主要是自己DP太菜了.</p><h4 id="R2D2"><a href="#R2D2" class="headerlink" title="R2D2"></a>R2D2</h4><p>更加绝望. T1是一个优化DP, 然而用奇怪贪心A掉了, 还不怎么好卡. hhh. T2其实是会写的, 然而考试的时候建图少加了一些边, 炸到40分. 难受, 这一题还是一条老题. 想的时候还是要全面一点. T3就是个二分答案加并查集维护连通性. 考场上因为没有理解题目, 导致乱想了半天, 浪费了1h, 没有写出来, 连骗分都没有骗到. 也是个老的题目, 考完理清思路大概写了0.5h + 1h. </p><p>这一天分数还行, 不过不是很满意, 没有发挥好.</p><h4 id="R3D1"><a href="#R3D1" class="headerlink" title="R3D1"></a>R3D1</h4><p>最为绝望的一天. 连骗分都不会写的一次. T1暴力写, 本来接近正解了, 然后被旁边人带偏到了DP的不归路上, 没能推出方程, 然后就心态爆炸了(预计按实力可以AC). 最后绝望的花了1min 写了一个5行骗分, 因为数据太水骗到了70!!!震惊了!!! T2本来可以写出70分, 然而因为各种奇奇怪怪的原因, 最后只写了一个20分的裸暴力, 除了优化以外我的思路完全正确. T3是个数学题, 要用容斥推到一下, 然而十分良心的部分分使得各位选手(不包括我)拿的很开心. 我写了一个可以搞到50左右的纯递推暴力, 然而最后没有时间调试了, 就只有10分了. 后来把一种情况写对了, 就已经有大概40分了. 然后还可以不充斥直接算排列组合, 还有一部分的分值. 这个就随缘拿分了.</p><p>这一天简直是我NOIP滚粗退役的预兆. </p><h4 id="R3D2"><a href="#R3D2" class="headerlink" title="R3D2"></a>R3D2</h4><p>结论是我太菜了. T1在打表上浪费了一点时间, 其实没有必要, 不是每一题结论题都要打表, 还是要相信自己, 然后20min出正解. 最为毒瘤的是我居然在数据分治的时候, 暴力写错了, 没有考虑端点相等的情况, 只对了最后3个点. 头一次出现暴力写错了. T2是一个折半查找的题, 这个思路不太常用, 学习了. 然而我在考试的时候不知道为什么毒瘤地使用了常数巨大的算法(可能是因为我太相信自己的卡常和STL了, 然后map莫名其妙地炸了. 还有就是因为毒瘤CTR它卡空间, 不敢开大数组换时间), 导致暴力分都写T了, 只拿了15分. T3绝对的暴力出奇迹, 写了一个<code>O(m^2)</code>的暴力算法, 还带一个log的set常数, 居然有80分, 预计40分. 不过后来换linux测的时候也不知道是不是时间卡的比较紧, 又掉回60分了. T3考场上其实快出正解了, 然而并没有最后想明白, 不过优秀卡常就已经很厉害了. 正解就是找一下三元环, 然后重新建有向图<code>O(n)</code>跑. 神奇的算法, 不过不会写. 最强的人暴力卡常90分, 在这里赶快再膜一波, 以求NOIP卡常时RP++.</p><p>今天跟昨天差不多难受, 估计需要调整一下心态了</p><h4 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h4><p>感觉自己的图论和模拟还能应付, 不至于特别惨, 不过数学和dp就比较难了… 贪心是一种随缘的算法, 不管它. 心态还是很重要的, 最后主要还是靠部分分尽量多拿来获得国一这种东西. 至于接下来的一个星期, 主要就练习一下模拟和暴力, 有好几道NOIP的模拟原题, 感觉不错. 至于学校的训练, 如果可以就去吧.</p><h3 id="接下来的东西"><a href="#接下来的东西" class="headerlink" title="接下来的东西"></a>接下来的东西</h3><p>明天开始就可能停课了</p>]]></content>
    
    
    
    <tags>
      
      <tag>NOIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 并发相关内容整理</title>
    <link href="/2018/08/30/JAVA%20%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
    <url>/2018/08/30/JAVA%20%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-并发相关内容整理"><a href="#JAVA-并发相关内容整理" class="headerlink" title="JAVA 并发相关内容整理"></a>JAVA 并发相关内容整理</h1><h3 id="Java线程与Linux内核线程的映射关系"><a href="#Java线程与Linux内核线程的映射关系" class="headerlink" title="Java线程与Linux内核线程的映射关系 "></a><a href="http://blog.sina.com.cn/s/blog_605f5b4f010198b5.html" target="_blank" rel="noopener">Java线程与Linux内核线程的映射关系 </a></h3><h3 id="Java并行知识点"><a href="#Java并行知识点" class="headerlink" title="Java并行知识点"></a><a href="https://blog.csdn.net/qq_35559756/article/details/73385468" target="_blank" rel="noopener">Java并行知识点</a></h3><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Lock</a></h3><h3 id="Synchronize"><a href="#Synchronize" class="headerlink" title="Synchronize"></a><a href="https://www.cnblogs.com/dolphin0520/p/3923737.html" target="_blank" rel="noopener">Synchronize</a></h3><h3 id="Lock和Synchronize性能比较"><a href="#Lock和Synchronize性能比较" class="headerlink" title="Lock和Synchronize性能比较"></a><a href="https://blog.csdn.net/ganyao939543405/article/details/52486316" target="_blank" rel="noopener">Lock和Synchronize性能比较</a></h3><h3 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a><a href="https://www.jianshu.com/p/be2dc7c878dc" target="_blank" rel="noopener">Condition对象</a></h3><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><a href="https://www.cnblogs.com/qjjazry/p/6581568.html" target="_blank" rel="noopener">乐观锁和悲观锁</a></h3><h3 id="Java-Executor"><a href="#Java-Executor" class="headerlink" title="Java Executor"></a><a href="https://blog.csdn.net/ns_code/article/details/17465497" target="_blank" rel="noopener">Java Executor</a></h3><h3 id="线程安全容器"><a href="#线程安全容器" class="headerlink" title="线程安全容器"></a><a href="https://blog.csdn.net/u010425776/article/details/54890215" target="_blank" rel="noopener">线程安全容器</a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OI劝退指南 &amp;&amp; 退役预定感言</title>
    <link href="/2018/08/03/OI%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97-%E9%80%80%E5%BD%B9%E9%A2%84%E5%AE%9A%E6%84%9F%E8%A8%80/"/>
    <url>/2018/08/03/OI%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97-%E9%80%80%E5%BD%B9%E9%A2%84%E5%AE%9A%E6%84%9F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="OI劝退指南-amp-amp-退役预定感言"><a href="#OI劝退指南-amp-amp-退役预定感言" class="headerlink" title="OI劝退指南 &amp;&amp; 退役预定感言"></a>OI劝退指南 &amp;&amp; 退役预定感言</h1><blockquote><p>写了6年代码，搞了4年竞赛，终于要到头了。万事终有结束的一天，现在我倒是希望我的竞赛早点结束。我不希望再在自己不喜欢的事情上浪费时间了。总之，撑到今年NOIP就好。结束之后，我决定不再参加任何算法类<strong>竞赛</strong>，也不接受关于算法<strong>竞赛</strong>的任何咨询和讨论。</p><p>正如标题所言，这一篇blog是作为一个失败者写给后死者们看的，希望以后的学生们不要<strong>盲目</strong>地被拉上贼船吧，希望他们能够做真正自己喜欢的事情。</p><p>“<em>后死诸君多努力</em> ”     —— ？？</p></blockquote><h3 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h3><p>​    正所谓殊途同归，每个人都应该有一个不同的开始。至于我，一个被拉上贼船的人，自然不是对竞赛或者是算法感兴趣。在小学的时候，因为非常闲（这也导致我现在每天累的死去活来还考得一塌糊涂），所以天天在打游戏。那时候虽然已经是2011年了，我五年级，但是我还是很喜欢玩C&amp;C系列中的Red Alert 2，一款2000年针对win2000左右系统开发的即时战略游戏。我对它进行了深入的研究，也不再满足于仅仅是在它既有的框架内玩游戏，就开始玩mod，以至于自己想要写一个mod。一开始先改一改配置文件（没错，就是那个rules.ini，玩过的都知道），后来发现这样也太局限了，就顺手接触了编程相关的内容。因为各种原因，我最先学会的，居然是VBS（就是那个windows脚本，天天被用来做无脑病毒）。后来由于要忙小升初，就浪费了一段时间。</p><p>​    上初一之前，我被拉去参加了一个类似于竞赛预科班一样的东西，于是乎就学会了Pascal和基本的算法。初一开始，学校有NOIP的竞赛，我也顺手去报了名。然而我并不是那么重视这个东西，因为它主要是做题。在做够了八国联军的题目之后，我不想再看到题目。初一的寒假，本校唯一一次和盐城大丰的某个学校联系举行了一次冬令营，在那里我发现了自己的浅薄，那里的学生已经掌握了高阶的算法，基本上是我在高一的时候才会的东西。然而我并没有引起重视。在那里最大的收获是一个学生教练，Tsinghua计算机毕业，当时因为NOI金牌保送的。从他那里我了解了更加广大的计算机世界，比如java，c++，python和php这些语言。于是回来以后我就更无心竞赛，开始学这些东西。初二的时候，莫名其妙地过了初赛，NOIP普及组两日游，拿了个小奖。那年暑假，我才真正认真的开始竞赛，估计那时侯水平还是可以的，够得上提高组的二等奖了。那个暑假，我还开始了对编译器的研究，写出来一个小的解释器demo，可以有控制流和数组。初三的NOIP考得非常惨，因为少打一个空格导致最后一题爆零，错失一等奖。</p><p>​    中考结束以后，事情很多，就没有再搞竞赛。只是在开学之后突击了一下，就去考了NOIP2017提高，因为没有开long long错失一等奖，非常气，就打算再忙一年。渐渐发现，自己已经跟不上趟了，数学思维的硬伤导致我的动态规划和数学内容非常差，图论和打表暴力还马马虎虎。计算机竞赛已经成为了一块心病，一个包袱，丢不掉，也不想去学，一直到现在，浪费了我不少时间，也没有多大长进，估计也不会有什么好的成果。</p><p>​    这就是我的故事，6年，也就短短百余字。</p><h3 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h3><p>​    这几年比较后悔的事情，就是没有在NOIP2017以后就退役，以及发现算法竞赛本质太迟了，直到年初我才大概搞明白什么才是我真正想要去学习的。还有就是初中太浪了吧。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li><p>第一个结论是关于算法竞赛<strong>本质</strong></p><p>算法竞赛，本质上更加倾向于数学，尤其是离散数学，而且基本超出了高中的范围，和高中课程基本没有什么联系。我作为一个数学渣，能撑这么久，主要还是编程能力在死磕。而且算法就是数学的一个分支，考到的内容一般比较抽象，对审题建模要求也比较高，计算机不过是个工具罢了。单单通过学习算法竞赛，你甚至不能搞懂计算机是怎么工作的，也不要妄想能够写出一个像样的应用。</p></li><li><p>第二个结论是关于算法竞赛的<strong>优点</strong></p><p>首先可以对编程有一个基本的认识。</p><p>其次可以学到许多离散数学的知识和以后基本用不到的算法（基本上二叉树封顶）</p><p>还有对理科思维也是有一定的作用的</p><p>最后当然是如果考得好（怎么说也得省队吧）的话，可以自主招生</p></li><li><p>第三个结论是关于它的<strong>缺点</strong></p><p>这个竞赛就像高考一样，是考试。它会挖空心思来为难考生，有许多根本在现实中不存在的巨大数据量和限制，而且很多模型是不切实际的。这个考试还会对学生的代码风格和以后写大型程序的能力造成巨大破坏。最可怕的一点在于，它需要用到电脑（注意我说的这个用词）。这样就比较尴尬了，因为会情不自禁的打开b站，打开qq，打开游戏。。。。etc。</p></li><li><p>第四个结论是关于<strong>初心</strong>和<strong>选择</strong></p><p>虽然我不是很喜欢那个包子，但是初心还是非常重要的。我就是一个忘记初心的人，我本来想要做游戏，后来就开始被学竞赛，甚至走偏到了操作系统的歪门邪道上来。我现在比较后悔当时没有毅然决然放弃竞赛，而是为了一些什么去硬撑着，总觉得有点可惜，反而浪费了热情和精力。</p><p>这里还要谈一谈所谓竞赛和工程。竞赛是智力游戏，而工程是荒野求生。竞赛关注算法的方方面面，而工程对效率、空间的要求较低，主要关注正确性，实用性和整体的架构。编程有很多方面，竞赛是给那些计算机科学家和未来的技术大佬准备的。如果立志成为工程师的话，其实不必沉迷过深，算法学到了就行了，竞赛什么的都去死吧。不是说算法不重要，而是真正重要的算法都不难也不多。通用算法就那么几个，剩下的就比较的specific了，它们只解决在特定情况下的某一小类问题。</p></li><li><p>第五个，最后一个结论是关于<strong>心态</strong></p><p>这个竞赛和其他的竞赛一样，都比较考验智力。总会有那么一些人比你年纪小、能力强，天才层出不穷。不必太放在心上，因为他们本来就是用来仰望的，人还是要看着前面走路。在你看前面的时候，他们早已让别人无法望其项背了，不会太堵你的路的。如果喜欢，就继续做下去吧。不喜欢就尽早放弃，把时间让给真正有意义的事情。</p></li></ul><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>编程在未来应该是一个常用技能，就像现在的神经网络一样。无奈现在懂得人还是不多。很多情况下，人们还是需要一个比较高级的计算器的。在公司里叫做办公自动化（比如高效excel什么的），在科学研究中是建模的一部分（最流b的计算器之matlab）。编程不一定要参加竞赛，也不只是竞赛。我甚至会建议那些真正想要把编程作为一种爱好的人，真正想要做出一些属于自己的东西的人不要去参加竞赛。考试总是有着巨大限制的。</p><p>在暑假里我参加了一个学校里大佬搞得计算机普及项目，也去讲了一节课。我还是真心希望更多的人能够喜欢编程，也很欢迎和竞赛题无关的算法和技术讨论。</p><p>至于怎么入门和继续学习，我觉得从实践先做起，成就感和热情很重要。然后再去研究一些基本的算法和原理，最后就朝着目标前进吧。</p><blockquote><p>江苏省扬州中学OI退役    2017级    李茂良    于    2018年8月3日晚22时48分</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>人生导师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代操作系统 导读</title>
    <link href="/2018/06/01/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AF%BB/"/>
    <url>/2018/06/01/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Modern-Operating-Systems-导读"><a href="#Modern-Operating-Systems-导读" class="headerlink" title="Modern Operating Systems 导读"></a><em>Modern Operating Systems</em> 导读</h1><h3 id="太懒了不想写小标题"><a href="#太懒了不想写小标题" class="headerlink" title="太懒了不想写小标题"></a>太懒了不想写小标题</h3><p>之所以会写这一篇导读，主要是由于自己准备看一看 <em>Windows Internels</em> 这本书，里面据说讲了不少黑科技，比如说Windows10系统基本上是跑在一个虚拟机上什么的，于是乎就准备先补一补操作系统基本理论，翻出了尘封一整个学期的《现代操作系统》这个砖头，开始认真看，并且计划做一些批注，以表示自己曾经读过这本书（自从被强迫做红楼梦的批注之后，就忍不住读书做批注了，啊啊啊啊）。现在的阅读进度大概是前4章结束，之后大概会跳过不少内容，可能会看第5章，略读第8章，再认真看看第11章，基本上就可以结束本次阅读了。说实在的还是想去把本书的第四版略读一下，因为似乎它有讲到云和windows8还有iOS和Android这种比较现代的东西，对我的阅读还是有不少好处的。</p><h3 id="大概说说这本书讲了什么"><a href="#大概说说这本书讲了什么" class="headerlink" title="大概说说这本书讲了什么"></a>大概说说这本书讲了什么</h3><p>这本书正如它的标题所说，是一本关于操作系统理论的书，讲得比较的学院派，不过我本来就是要看一些比较理论的东西，毕竟工程里的实现千千万。所以关于OS的东西基本上都讲到了，除了具体实现，比如说历史，设计类型，基本的概念，进程线程，内存管理，文件磁盘，输入输出，甚至还有系统安全和实例分析。有点笼统吧，这是我的基本感觉，不过这个似乎也具体不起来，要不然就要够一架子书了。</p><h3 id="阅读的知识准备"><a href="#阅读的知识准备" class="headerlink" title="阅读的知识准备"></a>阅读的知识准备</h3><p>哈哈，终于到了我可以嘲讽他人的地方了，毕竟作为一个OI菜鸡，天天被大佬嘲讽。<br>首先是半精通c语言，（c++什么的去死吧，世界上最垃圾的语言），因为几乎所有的OS都是用C写的，指针的概念对于理解十分重要。<br>其次是对OS的基本理解，最好Windows和*nix都体验过。最好还懂一点多线程和汇编，读到相关章节的时候就会异常亲切，然后跳过去。<br>其实汇编和本书的第3章结合起来读更加有助于理解。对于程序编译、链接和执行的相关机理也可以实现了解一下。<br>建议在自己野心勃勃地去写一个dos之前，先读一读这种理论书，不建议边学边做或者是去看代码什么的。另外，书里还有一点点的数学内容和一部分硬件相关，不过问题不是很大。最后就是把算法学学好，什么链表，图论，树都是有涉及到的，不过书中新介绍的算法比这些简单多了，都是一些实用、稳定、平均较优的易于理解的算法。<strong>とにかく，Don’t Panic。</strong></p><h3 id="读些什么"><a href="#读些什么" class="headerlink" title="读些什么"></a>读些什么</h3><p>这是个比较重要的问题，因为这毕竟是这是这一篇主要想要说的东西。hhh。第一遍随便你怎么看，像我一般会来来回回把第一章看个四五回才会真正get determined来读这本书的。第二遍可以通读，比较事无巨细的全都看一遍。这之后就可以以此为基础做一些其他的阅读，或者实践一下，再加深理解之后，可以挑一些来研究研究。里面的基本概念需要比较好的理解和掌握，至于一些算法，就我暂时看下来，只需要知道它们的各自的用途和优缺点就差不多了，不需要具体掌握细节内容。最好一边读一边查一查不知道的内容，可以扩展知识量，还有always留一份英文版，电子的就好，因为会出现垃圾翻译的情况。</p><h3 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h3><ul><li>c语言：Primer系列</li><li>汇编：《汇编语言》</li><li>操作系统：《操作系统设计与实现》（也是本书作者写的）<br>  Linux内核设计相关内容  </li><li>其他：编码 | 程序员的基本素养：编译、链接</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows API Set 2</title>
    <link href="/2018/06/01/Windows-API-Set-2/"/>
    <url>/2018/06/01/Windows-API-Set-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DWM-Desktop-Window-Manager"><a href="#DWM-Desktop-Window-Manager" class="headerlink" title="DWM(Desktop Window Manager)"></a>DWM(Desktop Window Manager)</h1><p>本来打算两天更一次的，不过以后估计都要周更或者半月更了。。。高一也不容易啊。。。还要忙oi  </p><h3 id="首先来说一说什么是DWM"><a href="#首先来说一说什么是DWM" class="headerlink" title="首先来说一说什么是DWM"></a>首先来说一说什么是DWM</h3><blockquote><p>The desktop composition feature, introduced in Windows Vista, fundamentally changed the way applications display pixels on the screen. When desktop composition is enabled, individual windows no longer draw directly to the screen or primary display device as they did in previous versions of Windows. Instead, their drawing is redirected to off-screen surfaces in video memory, which are then rendered into a desktop image and presented on the display.<br>Windows Vista中引入的桌面组合功能从根本上改变了应用程序在屏幕上显示像素的方式。启用桌面组合后，各个窗口不再像以前版本的Windows中那样直接绘制到屏幕或主显示设备上。相反，他们的绘图被重定向到视频内存中的离屏表面，然后渲染成桌面图像并显示在显示器上。</p></blockquote><blockquote><p>Desktop composition is performed by the Desktop Window Manager (DWM). Through desktop composition, DWM enables visual effects on the desktop as well as various features such as glass window frames, 3-D window transition animations, Windows Flip and Windows Flip3D, and high resolution support.<br>桌面组合由桌面窗口管理器（DWM）执行。通过桌面组合，DWM支持桌面上的视觉效果以及各种功能，如玻璃窗框，3D窗口过渡动画，Windows Flip和Windows Flip3D以及高分辨率支持。</p></blockquote><blockquote><p>The Desktop Window Manager runs as a Windows service. It can be enabled and disabled through the Administrative Tools Control Panel item, under Services, as Desktop Window Manager Session Manager.<br>桌面窗口管理器作为Windows服务运行。可以通过“服务”下的“管理工具”控制面板中的“桌面窗口管理器会话管理器”来启用和禁用它。</p></blockquote><p>以上先引用msdn里的一段描述。不管你看得懂还是看不懂，总而言之就是在原来的直接桌面窗口绘制上面加了一层，让窗口的外观和切换变得更加的“炫酷”（虽然我一点都不这么觉得）。比如说毛玻璃效果和win7的3D窗口切换就是通过这个东西来实现的。不过在Win10里面，这个东西的存在感似乎变低了。估计是M$爸爸又在打什么主意了吧。</p><h3 id="然后我们来说一些正事"><a href="#然后我们来说一些正事" class="headerlink" title="然后我们来说一些正事"></a>然后我们来说一些正事</h3><p>待续</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows API Set 1</title>
    <link href="/2018/06/01/Windows-API-Set-1/"/>
    <url>/2018/06/01/Windows-API-Set-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-Accessibility"><a href="#Windows-Accessibility" class="headerlink" title="Windows Accessibility"></a>Windows Accessibility</h1><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>这个里面的函数似乎都用处不大，但是为了这个系列的完整性，姑且还是把他们记下来吧。<del>从名字就可以看出来，这个里面的函数主要是Windows辅助功能之类的玩意儿，用来帮助残疾人使用Windows。。。</del>//大雾</p><h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h3><p>能用的就3个</p><ul><li>RegisterPointerInputTarget (&gt;= Windows 8)</li><li>SoundSentryProc</li><li>UnregisterPointerInputTarget (&gt;= Windows 8)</li></ul><h4 id="RegisterPointerInputTarget-amp-amp-UnregisterPointerInputTarget"><a href="#RegisterPointerInputTarget-amp-amp-UnregisterPointerInputTarget" class="headerlink" title="RegisterPointerInputTarget &amp;&amp; UnregisterPointerInputTarget"></a>RegisterPointerInputTarget &amp;&amp; UnregisterPointerInputTarget</h4><p>这两个函数好像主要是用来控制触屏和鼠标输入的函数，基本用不到系列。。。<br>** 函数原型**</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">BOOL WINAPI <span class="hljs-title">RegisterPointerInputTarget</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  _In_ HWND                hwnd,</span></span><span class="hljs-function"><span class="hljs-params">  _In_ POINTER_INPUT_TYPE  pointerType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">BOOL WINAPI <span class="hljs-title">UnregisterPointerInputTarget</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  _In_ HWND                hwnd,</span></span><span class="hljs-function"><span class="hljs-params">  _In_ POINTER_INPUT_TYPE  pointerType</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><p>这两个函数可以把<strong>所有的</strong>鼠标指针类型的输入定向到注册的程序。一次只能有一个窗口注册此函数。</p><h4 id="SoundSentryProc"><a href="#SoundSentryProc" class="headerlink" title="SoundSentryProc"></a>SoundSentryProc</h4><p>更加没有用的函数，可以在计算机内置扬声器发出声音是在屏幕上进行显示。/笑<br><strong>函数原型</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">SoundSentryProc</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">   DWORD dwMillisec,</span></span><span class="hljs-function"><span class="hljs-params">   DWORD fdwEffect</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;</code></pre></div><p>在这个函数下面涉及到一个叫做<code>SystemParametersInfo</code>的函数，这个函数的功能<del>diaobao</del>非常的强大，过几天再说。</p><h3 id="相关知识整理"><a href="#相关知识整理" class="headerlink" title="相关知识整理"></a>相关知识整理</h3><ul><li><p>首先是hWnd这个神奇的玩意儿。这个名字是有h（handle）和Wnd（window）组合而成的。所以它指的是一个窗口句柄。在宏展开之后是</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nameHWND__</span> &#123;</span><span class="hljs-keyword">int</span> unused;&#125;; <span class="hljs-keyword">typedef</span> sturct nameHWND__ * HWND;</code></pre></div><p>所以这家伙是一个指向结构体的指针，这个结构体包含一个成员变量unused。至于句柄这个东西，过天专门写一篇来整理一下。</p></li><li><p>其次，就没有了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Welcome</title>
    <link href="/2018/02/21/Welcome/"/>
    <url>/2018/02/21/Welcome/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h1><p>在下，高中学生，OI退役，主要兴趣方向为操作系统和编译原理</p><p>I, a senior high student, who once took part in OI, whose interet is about Operating Systems and Compliers</p>]]></content>
    
    
    
    <tags>
      
      <tag>简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
