[{"content":" ","date":"2019-01-11T00:00:00Z","permalink":"https://ridethepig.github.io/blog/%E6%9C%9F%E6%9C%AB%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/","title":"幸运加成"},{"content":"NOIP 退役回顾 回首 初二起4年OI, 占据了我编程岁月的相当一部分时光. 现在想起来, 其实有点后悔. 人们都说青春无悔, 然而青春实际上是充满着悔恨和嗟叹的. 从想要开发游戏, 到被带进竞赛的坑, 其实莫名奇妙, 我自己并不知道这一系列的选择代表了什么, 现在看了, 它们代表着失败和悔恨. 如果可以重新来过, 我选择享受每一天的阳光, 享受计算机科学和算法本身的优美, 没有智障的题面, 没有毒瘤的数据, 也没有时间限制, 排名先后, 分数和自招.\n当然, 在无聊的竞赛之余, 我还学习了Python \u0026amp; C#语言, 操作系统 \u0026amp; 编译原理, 也学会了很多计算机相关的专业知识, 它们给我带来了无尽的乐趣, 让我认识到计算机科学世界的广博, 支撑着我度过竞赛岁月. 希望后来者们不要局限于竞赛, 除了竞赛, 要记得计算机还有很多更加有趣和有用的方面.\n我很感谢那些从初一起就陪伴我的同学们, 无论是中途退出, 还是早早退役, 感谢你们陪我打RA3, 陪我在冬令营课上刷知乎, 陪我刷题, 向我讲解题目. 值得庆幸的是, 这一切并不依赖于竞赛的载体, 我们拥有竞赛之外的更多的东西: 游戏, 番剧, 食物, 搞笑\u0026hellip;\u0026hellip;这或许是竞赛生活中为数不多了乐趣了. 也是竞赛留给我的唯一收获. 竞赛败坏了我的编程习惯, 带偏了我的思维, 浪费了我的青春, 这是人生之痛, 但苦难同时也是救赎.\n这里特别的感谢FSR大人, 以及您所讲过的算法, 题目, 以及有趣的番剧和精彩的RA3对决. 希望以后仍然有机会一起讨论这些, 虽然不是很想提及竞赛. 祝您早日金牌.\n至于老师, 感谢本校的总教练laoni, 感谢您的关心和培养, 虽然没有能够取得好成绩, 辜负期望了. 同时也感谢隔壁jdzx的chenzhong老师, 感谢初中时候指导我学习了中级算法, 并且耐心地解决我的问题. 是您使得我可以较为轻松地进阶提高组的比赛.\n同时也隔空感谢一下前些日子在czyz集训时的同学们. 你们应该已经取得好成绩了吧. 另外还有隔壁的tjh巨佬, 同届的OI选手, 也算是相互勉励(%)了吧.\n当下 此时也没有什么太多的感触了, 只是觉得比较的轻松, 可以睡一个好觉了. 虽然成绩还不清楚, 虽然明天还有期中考试, 但是不管怎样, 都已经结束了. 此时突然想要找个人聊一聊. 不过各位可能都在复习期中 / 到处浪吧\u0026hellip;\n未来 正如昨天写到的, 我对于这样的竞赛已经感到十分失望了. 并不想要多说什么, 只是以后不会再有以后了. CCF(China Collecting money Foundation)再也收不到我的血汗钱了. ACM-ICPC除非在弱校, 否则不会去参加了. 就连大学选择计算机专业的可能性也将为一成了. 希望这次做得能够决绝一点, 不要像高一差5分退役的时候怀抱幻想了. 青春没有重来, 人生充满后悔. 然而我们还是希望下次能够做得更好, 总是在绝望中, 骗自己去怀抱希望.\n至于以后, 直到高三毕业, 都会用周末和假期的闲暇时间, 用心打磨一个项目, 或许是一个实用工具, 也或许是一个大型后端工程. 以前都太浮躁了, 没有能够把一个项目做好, 这次希望可以. 指导感兴趣的同学也是可以的, 只不过不会忽悠他们去学竞赛了.\n以后我的博客里应该还会再出现一篇NOIP相关的文章, 不过那得等到出成绩之后了.\n以后不能每天碰到电脑了, 可能会一周甚至两周一更吧. 主要内容主要会是学校生活, 项目开发经历以及技术原理解析和科技新闻一类的东西, 虽然我也不觉得会有人能够看到它们.\n结束 就这么结束了呢. 怀着悔恨, 不甘, 无助的心情, 去面对永无黎明的黑暗. \u0026ldquo;信竟没有明天\u0026rdquo;, 用RA3苏联第6关的话来说, 大概是这样的感觉吧.\n就这么结束吧. さようなら。\nPrisrak · Smalin (Maoliang_Li)\n","date":"2018-11-11T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E6%AD%A3%E5%BC%8F%E9%80%80%E5%BD%B9%E5%AE%A3%E8%A8%80/","title":"NOIP 退役回顾"},{"content":"NOIP 考试记 -3 今天早上又去学校打了一场模拟赛, 感觉比较郁闷. 最近心态似乎还是比较爆炸, 又爆零了. T1因为评测机辣鸡导致暴力居然T掉了, 本机可以过3个点. T2居然把MST的并查集写错了. T3因为比赛环境比较的毒瘤, 就没有写暴力就交了. 总共浪掉了110. 毒瘤至极, 我自己也不想说什么.\n几个要注意一下的:\n写组合数不要暴力写, 记得打一下组合数的表, 顺便还少了一个log的逆元 看清题目, 不要太想当然. 估计也还是因为不够重视吧. 今天的炸零. 也只能这么安慰一下自己了. 其实还是暴露出来更多的一些问题, 比如如何保证暴力能拿分, 确保拿到分. 去年的时候由于各种码力加成, 就不用担心什么暴力写不出来之类的问题. 今年水平稍微提高了, 暴力水平反而下降了, 各种手滑出大锅. 再有就是如何能够比较全面的考虑一个问题, 有几题以为想到正解, 然后直接炸零.\n估计这几天本来想写的20道题就写不完了, 事到如今也只能相信自己了. 还剩两天, 估计就只能把NOIP几天暴力和模拟的原题写一写了. 然后再复习一下基本算法, 剩下时间就全部交给DP了, 毕竟连续几年都是一天一条DP, 把人气死, 尤其是我这种DP巨弱的选手.\n-2 虽然今天早上打算认真听课, 但是还是忍不住上完了主课去看了一眼. 今天的题其实还是比较平和的. T1可以暴力卡常40pt. 然而正解是除法分块优化除法求和来暴力枚举. 有两个初三的jl立马就想到了, 我今天晚上才理解这个东西, 感觉真的是要入土了. T2的话, 15min出正解, 没写, 估计写了会挂掉. T3是个原题, 毒瘤树形dp, 不多说什么, 也不是不可做就是了. 反正感觉因该第一天不去才对的说. 2333\n几个要注意一下的:\n看到带取模的数学题, 记得把 $$ a \\bmod p $$ 变成 $$ a - \\lfloor\\frac{a}{p}\\rfloor * p $$\n除法分块??\n今天算是稍微回复了一点码力, 不过还是非常的眼瞎, 各种打错. 明天打算再做两道NOIP原题, 其他的不管了, 看看骗分导论, 学一波模拟退火, 就去GG退役了. 今天也好颓废啊, 甚至想要NOIP前夜放君の名来着2333.(不知道有没有人跟我一起看) 今天莫名其妙心态不错\n-1 哇, 明天就去南京了, 心情有点小复杂, 感觉这一年又白活了. 今天主要是打板子和学习玄学算法, 还有好多的板子没有去打, 话说如果不是NOIP就不知道自己其实还有好多东西没有去学. (所以又浪了一年) 更多的话, 就留到明天晚上再说吧.\n0 Day0结束了. 最后一天的佛脚真的是抱的可以, 一天打了十几个板子, 外加十个DP板子, 简直就跟TMD什么都没有学过一样. 除了感觉自己白学一年, 就没有什么别的感触了. 现在其实一会感觉很慌, 一会又感觉稳的不行. 反正, 就这样吧, 希望这种东西, 本事无所谓有, 也无所谓无的. 现在最重要的似乎是睡一觉以及保证自己的肚子不要出锅. 赶紧睡了, 没有竞赛的黎明正在等待着我.\n1 今天居然出现了3条原题??? (我不想和你说什么, 因为我只是一只CCF) 导致已知上百号人当场AK, 无数人250+. 没有骗满分的我留下了蒟蒻的泪水. T1居然还是抄的以前的NOIP??? 然而我考场上并没有想到怎么写, 于是胡诌了一个递归分治, 大样例和自己的毒瘤数据都过了, 应该没有什么大问题. 有人说会被卡掉, 不过不管了. 期望得分: 70 - 100. T2不知道是个什么, 一眼看出背包可做, 然后就写了个80分做法. 满分做法没有调对. 期望得分: 80. T3是个二分答案+树形dp, 然而考场上不会写check函数, 就立马凉凉. 写了35分部分分, 另外的20部分分没有调出来. 所以今天的期望得分再185 - 215之间.不算太差, 但绝对算不上是满意, 已经凉透了. 我彻底对CCF和信息学奥赛失望了, 连最基本的出题态度都已经丧失的竞赛还有什么希望吗? 虽然大佬们可能AK得非常开心, 但是对于中等水平的选手绝对不是什么开心的事情, 辛辛苦苦来参加复赛, 做到的却是陈旧的题目, 更可悲的是我竟然不知道T2T3是原题. 不想复习了. 已经提前退役了, 我已经把Luogu上的签名改成了退役选手, 也公开了所有代码. 再见了, NOIP. 虽然明天还是会去强撑着把它考完.\n2 这还行\n暴力 GG 滚粗 退役\n然后去搬砖, 享受奋斗的社会主义人生\n之前看到了去年NOIP小学奥数那张毒瘤图, 突发奇想地打算在NOIP之前看一波\u0026lt;你的名字\u0026gt;, 于是乎今天下午, 在确认直接提前一天退役以后, 跟同学一起看了这个前年的番. 总体感觉是: woc, 这居然是一个大制作. 本来以为这还是类似于言叶之庭的作画, 没想到居然画面如此之精良.\n看的时候是一边吐槽一边看的, 外加旁边还有两个放鬼畜加打游戏的, 所以观感不是很好, 但觉得如果在电影院看的话, 效果应该是很好的. 尤其是画的彗星的场面, 非常的漂亮.\n情节本身不多说, 写得很好, 虽然一开始看得有一点懵逼, 毕竟是时空交错的剧情, 导致到后来就不知道是谁在说话了, 最后似乎是新海诚第一次发糖, 虽然不是特别甜\u0026hellip; 比较可惜的是没有能够一个人享受剧情, 作为一个剧情导向的死宅, 我更加觉得有点浪费. 导致看完内心毫无波澜\u0026hellip; 本来是非常凄美的爱情故事, 然而在看完一大波鬼畜和吐槽之后, 就完全无感了, 比较难受.\n音乐无论是作曲还是配制, 都非常的到位, 之前在听歌的时候就能感觉到场面的宏大开阔, 当bgm响起的时候实在是激动万分. (洋次郎自然是没话说的呀) 后来本着尊重演职人员的态度, 顺手看了一眼CV, woc, 简直是太强了: 信长, 上百石萌音, 连香菜都来客串了\u0026hellip;\u0026hellip;\n可惜并没有什么可爱的妹子一起看的说\u0026hellip;\n至于看完了有什么想法的话, 可能没有. 估计是因为老了, 这样的番看多了, 也就不觉得有什么触动, 所以也越来越难被感动. 现在已经害怕看恋爱番了\u0026hellip;一个是怕出现那样的情况, 还有一个是自己会觉得有一丝忧伤\u0026hellip;当别人成为人生赢家的时候, 然而我还在写着毫无算法可言的代码, 看着鬼畜的时候, 偶尔也会觉得人生的灰暗吧. 当然还有旁边坐着一个老司机的忧伤.\n话说日本的传统文化可以玩好多东西, 然而不知道为什么中国那些古董就一点也不文艺呢, 而是有一种木头的感觉.\n希望明天RP++. (话说我今天考场上跟就跟看这个番的时候一样懵逼) 同时也祝和我分享此番的同志zjy RP++\n一边听着过气的歌一边写下的无聊感言\n","date":"2018-11-10T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip-%E8%80%83%E8%AF%95%E8%AE%B0/","title":"NOIP 考试记"},{"content":"NOIP退役整理 2 图论 看完保证你, 退役!\n继续没有任何证明的笔记\n[TOC]\n0. 基础的算法 -1. 链式前向星 最最最最重要的存图方法.\nint head[maxn], cnt = 1; struct Edge { int next, to, w; } edge[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } for (int i = head[u]; i; i = edge[i].next) { int v = edge[cnt].to; //... } 0. 百分数(BFS)和电风扇(DFS) 这个我不想说什么. 不过什么DFS的手工栈估计也是不会考,我虽然会写但是只用过一次还炸了\n1.拓扑排序 拓扑序是一个比较重要的顺序,可以用来做各种事情,比如在图上递推, 或者直接解题什么的.\n主要就是在DAG上分析依赖关系. 还可以判环.主要思想就是:每次找入度为0的节点,找到后删除该节点和该节点的出度边.\n// deg[]是入度. vis[]呵呵. 以下默认使用链星. (生成树除外) void Topo(int u) { vis[u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; deg[v] --; if (!deg[v]) Topo(v); } } //main for (register int i = 1; i \u0026lt;= n; ++ i) { if (!vis[i] \u0026amp;\u0026amp; !deg[i]) Topo(i); } 可以在这个主要模板上做各种操作. 判环的话, 记一个color标记(比如:记正在访问为-1, 已经访问为1, 没有访问为0), 如果祖先节点没有返回但是子孙节点又访问到了它, 于是就有环了.\n其实还有BFS的写法.估计不考, 就不管了.随便找了一个板子\n1.最短路 1. Dijkstra 先膜一波: %%%Dijkstra%%%\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; using std::priority_queue; const int maxn = 1e5 + 10; const int inf = 0x7fffffff; inline int read() { int x = 0, f = 1; char c; while((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct T_Edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; inline void AddEdge(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } struct T_Node { int i, d; T_Node(int a, int b): i(a), d(b) { } inline friend bool operator \u0026lt; (T_Node a, T_Node b) { return a.d \u0026gt; b.d; } }; priority_queue\u0026lt;T_Node\u0026gt; pq; int n, m, s; int dis[maxn + 10], vis[maxn + 10]; int main() { n = read(); m = read(); s = read(); register int ui, vi, wi; for (register int i = 1; i \u0026lt;= m; ++ i){ ui = read(); vi = read(); wi = read(); AddEdge(ui, vi, wi); } for (int i = 1; i \u0026lt;= n; ++ i) { dis[i] = inf; } T_Node now(s, 0); now.i = s; now.d = dis[s] = 0; pq.push(now); while (!pq.empty()) { now = pq.top(); pq.pop(); int u = now.i; if(vis[u]) continue; vis[u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (!vis[v] \u0026amp;\u0026amp; dis[v] \u0026gt; dis[u] + edge[i].w) { dis[v] = dis[u] + edge[i].w; pq.push(T_Node(v, dis[v])); } } } for (register int i = 1; i \u0026lt;= n; ++ i){ printf(\u0026#34;%d \u0026#34;, dis[i]); } return 0; } 这个的复杂度是严格O(nlog(n))的.(其实跑n遍dj比一遍floyd要快(不考虑常数) // 笑)\n2. SPFA #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; inline int read() { /*...*/} int head[maxn], cnt = 1; struct Edge{ int next, to, w; } edge[maxn]; inline void add_edge (int u, int v, int w) {/*...*/} int vis[maxn], dis[maxn]; inline void spfa(int s) { int q[maxn]; memset(q, 0, sizeof(q)); memset(dis, 0x3f, sizeof(dis)); int l = 1, r = 1; q[l] = s, dis[s] = 0; while (l \u0026lt;= r) { int u = q[l ++]; vis[u] = [0]; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (dis[v] \u0026gt; dis[u] + edge[i].w) { dis[v] = dis[u] + edge[i].w; if (!vis[v]) vis[v] = 1, q[++r] = v; } } } } //main 这个写起来比较方便, 虽然有可能会被卡掉.\n3. Floyd 这个的主要思想是DP. 所以也是可以在上面加个一位瞎搞的. 复杂度很高, O(n^3)\n状态转移方程 $$ D[k,i,j] 表示经过几个编号不超过k的节点,从i到j的最短路.我们把这个k作为一个中转点一样的东西 \\\\ 显然, D[k, i, j] = min(D[k-1, i, j], D[k-1, i, k] + D[k-1, k, j]) \\\\ 再显然,k这一维可以被推掉 \\\\ 就变成了: D[i, j] = min(D[i, j], D[i,k] + D[k,j]) $$\n//init memset(d, 0x3f, sizeof(d)); for (register int i = 1; i \u0026lt;= n; ++ i) d[i][i] = 0; //自己到自己 // read in... for (register int k = 1; k \u0026lt;= n; ++ k) { for (register int i = 1; i \u0026lt;= n; ++ i) { for (register int j = 1; j \u0026lt;= n; ++ j) { d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]); } } } 这个玩意儿似乎可以用来求最小环, 最后再写吧\n然而更加牛逼的是, 这个玩意儿的求解过程比较类似于矩阵乘法, 有些看似不可做的题目可以用类似于这样的矩阵快速幂跑.\n4. 相关题目 Luogu P1144 最短路计数. 在跑Dj/ Spfa的时候随便统计一下 Luogu P2384 把加法换成了乘法, 保证你退役2333. 其实打个log就好了 Luogu P1613 在Floyd上加一维乱搞 5. 我是不是应该皮一把k短路 A*可做. 复杂度上界O(nklog(nk)\n我不会写红红火火恍恍惚惚\n2.生成树 1. Kruskal #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e5 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int fa[maxn]; int findfa(int x) { return fa[x] == x ? fa[x] : fa[x] = findfa(fa[x]); } struct Edge{ int from, to, w; inline friend bool operator \u0026lt; (Edge a, Edge b) { return a.w \u0026lt; b.w; } } edge[maxn]; int main() { int n = read(); int m = read(); for (int i = 1; i \u0026lt;= m; ++ i) edge[i].from = read(), edge[i].to = read(), edge[i].w = read(); std::sort(edge + 1, edge + m + 1); int cnt = 0, ans = 0; for (int i = 1; i \u0026lt;= n; ++ i) fa[i] = i; for (int i = 1; i \u0026lt;= m; ++ i) { int fau; if ((fau = findfa(edge[i].from)) != findfa(edge[i].to)){ fa[edge[i].to] = fau; ans += edge[i].w; cnt ++; } } if (cnt \u0026lt; n-1) printf(\u0026#34;fuck\u0026#34;); //如果边数不对就说明生成失败了 else printf(\u0026#34;%d\u0026#34;,ans); } 2. Prim 不讲 这个基本用不到. 只有在稠密图上才会优于KS.\n3. 变种生成树 最大生成树就把排序的顺序改一下就好了.\n次大/小生成树有点难写.\n先求最小生成树T,枚举添加不在T中的边,则添加后一定会形成环,找到环上边值第二大的边,把它删掉,计算当前生成树的权值,取所有枚举修改的生成树的最小值,即为次小生成树.这种方法的实现更为简单,首先求最小生成树T,然后从每个结点u,遍历最小生成树T,用一个二维的数组max[u][v]记录结点u到结点v的路径上边的最大值,然后枚举不在T中的边(u,v),计算T-max[u][v]+w(u,v)的最小值,即为次小生成树的权值 ,这种方法的时间复杂度为O(n^2+e).\n因为没什么题,就不多说了.\n考生成树的时候,一般是Day2T1的难度.基本上不会有什么特别的地方,一旦看出来能敲对就可以了.题目都比较弱智,不贴了\n3.Tarjan 先膜一波为敬: %%%Tarjan%%%\n1. 强连通分量 概念就不说了. 主要用来缩点,缩完以后就把一个有环图变成DAG,就可以随便瞎搞了.\n求这个玩意儿,其实有另外一个奇葩的跑两边的算法.(在接受FanDalao的指导之前,我一直写的是那个k打头的算法).\n先上板子\nint low[maxn], dfn[maxn], stk[maxn], instk[maxn], tim, top, scc[maxn], num; // scc[u]代表u属于的强连通分量的编号 // low[u]代表u能到达的最小的dfn,似乎也就是最老的祖先 // dfn代表的似乎是dfs序列 void Tarjan(int u) { dfn[u] = low[u] = ++tim; instk[stk[++top] = u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (!dfn[v]) { Tarjan(v); low[u] = std::min(low[u], low[v]); } else if (instk[v]) { low[u] = std::min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { //完了,又回到自己了 num ++; while(1) { int v = stk[top --]; instk[v] = 0, scc[v] = num; if (v == u) break; } } } 还是有一些有趣的题目的.不过感觉都比较趋同,缩点-\u0026gt;搞一搞连通性,最短路,出度入度-\u0026gt;没了\n2. 割点和桥 概念不说.\n割点\ninline void dfs(int u,int root) { int sz = 0; dfn[u] = low[u] = ++cnt; for (register int i = head[u];i;i = edge[i].next) { int v = edge[i].to; if (dfn[v]) low[u] = min(low[u],dfn[v]); else { sz ++; dfs(v,root); if (low[v] \u0026gt;= dfn[u]) iscut[u] = true; low[u] = min(low[u],low[v]); } } if (u == root \u0026amp;\u0026amp; sz \u0026lt; 2) iscut[u] = false; } // may be more beautiful void point(int u, int rt) { int sz = 0; dfn[u] = low[u] = ++tim; for (register int i = head[u]; i; i = edge[i].next ) { int \u0026amp;v = edge[i].to; if (!dfn[v]) { sz ++; point(v, rt); if (low[v] \u0026gt;= dfn[u]) iscut[u] = 1; low[u] = std::min(low[u], low[v]); } else { low[u] = std::min(low[u], dfn[v]); }\t} if (u == rt \u0026amp;\u0026amp; sz \u0026lt; 2) iscut[u] = 0; } 桥 //正确性不明\nvoid bridge(int u, int fa) { low[u] = dfn[u] = ++tim; for (register int i = head[u]; i; i = edge[i].next){ int \u0026amp;v = edge[i].to; if (!dfn[v]) { bridge(v, u); low[u] = std::min(low[u], low[v]) ; if (low[v] \u0026gt; dfn[u]) { // \u0026#34;\u0026gt;\u0026#34; isbridge[u][v] = 1; } } else if (fa != v) { low[u] = std::min(low[u], dfn[v]); } } } 似乎没有什么题目。\n3. 双联通分量 \u0026ldquo;点双连通图的定义等价于任意两条边都同在一个简单环中,而边双连通图的定义等价于任意一条边至少在一个简单环中.\u0026ldquo;这个是从网上抄的.\u0026ldquo;不同双连通分量最多只有一个公共点,即某一个割顶,任意一个割顶都是至少两个点双连通的公共点.不同边双连通分量没有公共点,而桥不在任何一个边双连通分量中,点双连通分量一定是一个边双连通分量.\u0026rdquo;\n这个东西的求解跟上面的割点和桥差不多,虽然我没写过.(有一条HNOI2012)\n过天把代码补上\n4. LCA \u0026ldquo;对呀对呀..求LCA有六种方法,你知道吗?\u0026rdquo; \u0026ndash;fan乙己 %%%%%%\n1. 暴力 我表示不会写. 这个应该跟倍增差不多思想.就是对于两个点,轮流向上面跳,直到碰起来这个样子.\n2. ST表/RMQ 这个跟tarjan一样不是很常用.就不打了,省的浪费时间和记忆力\n3. 倍增 最最最常用而且很好写的lca.大家都在写它.(虽然很容易被卡掉,但是NOIP级别的还没有毒瘤到去卡这个)\n主要思想就是先预处理出每个点的深度,然后对于两个点的深度差倍增的向上跳,因为是倍增所以比一般的跳快一点.\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int next, to; } edge[maxn\u0026lt;\u0026lt;1]; inline void AddEdge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; } int deep[maxn], l[maxn][30]; void dfs(int u) { //预处理 for (register int i = 1; i \u0026lt;= 20; ++ i) { l[u][i] = l[l[u][i-1]][i-1]; } for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (v == l[u][0]) continue; // 什么,儿子变成父亲了233 l[v][0] = u; // v的父亲是u,就是从v向上跳2^0,即1步到达u deep[v] = deep[u] + 1; dfs(v); } } inline int getlca(int u, int v) { if (deep[u] \u0026lt; deep[v]) u ^= v ^= u ^= v;\tfor (register int i = 20; i \u0026gt;= 0; -- i) { if (deep[l[u][i]] \u0026gt;= deep[v]) { u = l[u][i]; } }//把u和v跳到同一高度 if (u == v) return u; //到了一个点上,说明这两个点具有祖先关系 for (register int i = 20; i \u0026gt;= 0; -- i) if (l[u][i] != l[v][i])//一起跳 u = l[u][i], v = l[v][i];\treturn l[u][0]; } int n,m,s; int main() { n = read(); m = read(); s = read(); int tmp1,tmp2; for (register int i = 1; i \u0026lt;= n-1;i ++) { tmp1 = read(); tmp2 = read(); AddEdge(tmp1,tmp2); AddEdge(tmp2,tmp1); } deep[s] = 1; dfs(s); for (register int i = 1;i \u0026lt;= m; i++) { tmp1 = read(); tmp2 = read(); printf(\u0026#34;%d\\n\u0026#34;,getlca(tmp1,tmp2)); } } 4. 树链剖分 树剖是前置技能.不说.\n主要思想是把u和v所在链的顶端跳到一起\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int next, to; } edge[maxn\u0026lt;\u0026lt;1]; inline void AddEdge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; } int sz[maxn], son[maxn], top[maxn], deep[maxn], fa[maxn]; void dfs1(int u) { sz[u] = 1, son[u] = 0; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (v == fa[u]) continue; fa[v] = u, deep[v] = deep[u] + 1; dfs1(v); if (!son[u] || sz[v] \u0026gt; sz[son[u]]) son[u] = v; sz[u] += sz[v]; } } //处理儿子 void dfs2(int u, int tp) { top[u] = tp; if (son[u]) dfs2(son[u], tp); for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (v != fa[u] \u0026amp;\u0026amp; v != son[u]) dfs2(v, v); } }//处理链顶 inline int getlca(int u, int v) { while (top[u] != top[v]) { if (deep[top[u]] \u0026lt; deep[top[v]]) u ^= v ^= u ^= v; u = fa[top[u]]; } if (deep[u] \u0026gt; deep[v]) u ^= v ^= u ^= v; return u; } int main() { int n = read(), m = read(), s = read(); for (register int i = 1; i \u0026lt; n; ++ i) { int u = read(), v = read(); AddEdge(u, v); AddEdge(v, u); } dfs1(s); dfs2(s, s); for (register int i = 1; i \u0026lt;= m; ++ i) { int ui = read(), vi = read(); printf(\u0026#34;%d\\n\u0026#34;, getlca(ui, vi)); } return 0; } 5. 离线Tarjan 不是很常用.贴一个久远的板子.\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; const int maxn = 3e6+50; int n,m,s,cnt1 = 1, cnt2 = 1; int head1[maxn], head2[maxn], ans[maxn], fa[maxn]; bool vis[maxn]; struct t_edge{ int next, to; }edge[maxn]; struct t_query{ int next, to, num, vis; }query[maxn]; inline void AddEdge(int,int); inline void AddQuery(int,int,int); inline int read(); int father(int); inline void combine(int,int); void dfs(int); int main() { //freopen(\u0026#34;testdata.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); n = read(), m = read(), s = read(); //scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s); int ui,vi; for (int i = 1; i \u0026lt;= n-1; ++i) { int ui = read(),vi = read(); //scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;ui,\u0026amp;vi); AddEdge(ui,vi); AddEdge(vi,ui); } for (int i = 1; i \u0026lt;= m; ++i) { int ui = read(),vi = read(); //scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;ui,\u0026amp;vi); AddQuery(ui,vi,i);AddQuery(vi,ui,i); } //fclose(stdin); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; dfs(s); for (int i = 1;i \u0026lt;= m; ++i) printf(\u0026#34;%d\\n\u0026#34;,ans[i]); return 0; } inline void AddEdge(int u,int v) { edge[cnt1].next = head1[u]; edge[cnt1].to = v; head1[u] = cnt1 ++; } inline void AddQuery(int u,int v,int num) { query[cnt2].next = head2[u]; query[cnt2].to = v; query[cnt2].num = num; head2[u] = cnt2 ++; } inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + c - 48; return f ? x : -x; } int father(int x) { if (fa[x] != x) fa[x] = father(fa[x]); return fa[x]; } inline void combine(int x,int y) { fa[father(x)] = father(y); } void dfs(int u) { vis[u] = true; for (int i = head1[u]; i ; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (vis[v]) continue; dfs(v); combine(v,u); } for (int i = head2[u]; i ; i = query[i].next) { int \u0026amp;v = query[i].to; if (vis[v] \u0026amp;\u0026amp; !query[i].vis) { ans[query[i].num] = father(v); query[i].vis = true; } } } 6. 笛卡尔树 这个不会写, 巨难\n5. 二分图 1. 二分染色 这个算法似乎还是考过的,主要用来判断一个图是否是二分图,还可以顺带做一些操作.看到有某些互斥操作或者两边分的比较明显的就可以考虑二分图相关的东西.染色很简单,暴力遍历一边就结束了.\n题目:\nLuogu P1155. 其实也可以不用二分图.也比较不好想到是二分图 Luogu P1330. 这个比较明显. 蒟蒻表示自己基本只刷过luogu\u0026hellip;没有什么别的题库.tcl\n2. 二分图匹配 这个里面有许多奇奇怪怪的概念:\n定义：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。\n匹配点：匹配边上的两点\n极大匹配(Maximal Matching)：是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。\n最大匹配(maximum matching)：是所有极大匹配当中边数最大的一个匹配,设为M。选择这样的边数最大的子集称为图的最大匹配问题。\n完美匹配（完备匹配）：一个图中所有的顶点都是匹配点的匹配，即2|M| = |V|。完美匹配一定是最大匹配，但并非每个图都存在完美匹配。\n最优匹配：最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。（KM（Kuhn and Munkres）算法，是对匈牙利算法的一种贪心扩展。）\n最小覆盖 二分图的最小覆盖分为最小顶点覆盖和最小路径覆盖：\n①最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联\n注：二分图的最小顶点覆盖数=二分图的最大匹配数\n②最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。\n注：二分图的最小路径覆盖数=|V|-二分图的最大匹配数\n最大独立集:最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集=|V|-二分图的最大匹配数。最大独立集S 与 最小覆盖集T 互补\n这个当然是抄的\n1. 二分图最大匹配 就是找到最多的匹配个数. 经典模型为稳定婚姻问题.\n二分图匹配本质上是一个网络流问题,只要再左边一列的左边加一个源点,右边一列右边再加一个汇点,跑最大流就好了.但是对于二分图来说其实不必要这个样子,可以简单一点.\n接下来是板子. 其实代码并不是很难, 难在发现这是一个二分图,再把模型建起来.这一点在网络流里面也是一个巨大的问题.233\n算法为匈牙利算法.主要思想就是先随便匹配,遇到有重合的就考虑拆掉原来的,再给原来的重新配一个.知道再也配不到为止.(一个无比凶残的算法)\n// Luogu P3386 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int to, next; } edge[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt ++; } int pre[maxn], vis[maxn], tim, ans; int dfs(int u) { for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp; v = edge[i].to; if (vis[v] == tim) continue; //神奇的常数优化,不需要memset了 vis[v] = tim; if (!pre[v] || dfs(pre[v])) { // 自己未被匹配 || 可以腾出一个位置; 这个写得顺序也是一个常数优化 pre[v] = u; // 重新匹配成功 return 1; } } return 0; } int main() { int n = read(), m = read(), e = read(); for (register int i = 1; i \u0026lt;= e; ++ i) { int ui = read(), vi = read(); if (ui \u0026gt; n || vi \u0026gt; m) continue; add_edge(ui, vi); } for (register int i = 1; i \u0026lt;= n; ++ i) { tim ++; if (dfs(i)) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 2. 二分图最大带权匹配(最优匹配) 就是给每一个匹配加一个权值,然后求最大匹配,同时使权值最优.\n同样可以跑网络流. 不过主要使KM算法.这个东西可以用,但是似乎从来没有刻意去考过, 估计也暂时不将去考.\n鉴于我自己只是了解大概思想, 板子就没有了.\n6. 各种奇怪算法 1. 差分约束 有一大堆形如 $$ x{i} - x{j} \\leq c_{k} $$ 的不等式, 因为它们长得非常像SPFA / DJ中的三角形不等式, 于是乎可以用图论方法来求解这一堆东西的关系.\n如果出现小于, 就在后面-1就好了, (至于double请自求多福), 如果是大于等于之类的, 打个负号然后考场上现场瞎编就好了.\n如果存在负环, 表明不满足条件 (貌似很多题里面只要有环就不成立, 到时候随机应变就好了)\n如果跑出来是个inf, 就表明没有任何的限制.\ndis的结果就是每一条约束链的最小花费, (一组解?)\n下面是个板子\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 10001; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } struct t_edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; int head[maxn], cnt = 1; inline void add_e(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } int dis[maxn], vis[maxn], flg; int n, m; void spfa(int s) { if (flg) return; vis[s] = 1; for (register int i = head[s]; i; i = edge[i].next) { int v = edge[i].to; if (flg) return; if (dis[v] \u0026lt; dis[s] + edge[i].w) { dis[v] = dis[s] + edge[i].w; if (!vis[v]) spfa(v); else { flg = 1; return; } } } vis[s] = 0; } int main() { n = read(); m = read(); int op, ai, bi, ci; for (register int i = 1; i \u0026lt;= m; ++ i) { op = read(); ai = read(); bi = read(); switch(op) { case 1:{ ci = read(); add_e(bi, ai, ci); break; } case 2: { ci = read(); add_e(ai, bi, -ci); break; } case 3: { add_e(ai, bi, 0); add_e(bi, ai, 0); break; } } } for (register int i = 1; i \u0026lt;= n; ++ i) { spfa(i); if (flg) break; } printf(flg ? \u0026#34;No\\n\u0026#34; : \u0026#34;Yes\\n\u0026#34;); return 0; } 2. 负环 深搜或者SPFA都可以用来判负环\n至于正环, 随便写一写就好了\n上代码\n大法师:\n// luogu-judger-enable-o2 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 3001; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } struct t_edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; int head[maxn], cnt = 1; inline void add_e(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } int dis[maxn], vis[maxn], flg; int n, m; void spfa(int s) { if (flg) return; vis[s] = 1; for (register int i = head[s]; i; i = edge[i].next) { int v = edge[i].to; if (flg) return; if (dis[v] \u0026gt; dis[s] + edge[i].w) { dis[v] = dis[s] + edge[i].w; if (!vis[v]) spfa(v); else { flg = 1; return; } } } vis[s] = 0; } int main() { int t = read(); while (t --) { n = read(); m = read(); int ui, vi, wi; flg = 0; cnt = 1; memset(vis, 0, sizeof(vis)); memset(head, 0, sizeof(head)); memset(dis, 0, sizeof(dis)); for (register int i = 1; i \u0026lt;= m; ++ i) { ui = read(); vi = read(); wi = read(); if (wi \u0026lt; 0) add_e(ui, vi, wi);\telse { add_e(ui, vi, wi); add_e(vi, ui, wi); } } for (register int i = 1; i \u0026lt;= n; ++ i) { spfa(i); if (flg) break; } printf(flg ? \u0026#34;YE5\\n\u0026#34; : \u0026#34;N0\\n\u0026#34;); } return 0; } 百分数:\n#include\u0026lt;bits/stdc++.h\u0026gt; #define IL inline #define RI register int #define N 100086 #define clear(a) memset(a,0,sizeof a) #define rk for(RI i=1;i\u0026lt;=n;i++) using namespace std; IL void read(int \u0026amp;x) { int f=1;x=0;char s=getchar(); while(s\u0026gt;\u0026#39;9\u0026#39;||s\u0026lt;\u0026#39;0\u0026#39;){if(s==\u0026#39;-\u0026#39;)f=-1;s=getchar();} while(s\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;s\u0026gt;=\u0026#39;0\u0026#39;){x=x*10+s-\u0026#39;0\u0026#39;;s=getchar();} x*=f; } int n,m,T; struct code{int u,v,w;}edge[N]; bool vis[N]; int head[N],tot,dis[N],cnt[N]; IL void add(int x,int y,int z){edge[++tot].u=head[x];edge[tot].v=y;edge[tot].w=z;head[x]=tot;} IL bool spfa(int now) { rk vis[i]=false,dis[i]=2147483647,cnt[i]=false; queue\u0026lt;int\u0026gt;q; q.push(now); vis[now]=true; dis[now]=0; while(!q.empty()) { int u=q.front();q.pop();vis[u]=false; if(cnt[u]\u0026gt;=n)return true; for(RI i=head[u];i;i=edge[i].u) { if(dis[edge[i].v]\u0026gt;dis[u]+edge[i].w) { dis[edge[i].v]=dis[u]+edge[i].w; if(!vis[edge[i].v]) { q.push(edge[i].v); vis[edge[i].v]=true; cnt[edge[i].v]++; if(cnt[edge[i].v]\u0026gt;=n)return true; } } } } return false; } int main() { read(T); while(T--) { read(n),read(m); tot=0;clear(head); for(RI i=1,u,v,w;i\u0026lt;=m;i++) { read(u),read(v),read(w); if(w\u0026lt;0)add(u,v,w); else add(u,v,w),add(v,u,w); } puts(spfa(1)?\u0026#34;YE5\u0026#34;:\u0026#34;N0\u0026#34;); } } 3. 最小环 可以用Floyd来求, 似乎dj也可以做. 不过网上似乎只有Floyd的做法, 于是乎抄写一波.\n4. 反图 这个主要是用来解决不能到达终点的情况的. 很多时候正反跑一遍 或者直接反着跑就会奇迹再现\n5. 欧拉路 6. 哈密顿路 不管了\n7. 倍增 这个可以用来优化图上 / 树上的长度问题. 具体写得话, 随缘了.\n记得不要把数组开太小. 还有这个玩意儿有点耗空间. (不过这几年不卡空间就是了)\n7.一些奇特的东西 1.DFS序和DFS树 咕咕咕\u0026hellip;\n8. 一些奇葩题 POJ3613 看起来是图论题的矩阵快速幂 NOIP2013 华容道: 非常牛逼的一条图论建模 ","date":"2018-11-08T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/","title":"NOIP退役整理 2 图论"},{"content":"NOIP退役整理 3 数据结构 看完保证你, 退役!\n感觉NOIP的数据结构并不是很多的说\u0026hellip;233\n0. 并查集 1. 树状数组 随便贴一个区间加的\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #define re register int #define lowbit(x) (x \u0026amp; -x) const int maxn = 5e5 + 10; typedef long long lld; inline lld read() { lld x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } lld a[maxn], n, m; inline void Add(lld x, lld k) { for (; x \u0026lt;= n; x += lowbit(x)) a[x] += k; } inline lld get(lld x) { lld r = 0; for (; x; x -= lowbit(x)) r += a[x]; return r; } int main() { n = read(); m = read(); lld now, last = 0; for (re i = 1; i \u0026lt;= n; ++ i) { now = read(); Add(i, now - last); last = now; } for (re i = 1; i \u0026lt;= m; ++ i) { lld op = read(), x = read(); if (op == 1) { lld y = read(), k = read(); Add(x, k); Add(y + 1, -k);\t} else { printf(\u0026#34;%lld\\n\u0026#34;, get(x)); }\t} return 0;\t} 2. 线段树 随便写写就好\n3.ST表 主要用来解决RMQ(区间最值问题)的一种算法, 主要思想竟然是动态规划(区间动规)和倍增.支持O(nlog(n))预处理, O(1)查询, 而且常数非常小, 跑得跟记者一样快但是不支持修改,极大地限制了它的运用范围.\n方程: $$ f[i,j] = max(f[i,j-1], f[i + 2^{j-1}, j-1]) \\ 其中f[i,j]表示a[i]到a[2^j-1]区间内的最大值 $$ 求解的时候 $$ k = log_2(r - l + 1)\\ ans = max(f[l, k], f[r - 2^k + 1, k]) $$ 板子\n// 初始化部分 for (log[0] = -1, register int i = 1; i \u0026lt;= n; ++ i) log[i] = log[i \u0026gt;\u0026gt; 1] + 1; //递推log,在询问较多时可以卡卡常 for (register int i = 1; i \u0026lt;= n; ++ i) st[i][0] = dat[i]; //dp初始化 for (register int j = 1; j \u0026lt;= 22; ++ j) { for (register int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; ++ i) { st[i][j] = std::max(st[i][j-1], st[i+(1\u0026lt;\u0026lt;j-1)][j-1]); } } //查询 inline int query_max(const int \u0026amp; l, const int \u0026amp; r) { int k = log[r - l + 1]; return std::max(st[i][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); } 4. 平衡树大法!!! 这个不会用到的. 只是个人兴趣而已\n5. Trie 6. 平板电视(ext/pb_ds/*.hpp) 7. 差分 前缀和 这个玩意儿写得不错, 抄下来了.\n前缀和 1.一维前缀和 对于数组A[], 前缀和SUM[i]表示的就是A[1]+A[2]+…+A[i].\nint init() { for(int i = 1; i \u0026lt;= n; i++) sum[i] = sum[i-1] + a[i]; } int get(int l, int r) { return sum[r] - sum[l-1]; } 2.二维前缀和 对于二维数组, 前缀和SUM[i][k]表示的是所有A[i’][k’](1\u0026lt; = i’\u0026lt;=i,i \u0026lt;= k’\u0026lt;=k)的和.\nint init() { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j]; } } } int get(int x1, int y1, int x2, int y2) { return sum[x1][y1] - sum[x1][y2 - 1] - sum[x2 - 1][y1] + sum[x2 - 1][y2 - 1]; } 3.%k时的优化 （p - q）% k= 0 ==\u0026gt; p % k = q % k 统计q % k 和 p % k 相等的数 详细见T1\n差分 1.一维差分 我们对[L,R]区间进行加num操作，在C[L]处加上num，在C[R+1]处减去num\nvoid init(int l,int r,int num) { dis[l] += num, dis[r + 1] -= num; } int get() { for(int i = 1; i \u0026lt;= n; i++) { val[i] = val[i-1] + dis[i]; } } 2.二维差分 其实也挺简单，和二维前缀和一样\nvoid init(int x1, int y1, int x2, int y2, int num) { sumx1 += num; sumx1 -= num; sumx2 + 1 -= num; sumx2 + 1 += num; } void get() { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { sumi += sumi + sumi-1 - sumi-1; } } } 3.树上差分 (1)点差分 对 u 到 v 的路径上的点 +num 用来求 - 已知路径求树上所有节点被路径覆盖次数\nint init(int u, int v, int num) { dis[u] += num; dis[v] += num; dis[lca(u,v)] -= num; dis[f[lca(u,v)]] -= num; } (2)边差分 对 u 到 v 的路径上的边 +num 用来求 - 已知路径求被所有路径覆盖的边 dis[i] 表示以i节点为儿子的边\nint init(int u, int v, int num) { dis[u] += num; dis[v] += num; dis[lca(u,v)] -= 2 *num; } 最后dfs遍历一遍\nvoid dfs(int x) { for(int i = head[u]; i; i = e[i].next) { int v = e[i].v; if(v != fx) { //fx 为倍增数组 dfs(v); dis[x] += dis[v]; } } } ","date":"2018-11-08T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"NOIP退役整理 3 数据结构"},{"content":"NOIP退役整理 1 数学相关 看完保证你,退役\n这篇笔记里从不写证明\n[TOC]\n0.更加基础的算法 这里贴几个最最最最基础的算法\n1.√n求因数 int cnt = 0, fac[maxn]; inline void get_factor(int x) { for (register int i = 1; i * i \u0026lt;= x; ++ i) { if (x % i == 0) { fac[++ cnt] = i; if (i != x / i) fac[++ cnt] = x / i; } } } 2.gcd int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } 3.√n分解质因数 int cnt = 0; prime[maxn], index[maxn]; inline void prime_factor(int x) { for (register int i = 2; i * i \u0026lt;= n; ++ i) if (x % i == 0) { prime[++ cnt] = i, index[cnt] = 0; while (n % i == 0) x /= i, index[cnt] ++; } if (x \u0026gt; 1) prime[++ cnt] = x, index[cnt] = 1; } 1. 裴蜀定理 (Bezout) $$ ax + by = m $$\n对于这样一个不定方程,当且仅当gcd(a,b) | m的时候,有无数多个整数解.特别的,对于 ax + by = 1, 当且仅当a和b互质时有如上结论.\n另: 对于任意多个未知数和任意多个系数, 这个结论也是成立的. 也就是 $$ a_{1}x_{1} + a_{2}x_{2} + \\cdots + a_{n}x_{n} = d \\\\ 其中d = (a_{1}, a_{2}, \\cdots,a_{n}) $$ 这样一个式子.\n似乎简单的用法就是推出系数和后面的解的关系,然后用gcd或者整数相关的东西瞎搞.\n例题:\nBZOJ 1441. 显然就是推广结论的裸题 \u0026lt;JSOI 2009 瓶子和燃料\u0026gt; 虽然感觉和Bezout没有什么关系\u0026hellip;个人认为,这就是个结论题, 似乎用辗转相减更好理解一点 \u0026lt;HAOI2011 向量\u0026gt; 这个比较难,要多推几步.也是一条Bezout定理.(从某个聚铑博客里发现的题) (这个我不会写) NOIP2014 Day2T3 解方程. 这个似乎就是直接枚举(因为1e6好像可以过去),然后Bezout定理去检验.(话说这题好皮啊\u0026hellip;)(然而我也不会写) 2.拓展欧几里得 (Ex_Gcd) 1.基本内容 这个算是一个比较基础的算法,用来解线性同余方程.\n这个方程大概长这个样子: $$ ax \\equiv b\\pmod {m} $$ 我们需要求整数解.\n把这个玩意儿变个形, 就得到了 $$ ax + my = b $$ 这不就是个二元不定方程吗.这个可以用exgcd来解.显然, 由Bezout定理可知, 如果有整数解,那就一定有无数个这样的解. 当且仅当(a,m) | b时有整数解\n所以在解方程之前需要判定合法. 也就是判断(a, m)|b是否成立.\n先上代码\nvoid ex_gcd(int a, int b, int \u0026amp; d, int \u0026amp; x, int \u0026amp;y) { if (b == 0) { x = 1, y = 0, d = a; } else { ex_gcd(b, a % b, d, y, x); // 划重点. x和y不要打反了 y -= x * (a / b); //这个括号一定要打。否则会先乘溢出 } } 解出来以后,这只是一个解.\n所有的解可以由一种构造方法得到, 也就是通解.\n$$ x_{i} = x_{0} + i * b/(a,m),i\\in Z\\\\ y_{i} = y_{0} - i * b/(a,m),i\\in Z $$\n还有最小整数解:\n$$ x_{min} = (x*b/d \\bmod (m / d) + m / d) \\bmod (m/d) \\\\ 其中d = (a, m); $$\n似乎还可以这么写: (不是很清楚这两个有什么区别) 总而言之,求逆元用下面的,最小整数解用上面的\n$$ x_{min} = (x \\bmod m + m) \\bmod m $$\n2. 中国剩余定理 用来解线性同余方程组.背结论好了.\n$$ 设m_1, m_2, m_3, \\cdots, m_n 是两两互质的数\\\\ 设 m = \\Pi_{i=1}^nm_i\\\\ M_i = \\frac{m}{m_i}\\\\ t_i是同余方程 M_i*t_i \\equiv 1 \\pmod m_i的一个解\\\\ $$\n$$ 则对于任意n个整数a_1,a_2,\\cdots,a_n,\\\\ \\begin{equation} \\left\\{ \\begin{array}{lr} x \\equiv a_1 \\pmod{m_1} \\\\ x \\equiv a_2 \\pmod{m_2} \\\\ \\cdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right. \\end{equation} \\\\ 该方程组有整数解, 为x = \\Sigma_{i=1}^{n}a_iM_it_i $$ 同样的,这也只是一个特解. 最小整数解需要%一下.\n终于到例题了:\nPoj1061 青蛙的约会. 经典老题 NOIP2012 同余方程. 裸的拓欧. 没了. 附赠:一个不错的讲解 3.各种筛 (把你打成筛子) 这个相信大家都很清楚是什么. 就当板子放在这里.\n1.素数筛 inline void get_prime(int n) { memset(vis, 0, sizeof(vis)); int cnt = 0; for (register int i = 2; i \u0026lt;= n; ++ i) { if (!vis[i]) { vis[i] = prime[++ cnt] = i; } for (int j = 1; j \u0026lt;= cnt; ++ j) { if (prime[j] \u0026gt; vis[i] || prime[j] \u0026gt; n / i) break; vis[i * prime[j]] = prime[j]; }\t} } 顺手判素数\ninline bool is_prime(int x) { for (register int i = 1; i * i \u0026lt;= x; ++ i) { if (x % i == 0) { return false; } } return true; } 2.欧拉筛 inline void get_phi(int n) { memset(vis, 0, sizeof(vis)); int cnt = 0; for (register int i = 2; i \u0026lt;= n; ++ i) { if (!vis[i]) { vis[i] = prime[++ cnt] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= cnt; ++ j) { if (prime[j] \u0026gt; vis[i] || prime[j] \u0026gt; n / i) break; vis[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]); }\t} } 求一个phi. 长得和分解质因数一毛一样\nint get_phi(int n) { int ans = n; for (register int i = 2; i * i \u0026lt;= n; ++ i) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n \u0026gt; 1) ans = ans / n * (n - 1); return ans; } 顺便一提, phi(n)表示小于等于n的素数个数\n积性函数什么的反正考不到我也不会,就不管了.\n大概的表是 0, 1, 2, 2, 4, 2, 6, 4, 10 \u0026hellip;\u0026hellip; 这个可以打表想到\n例题: Poj3090.可以由暴力算法观察结果得出,这个是个欧拉函数(反正当时做的时候是打表出来的).至于具体证明,呵呵\n4.逆元 逆元就是用来做除法取模的东西. 一个数处以另一个数等于被除数乘上除数的逆元.(因为在取模的时候,除法不满足结合律, 所以要用逆元)我们有多种方法求逆元,直接给出代码.\n1.exgcd 这个其实就是线性同余方程右边是1的情况下的解, 很明显它是唯一的,而且可以用exgcd解.\nint get_inv(int n, int p) { int x, y, d; ex_gcd(n, p, x, y, d); return (x%p+p)%p; } 复杂度 O(log(n))\n2.费马小定理 这个只有在a,p互素的时候才能用\n由 $$ a^{p-1} \\equiv 1 \\pmod {p}, p是素数 $$ 可以随便瞎推得 $$ inv(i) = i^{p-2} \\pmod{p}, p是素数 $$ 因为用了一个快速幂,所以复杂度是O(log(n))\nint get_inv_fm(int x, int p) { int k = p - 2, ans = 1; x %= p; for (; k; k \u0026gt;\u0026gt;= 1) { if (k \u0026amp; 1) ans = ans * x % p; x = x * x % p; } return ans % p; } 其实还有什么Euler定理,当n垂直于a的时候,a^φ(n) 同余于 1(在模n意义下).这样的玩意儿\n3.线性递推 inline void get_inv_arr(int n, int p){ inv[1] = 1; for (register int i = 2; i \u0026lt;= n; ++ i) { inv[i] =(long long)(p - p/i) * inv[p % i] % p;\t//防溢出 } } 这个没什么好说的,反正不长,背下来就好.\n5.组合相关 1.基本内容 加法, 乘法原理\n排列数\n$$ P_{n}^{m} = \\frac{n!}{(n-m)!} $$\n组合数 $$ C_{n}^{m} = \\frac{n!}{m!(n-m)!} = \\frac{P_{n}^{m}}{m!} $$\n相关计算性质 $$ C_{n}^{m} = C_{n}^{n-m} \\\\ C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} \\\\ \\Sigma_{i = 0}^{n}C_{n}^{i} = 2^{n} $$\n这些东西可以用来递推或者化简.\n虽然不知道是什么,但是还是写一下多重集的组合数吧233 $$ 对于一个多重集S = {n_{1} * a_{1},n_2*a_2,\\dots,n_k * a_k} \\\\ 设整数r\u0026lt;=n_i(i\\in[1,k]),从S中取出r个元素的不同多重集数量是C_{k+r-1}^{k-1} $$\n有时候需要求组合数,接下来给出相关代码\n求一个组合数\ninline int comb(int n, int m, int p) { int n_1 = 1, m_1 = 1; for (int i = n; i \u0026gt;= n - m + 1; -- i) n_1 = n_1 * i % p; for (int i = m; i \u0026gt;= m; -- i) m_1 = m_1 * i % p; return n_1 * get_inv(m_1, p) % p; //假装我们这里有一个求逆元的函数 } 这个比较慢,O(n)的\n求很多个\n//假设我们有了所有阶乘的取模的值和其逆元的值 return fac[n] * fac_inv[m] * fac[n - m] % p; 二项式定理(杨辉三角形) 就是那个noip2011 day2t1. $$ (a+b)^{n} = \\Sigma_{i = 0}^{n}C_{n}^{i}a^{i}b^{n-i} $$\nfor (register int i = 1; i \u0026lt;= k; ++ i) { comb[i][0] = comb[i][i] = 1; }\tfor (register int i = 2; i \u0026lt;= k; ++ i) { for (register int j = 1; j \u0026lt;= n; ++ j) { comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % hhr; } } 2.Lucas定理 $$ C_{n}^{m} \\equiv C_{n \\bmod p}^{m \\bmod p} * C_{n/p}^{m/p} \\pmod {p} $$\n注意,这里的p是素数, 如果是合数的情况,似乎是可以分解来做. 我给的地址里面有讲到.\n唯一的~~例题似乎是BJZOJ1951的古代猪文.比较难,还要合并线性同余方程组(中国剩余定理).不会写\n带Lucas定理的求组合数. 据说在模数比较大的时候不需要Lucas(来自某位dalao)\ntypedef long long ll; inline ll fast_pow(ll a, ll b, ll \u0026amp;p) { ll ans = 1; a %= p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = ans * a % p; a = a * a % p; } return ans % p; } ll Comb(ll n, ll m, ll \u0026amp;p) { if (m \u0026gt; n) return 0; ll ans = 1; for(register int i = 1; i \u0026lt;= m; ++ i) { ll a = (n - m + i) % p; ll b = i % p; ans = ans * (a * fast_pow(b, p-2, p) % p) % p; // 费马小定理逆元 } return ans; } ll Lucas(ll n, ll m, ll \u0026amp;p) { if (m == 0) return 1; return Comb(n % p, m % p, p) * Lucas(n / p, m / p, p) % p; } 其实还有拓展Lucas定理\u0026hellip;不管了.\n赠送:一个很好的文章\n3.容斥原理 这个东西说简单也很简单, 但是不是非常好说明.那么一大堆数学公式不但难打,而且看着也嫌烦. 举个例子,就是那个高一数学做的集合题, 那个什么参加乒乓球, 篮球还有什么足球的同学一共多少个什么的东西.这个东西在竞赛中的应用大概是把一类计数类问题进行转换,转换成比较便于计算的形式,然后得出结果,通常是什么逆向思维.也有分类之后算总和的时候进行容斥以得出正确的结论.\n因为我自己写得比较烂,理解也非常浅陋,下面贴几个Blog:\n1\n4.隔板法 隔板法就是在n个元素间的(n-1)个空中插入k个板,可以把n个元素分成k+1组的方法.\n这个东西讲起来比较麻烦\u0026hellip;2333继续放blog(其实是我不会)\n1\n6.矩阵相关 矩阵的基本计算就不说了.\n矩阵考的最多的就是用矩阵来加速多项式的递推计算,也就是矩阵快速幂\n1.矩阵快速幂 先上板子\nstruct matrix { ll dat[maxn][maxn]; int n, m; matrix(int sz1, int sz2) : n(sz1), m(sz2) { memset(dat, 0, sizeof(dat)); } inline friend matrix operator + (matrix a, matrix b) { matrix c(a.n, a.m);\tfor (register int i = 1; i \u0026lt;= a.n; ++ i) { for (register int j = 1; j \u0026lt;= a.m; ++ j) { c.dat[i][j] = a.dat[i][j] + b.dat[i][j]; } } return c; } inline friend matrix operator * (matrix a, matrix b) { matrix c(a.n, b.m);\tfor (register int i = 1; i \u0026lt;= c.n; ++ i) { for (register int j = 1; j \u0026lt;= c.m; ++ j) { for (register int k = 1; k \u0026lt;= a.m; ++ k) { c.dat[i][j] = (c.dat[i][j] + a.dat[i][k] * b.dat[k][j] % p) % p; } } } return c; } }; inline matrix fast_pow(matrix a, ll k) { matrix ans(a.n, a.m); for (register int i = 1; i \u0026lt;= ans.n; ++ i) { ans.dat[i][i] = 1; } for (; k; k \u0026gt;\u0026gt;= 1) { if (k \u0026amp; 1) ans = ans * a; a = a * a; } return ans; } 2.矩阵加速递推 对于一个递推式,我们可以把它放在某一个矩阵里面.然后它的每一次递推操作可以使用矩阵运算来解决,套上快速幂就会像记者一样.难点主要在于构建单位矩阵.\n以Fibonacci为例:\n我们有 $$ F[n] = F[n-1] + F[n-2] $$ 然后把它放到一个1*2的矩阵里面(我喜欢横着的) $$ \\left[ \\begin{matrix} F[n-1] \u0026amp; F[n] \\end{matrix} \\right] \\\\ \\left[ \\begin{matrix} F[n-2] \u0026amp; F[n-1] \\end{matrix} \\right] $$ 我们希望从上面一个推到下面一个, 于是乎由于F[n-1] = 0 * F[n-2] + 1 * F[n-1], F[n] = 1 * F[n-1] + 1 * F[n-2],可以得出如下单位矩阵 $$ \\left[ \\begin{matrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 1 \\\\ \\end{matrix} \\right] $$ 我们只要把这个矩阵做上n-1次乘法就可以得到结果了.\n例题很多,就不一一列举了.\n7.线性基(虽然可能不考) 这个比较简单，用来求一堆数异或起来的最值问题。主要的做法就是把这一堆数字的二进制给存起来，然后去一个一个异或。用到了向量的思想，不多说，背板子。\nconst int maxbit = 63; struct linear_base { linear_base() { memset(dat, 0, sizeof(dat)); } long long dat[maxbit + 1]; bool insert(long long n) { for (register int i = maxbit; i \u0026gt;= 0; -- i) { if (n \u0026amp; (1LL \u0026lt;\u0026lt; i)) { if (!dat[i]){ dat[i] = n; break; } n ^= dat[i]; } } return n \u0026gt; 0; } long long get_min() {\tfor (register int i = maxbit; i \u0026gt;= 0; -- i) { if (dat[i]) return dat[i]; } return 0; } long long get_max() { long long ret = 0; for (register int i = maxbit; i \u0026gt;= 0; -- i) { if ((ret ^ dat[i]) \u0026gt; ret) { ret ^= dat[i]; } } return ret; } }; 附赠:一个很好的文章\n8.概率期望(碰到就放弃系列) 1.基本内容 2.期望DP 9.神奇的东西 1.题目收集 Luogu: 斐波那契公约数 gcd(F[n], F[m]) = F[gcd(n,m)] Luogu: P4388 phi 2.GCD相关性质 并不清楚有什么\n3.几个数列 1. Catalan $$ Cat_n = \\frac{C_{2n}^{n}}{n + 1} $$\n几个常见的情况:\n合法括号匹配序列数(n左n右 -\u0026gt; Cat(n)) 合法出栈序列数(n个数 -\u0026gt; Cat(n)) n个节点构成的不同二叉树的数量 给个表:1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012\u0026hellip;\u0026hellip;\n2. Fibonacci 这个就不说了\n3.欧拉函数 前面有\n4.约数个数 4. 数论分块 这个详见余数求和那道题\n5.一些结论 $$ (x + 1)^p \\equiv x^p + 1 \\pmod{p} $$\n可以用来证明Lucas定理(对于OI来说没什么用) $$ 对于a \\perp b, 形如k*a + b的素数有无数个 $$ 虽然不知道有什么用\n10.致谢 百度 cnblogs csdn luogu \u0026lt;算法竞赛进阶指南\u0026gt; \u0026lt;信息学奥赛一本通 提高\u0026gt; \u0026lt;具体数学\u0026gt;\n","date":"2018-11-05T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/","title":"NOIP退役整理 1 数学相关"},{"content":"OI劝退指南 写了6年代码，搞了4年竞赛，终于要到头了。万事终有结束的一天，现在我倒是希望我的竞赛早点结束。我不希望再在自己不喜欢的事情上浪费时间了。总之，撑到今年NOIP就好。结束之后，我决定不再参加任何算法类竞赛，也不接受关于算法竞赛的任何咨询和讨论。\n正如标题所言，这一篇blog是作为一个失败者写给后死者们看的，希望以后的学生们不要盲目地被拉上贼船吧，希望他们能够做真正自己喜欢的事情。\n“后死诸君多努力 ” —— ？？\n回忆 ​\t正所谓殊途同归，每个人都应该有一个不同的开始。至于我，一个被拉上贼船的人，自然不是对竞赛或者是算法感兴趣。在小学的时候，因为非常闲（这也导致我现在每天累的死去活来还考得一塌糊涂），所以天天在打游戏。那时候虽然已经是2011年了，我五年级，但是我还是很喜欢玩C\u0026amp;C系列中的Red Alert 2，一款2000年针对win2000左右系统开发的即时战略游戏。我对它进行了深入的研究，也不再满足于仅仅是在它既有的框架内玩游戏，就开始玩mod，以至于自己想要写一个mod。一开始先改一改配置文件（没错，就是那个rules.ini，玩过的都知道），后来发现这样也太局限了，就顺手接触了编程相关的内容。因为各种原因，我最先学会的，居然是VBS（就是那个windows脚本，天天被用来做无脑病毒）。后来由于要忙小升初，就浪费了一段时间。\n​\t上初一之前，我被拉去参加了一个类似于竞赛预科班一样的东西，于是乎就学会了Pascal和基本的算法。初一开始，学校有NOIP的竞赛，我也顺手去报了名。然而我并不是那么重视这个东西，因为它主要是做题。在做够了八国联军的题目之后，我不想再看到题目。初一的寒假，本校唯一一次和盐城大丰的某个学校联系举行了一次冬令营，在那里我发现了自己的浅薄，那里的学生已经掌握了高阶的算法，基本上是我在高一的时候才会的东西。然而我并没有引起重视。在那里最大的收获是一个学生教练，Tsinghua计算机毕业，当时因为NOI金牌保送的。从他那里我了解了更加广大的计算机世界，比如java，c++，python和php这些语言。于是回来以后我就更无心竞赛，开始学这些东西。初二的时候，莫名其妙地过了初赛，NOIP普及组两日游，拿了个小奖。那年暑假，我才真正认真的开始竞赛，估计那时侯水平还是可以的，够得上提高组的二等奖了。那个暑假，我还开始了对编译器的研究，写出来一个小的解释器demo，可以有控制流和数组。初三的NOIP考得非常惨，因为少打一个空格导致最后一题爆零，错失一等奖。\n​\t中考结束以后，事情很多，就没有再搞竞赛。只是在开学之后突击了一下，就去考了NOIP2017提高，因为没有开long long错失一等奖，非常气，就打算再忙一年。渐渐发现，自己已经跟不上趟了，数学思维的硬伤导致我的动态规划和数学内容非常差，图论和打表暴力还马马虎虎。计算机竞赛已经成为了一块心病，一个包袱，丢不掉，也不想去学，一直到现在，浪费了我不少时间，也没有多大长进，估计也不会有什么好的成果。\n​\t这就是我的故事，6年，也就短短百余字。\n遗憾 ​\t这几年比较后悔的事情，就是没有在NOIP2017以后就退役，以及发现算法竞赛本质太迟了，直到年初我才大概搞明白什么才是我真正想要去学习的。还有就是初中太浪了吧。\n结论 第一个结论是关于算法竞赛本质\n算法竞赛，本质上更加倾向于数学，尤其是离散数学，而且基本超出了高中的范围，和高中课程基本没有什么联系。我作为一个数学渣，能撑这么久，主要还是编程能力在死磕。而且算法就是数学的一个分支，考到的内容一般比较抽象，对审题建模要求也比较高，计算机不过是个工具罢了。单单通过学习算法竞赛，你甚至不能搞懂计算机是怎么工作的，也不要妄想能够写出一个像样的应用。\n第二个结论是关于算法竞赛的优点\n首先可以对编程有一个基本的认识。\n其次可以学到许多离散数学的知识和以后基本用不到的算法（基本上二叉树封顶）\n还有对理科思维也是有一定的作用的\n最后当然是如果考得好（怎么说也得省队吧）的话，可以自主招生\n第三个结论是关于它的缺点\n这个竞赛就像高考一样，是考试。它会挖空心思来为难考生，有许多根本在现实中不存在的巨大数据量和限制，而且很多模型是不切实际的。这个考试还会对学生的代码风格和以后写大型程序的能力造成巨大破坏。最可怕的一点在于，它需要用到电脑（注意我说的这个用词）。这样就比较尴尬了，因为会情不自禁的打开b站，打开qq，打开游戏。。。。etc。\n第四个结论是关于初心和选择\n虽然我不是很喜欢那个包子，但是初心还是非常重要的。我就是一个忘记初心的人，我本来想要做游戏，后来就开始被学竞赛，甚至走偏到了操作系统的歪门邪道上来。我现在比较后悔当时没有毅然决然放弃竞赛，而是为了一些什么去硬撑着，总觉得有点可惜，反而浪费了热情和精力。\n这里还要谈一谈所谓竞赛和工程。竞赛是智力游戏，而工程是荒野求生。竞赛关注算法的方方面面，而工程对效率、空间的要求较低，主要关注正确性，实用性和整体的架构。编程有很多方面，竞赛是给那些计算机科学家和未来的技术大佬准备的。如果立志成为工程师的话，其实不必沉迷过深，算法学到了就行了，竞赛什么的都去死吧。不是说算法不重要，而是真正重要的算法都不难也不多。通用算法就那么几个，剩下的就比较的specific了，它们只解决在特定情况下的某一小类问题。\n第五个，最后一个结论是关于心态\n这个竞赛和其他的竞赛一样，都比较考验智力。总会有那么一些人比你年纪小、能力强，天才层出不穷。不必太放在心上，因为他们本来就是用来仰望的，人还是要看着前面走路。在你看前面的时候，他们早已让别人无法望其项背了，不会太堵你的路的。如果喜欢，就继续做下去吧。不喜欢就尽早放弃，把时间让给真正有意义的事情。\n展望 编程在未来应该是一个常用技能，就像现在的神经网络一样。无奈现在懂得人还是不多。很多情况下，人们还是需要一个比较高级的计算器的。在公司里叫做办公自动化（比如高效excel什么的），在科学研究中是建模的一部分（最流b的计算器之matlab）。编程不一定要参加竞赛，也不只是竞赛。我甚至会建议那些真正想要把编程作为一种爱好的人，真正想要做出一些属于自己的东西的人不要去参加竞赛。考试总是有着巨大限制的。\n在暑假里我参加了一个学校里大佬搞得计算机普及项目，也去讲了一节课。我还是真心希望更多的人能够喜欢编程，也很欢迎和竞赛题无关的算法和技术讨论。\n至于怎么入门和继续学习，我觉得从实践先做起，成就感和热情很重要。然后再去研究一些基本的算法和原理，最后就朝着目标前进吧。\n江苏省扬州中学OI退役\t2017级\txxx\t于\t2018年8月3日晚22时48分\n","date":"2018-08-03T00:00:00Z","permalink":"https://ridethepig.github.io/blog/oi%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/","title":"OI劝退指南"},{"content":"Modern Operating Systems 导读 太懒了不想写小标题 之所以会写这一篇导读，主要是由于自己准备看一看 Windows Internels 这本书，里面据说讲了不少黑科技，比如说Windows10系统基本上是跑在一个虚拟机上什么的，于是乎就准备先补一补操作系统基本理论，翻出了尘封一整个学期的《现代操作系统》这个砖头，开始认真看，并且计划做一些批注，以表示自己曾经读过这本书（自从被强迫做红楼梦的批注之后，就忍不住读书做批注了，啊啊啊啊）。现在的阅读进度大概是前4章结束，之后大概会跳过不少内容，可能会看第5章，略读第8章，再认真看看第11章，基本上就可以结束本次阅读了。说实在的还是想去把本书的第四版略读一下，因为似乎它有讲到云和windows8还有iOS和Android这种比较现代的东西，对我的阅读还是有不少好处的。\n大概说说这本书讲了什么 这本书正如它的标题所说，是一本关于操作系统理论的书，讲得比较的学院派，不过我本来就是要看一些比较理论的东西，毕竟工程里的实现千千万。所以关于OS的东西基本上都讲到了，除了具体实现，比如说历史，设计类型，基本的概念，进程线程，内存管理，文件磁盘，输入输出，甚至还有系统安全和实例分析。有点笼统吧，这是我的基本感觉，不过这个似乎也具体不起来，要不然就要够一架子书了。\n阅读的知识准备 哈哈，终于到了我可以嘲讽他人的地方了，毕竟作为一个OI菜鸡，天天被大佬嘲讽。\n首先是半精通c语言，（c++什么的去死吧，世界上最垃圾的语言），因为几乎所有的OS都是用C写的，指针的概念对于理解十分重要。\n其次是对OS的基本理解，最好Windows和*nix都体验过。最好还懂一点多线程和汇编，读到相关章节的时候就会异常亲切，然后跳过去。\n其实汇编和本书的第3章结合起来读更加有助于理解。对于程序编译、链接和执行的相关机理也可以实现了解一下。\n建议在自己野心勃勃地去写一个dos之前，先读一读这种理论书，不建议边学边做或者是去看代码什么的。另外，书里还有一点点的数学内容和一部分硬件相关，不过问题不是很大。最后就是把算法学学好，什么链表，图论，树都是有涉及到的，不过书中新介绍的算法比这些简单多了，都是一些实用、稳定、平均较优的易于理解的算法。とにかく，Don\u0026rsquo;t Panic。\n读些什么 这是个比较重要的问题，因为这毕竟是这是这一篇主要想要说的东西。hhh。第一遍随便你怎么看，像我一般会来来回回把第一章看个四五回才会真正get determined来读这本书的。第二遍可以通读，比较事无巨细的全都看一遍。这之后就可以以此为基础做一些其他的阅读，或者实践一下，再加深理解之后，可以挑一些来研究研究。里面的基本概念需要比较好的理解和掌握，至于一些算法，就我暂时看下来，只需要知道它们的各自的用途和优缺点就差不多了，不需要具体掌握细节内容。最好一边读一边查一查不知道的内容，可以扩展知识量，还有always留一份英文版，电子的就好，因为会出现垃圾翻译的情况。\n相关推荐 c语言：Primer系列 汇编：《汇编语言》 操作系统：《操作系统设计与实现》（也是本书作者写的）\nLinux内核设计相关内容 其他：编码 | 程序员的基本素养：编译、链接 ","date":"2018-06-01T00:00:00Z","permalink":"https://ridethepig.github.io/blog/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AF%BB/","title":"现代操作系统 导读"}]