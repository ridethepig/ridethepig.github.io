[{"content":"PA5 读文档 最后一个 PA，那必然是要把剩下来的文档全部读完。需要预先看一遍带是 cool-tour.pdf 的第7章 Runtime System 和 PA5 handout，至于 cool-manual.pdf 的第13章语义部分倒是可以一边实现一边看。\n先看 handout：\n代码量巨大无比，竟然是 PA4 的2倍（悲 文件简述：cgen.{cc|hh} 大部分需要写的代码，和 PA4 类似的结构，从 AST 的根节点开始进行 cgen；cool-tree.h 和 PA4 类似；cgen_supp.cc 定义辅助函数；emit.h 里面有一些 MIPS 汇编和符号宏定义；剩下的都是老熟人了。 主要任务： 生成全局常量（prototype objects） 生成全局表，class_nameTab class_objTab 还有方法调用表 生成每个类的初始化代码 生成方法定义 推荐的实现方法还是分两部分，先生成对象布局，然后第二遍在生成每个表达式的代码。 提醒注意：这次没有必要去“逆向”参考编译器了，因为它实现了一些高级功能比如寄存器分配优化，这个 PA5 并不要求这个。 运行时错误处理：manual 规定了6种运行时错误，生成的代码需要检测三种：(static) dispatch on void, case on void, missing branch；除零可以交给模拟器；剩下两种由 Runtime 处理。 GC：有一个3个命令行开关控制垃圾回收系统相关的功能。默认情况下不打开 -g 开关，此时不启用 GC，也就是说这是一个选做功能；-t 迫使 GC 系统在每次分配对象的时候进行回收；-T 的功能交给实现，可能会用来实现一些其他的运行时检查。实现 GC 功能的时候，需要认真阅读 Runtime 手册相关内容。这里可以去看看 CS143 课程网站上的那个单独的 cool-runtime.pdf，似乎写的更加详细一些。 测试工具：和 PA4 类似，提供了一个 -c 选项来设置全局变量 cgen_debug。同时提供了一个第三方实现的 Coolaid 工具对生成的 MIPS 汇编进行一些检查，说不定会有帮助。最后关于 Spim 的 warning 可能会有用。 然后看看 Runtime System：\n首先是对象布局：GC Tag 设为-1；Object Size 也得填上；dispatch pointer 因为不会被 runtime 用到，所以需要自己设计 dispatch 表；对于属性，Int 只有一个32位整数、Bool 也是如此、String 有一个32位的长度+后面全部是 ASCII 字节（最后需要 word 对齐），然后还有空指针 void。 然后是一个叫原型对象（Prototype Object）的东西：COOL 里面新建对象的方法是使用 Object.copy()，因此我们需要生成这些供其复制的东西，也就是 prototype object。生成的时候需要正确设置前面的头部，对于属性，三个基本类型有自己的规定，其余类型的属性随意设置。 栈和寄存器约定：方法调用参数放在栈上、从左到右依次压栈，a0 寄存器里面放 self 对象指针。指定了一组 Scratch registers 供 runtime routine 存放临时数据，因此需要调用者保存；还有堆指针和堆界限两个寄存器，完全由 runtime 控制。其他的都可以用。 Label：生成的代码需要和 runtime 一起变成最后执行的机器码，因此有一些 label 是指定的，就类似于接口一样的东西。有些 label 是 runtime 提供给我们使用的，也有一些需要我们生成供 runtime 使用。有一句话 There is no need for code that initializes an object of class Bool if the generated code contains definitions of both Bool objects in the static data area. 没看懂 执行初始化：Runtime 预定义了一些代码来调用 main 方法。首先通过 Main prototype 生成一个 Main 类的对象并用 Main_init 初始化，该初始化方法依次执行 Main 的基类的初始化最后初始化 Main；然后调用 Main.main，在 a0 里面放上 Main 的指针并设置 ra；执行结束后，Main.main 返回，这里打印出提示信息并终止执行。不过实际上我们并不需要关心这个问题，只需要知道 main 会首先被执行、以及 self object 会被默认放在 a0 里面。 一些踩坑 测评脚本硬编码了一些东西，因此需要进行一些修改以使其能够正常工作。它会调用绝对路径 /usr/class/cs143/bin/spim，这个最好就是复制一份到对应的目录；还有一个问题就是它的 spim 好像和下发的不一样（简单逆向了一下），因此它的标准输出中 spim 的打印信息有一处和我们的 spim 不一样：它的 handler 打印的是绝对路径，而我的是相对路径。试了好几种方法都没法改，看字符串表发现是硬编码的，因此只能改测试样例的标准输出。默认运行会导致数据被重新解压覆盖，因此需要先单独解压，然后修改，实际测试的时候用不重新解压数据的参数。具体如下：\n# Assume you are in directory `assignments/PA5/` sudo mkdir -pv /usr/class/cs143 sudo cp -r ../../bin /usr/class/cs143 sudo cp -r ../../lib /usr/class/cs143 perl pa5-grading.pl -v find ./grading -type f -exec sed -i \u0026#39;s;/usr/class/cs143/cool;..;g\u0026#39; {} + perl pa5-grading.pl -r 实现说明 这个里面的细节实在是太多了，如果要全部写清楚的话就很抽象，所以就简单写写要点吧。\n在开始之前，建议把它实现的继承树实现给换成 PA4 里面自己写的，这样可以省去看它的抽象代码的功夫。平心而论，他写的基础代码质量真的不咋地，效率低下还有内存泄漏，无力吐槽。\n主要的实现还是分成两个部分，第一个部分先线性地去生成一些必要的静态数据表，然后再递归地去生成表达式代码。这也说明了整个代码的结构，前面一堆是数据段，后面一堆是代码段。\n关于静态数据的生成，主要参考 Runtime System 说明，里面应该把所有必须生成和建议的实现方式都说到了。然后 skeleton 已经写了一些部分的生成代码，主要看 CgenClassTable::code()，它生成了所有需要用 .globl 声明的符号（但是可能没有定义，具体的符号见 Figure 3）、所有的常量对象（String、Int、Bool 这三种基本类型的字面值常量，都被转换成了静态的对象格式存放在数据段里面）以及 GC 标志。我们需要生成的东西有：\nclass_nameTab：类名表，按照 class tag 排序 _dispTab：每个对象的函数表，可以自己设计，不过还是直接按照继承和扫描顺序填算了 _protoObj：每个对象的原型对象，建议给每个属性填上默认值，这样后面就可以少生成一些代码，因为复制的时候就相当于已经把没有初始化表达式的属性给赋默认值了，不需要单独生成加载默认值的代码了。 class_objTab：这个在 cool-tour.pdf 里面没写，但是单独的 cool-runtime.pdf 里面写了。它的用处是处理 SELF_TYPE 的东西。如果对象是 SELF_TYPE，就只能通过 class tag 来确定它的运行时类型然后动态绑定，而不能在编译时确定它调用的方法。所以需要一个对象表，里面放上 _init 和 _protoObj，用的时候拿 tag 查表。 为了生成这些表，还需要做一些额外的工作，不过最后思考一下，可以在一次先序遍历中解决所有的问题。为了生成 dispatch 表，需要统计一个类中的所有方法，这就涉及到了继承和重写基类方法；为了生成 protoObj，需要指派 tag 并统计所有的属性，这里也需要考虑继承的问题。因为后面要用到 tag 在运行时判断继承关系，因此 tag 不能随便分配，需要按照遍历顺序依次分配。\n做完以上的工作之后，我们就可以开始进行正式的代码生成了。代码生成主要是表达式的生成，最后每个函数包装一下。我基本上就是按照课上讲的 Accumulator 模型写的，除非是调用 Runtime 的地方，其他的代码都仅使用 a0 和 t1 这两个寄存器做计算。不过课上的模型毕竟是简化过的，基本上能生成一大半的代码。剩下的部分需要额外处理局部变量的引入和属性的查询，需要自己写一个从符号到存储位置的映射表。因为我懒得单独做临时变量的地址分配了（其实不难做，只需要额外遍历一次 AST 就可以了），所以分配临时变量就直接压栈了。不过索引临时变量还是用的是 $fp 的相对偏移，因此维护了一个全局变量来记录当前用了分配的变量用的是哪一个地址（类似于一个小的栈，分配的时候+1，离开作用域的时候-1）。函数的参数也在栈上，在函数开始时候要把参数加入到表里。当然，除了栈之外，属性也是映射表的一部分，所以表项要加一个域来指示符号是在栈上还是在堆上（即相对于对象指针的偏移量）。\n除了表达式的生成，还有函数的生成。\n首先需要确定的就是 calling convention，我是用了比较方便实现的结构：调用者只需要压参数就行了，然后把被调用者所属的对象指针塞进 $a0；被调用者负责保存 $fp,$s0,$ra 这三个寄存器，同时负责回收参数占用的空间。\n关于参数，由于 COOL 规定了函数参数从左到右求值（冷知识：C 语言没有规定，取决于编译器实现），因此我让栈顶放最后一个参数（但是正常的系统中是栈顶是第一个参数）这样比较好写（求值一个 push 一个），因此在取参数的时候要特别注意。\n关于寄存器的使用，一共涉及到 8 个寄存器\n$sp 栈指针，动态变化，需要维护栈平衡 $fp 帧指针，在一个函数上下文中是固定的，用来确定局部变量的位置 $ra 返回地址，没啥好说的。 $s0 存放 self object，每个函数可能不一样，所以要在入口保存旧的并加载新的，在出口恢复旧的。 $a0 有两种情况，一种是作为参数，一般是把目标函数的 self object 放在里面传进过程调用里面；另一种是作为返回值，无论是函数的返回值还是表达式的返回值，反正得到的结果都放在里面。 $t1 临时变量，因为 RISC 架构只能两个寄存器之间做运算。 $a1 $t2 在我的实现中，这两个仅仅是用来给 Runtime 传参数的时候才会设置的，其他地方不会用到也不需要保存。 需要生成的代码有两大块，对象初始化代码和方法代码。\n新建一个对象分两步，首先调用 Object.copy 从原型对象复制一份，然后调用对应类的初始化方法来完成属性初始化。初始化方法只有一个参数 $a0 放的是需要被初始化的对象指针，主要是也是两步，先调用基类的初始化代码，然后把自己新增的且有初始化表达式的属性依次按表达式求值。之所以只生成有 init 表达式的属性代码，是因为前面写原型的时候就把那些没有 init 表达式的属性的默认值给填上去了。\n方法代码就正常生成吧，不同的是，初始化代码每个类都要生成，而方法代码则不需要生成预定义的5个类的方法。还有就是生成之前记得把参数列表和属性给加到符号表里面。\n关于实现部分，就简单描述如上，剩下的细节就去看手册吧，写不动。\n完结感言 至此，这个编译器就算是做完了。实验是 3.17 正式开始做的，前天调完最后一个 PA 是 4.1，前前后后做了有半个月的样子，一共写了近 4000 行代码。唯一的感觉是，真累啊。这个 Lab 既没有友好的框架代码，也没有完善的文档说明，工程量还巨大，如果不是我特地去找了找测试脚本，估计还得再多花不少时间写测试样例。总之相比做过的其他几个实验，这个的体验顶多算是及格。\n就难度而言，其实是没有多难的，看上去折磨只不过是因为它的不完善导致每个 PA 开始之前会困惑好长时间，然后堆代码堆个上千行，最后调 edge case 再调半天。那些算法一个没做，我觉得倒是不如像 xv6 那样，给一个基础的系统，然后让我写寄存器分配或者是控制流分析这些进阶功能。对于编译的理解，好像也没有在理论课的基础上提升多少：PA1 学习 COOL，没啥大用；PA2 写 flex，练了练怎么写正则表达式；PA3 写 Bison，练了练怎么写 BNF 文法，背后的原理啥也没学会；PA4 写语义检查，也就是实现了课上讲的类型规则系统；PA5 生成代码，纯纯的 MIPS 汇编。\n硬要说我学到了什么的话，大概就是了解了一下编译器的完整流程吧。总之不是很推荐做这个实验，有这功夫不如去写写它的 Written Assignment，还有详细的参考答案，感觉比做这个 PA 要更有用那么一些。\n无论如何，完结撒花，就酱。\n","date":"2023-04-03T00:00:00Z","permalink":"https://ridethepig.github.io/blog/cool-compiler-part5/","title":"COOL Compiler-Part5"},{"content":"PA4 终于不用折腾老古董了，虽然但是这个 PA 的代码量有点大啊，而且要考虑的东西变多了，为啥越做越难了。\n这个 PA 的代码量特别大，写了我三天半，而且是周末的三天半（每天写12小时代码），主要是实现语义检查，有很多细节需要考虑，包括生成的一些错误信息之类的。将近1/3的时间会花费在读文档、写测例、对着参考编译器复制错误信息（虽然不一定要求和参考程序一样，但是写成一样的会使得 diff 比较方便）以及考虑各种细节问题上。\n写之前先读文档 需要读的 Manual: Typing rules，scoping rules。除了13节 operational semantics 之外，应该都要看完。\n主要任务：\n遍历所有的类、构建继承关系图、检查继承关系 对于每一个类，先遍历一遍构建符号表，然后类型检查并在 AST 上做类型注解 需要修改的文件：\ncool-tree.h 扩展 AST 的定义； semant.cc semant.h 实现主要的逻辑：semant() 方法会被主程序外部调用，ClassTable 写了一点 starter code，构建继承关系用这个东西。 如何遍历：\n看代码 dump_with_types 继承关系构建：建个图然后检查环路。从 basic class 继承有限制（Int、String和Bool这三个都是不可继承、不可重定义的，其他的basic class 不能重新定义），同时不能继承一个不存在的类。 推荐的分析过程：第一步先检查继承关系，第二步检查其他的语义条件。\n作用域：self 自动引入，其他带需要考虑命名覆盖的问题。注意，class、method、attribute 这些的命名可以在定义前被使用，因此可能需要多趟处理。符号表在 support code 里面有定义，甚至有一个 symtab_example.cc 的样例程序。\n类型检查：对于无法确定类型的表达式，赋一个 Object 然后尝试恢复。需要给出错误信息，不过正如课上讲的 cascading error 是可以接受的。\n代码生成接口约束：所有表达式节点的 type 必须设置为 Symbol，具体的值由 type checker 决定。no_expr 赋值为预定义的 Symbol 变量 No_type。\n错误输出：对于不存在继承相关错误的程序，需要报告所有的语义错误（不要求和参考实现完全一致）。这个作业里面需要手动调用报错方法 ClassTable::semant_error()，（前两个PA是工具自动生成的）\n调试：skeleton 提供了一个命令行开关 -s，对应全局变量 semant_debug，可以用来条件打开调试信息。\n实现说明 需要修改的文件有四个，semant.cc semant.h cool-tree.h cool-tree.handcode.h。前两个主要是自己实现，主要的代码都在这里；后两个是为了定义 AST 节点上的接口。\n接口方面，我增加了一个 semant(Class_, ClassTable*) 来做类型检查以及一些必要的 getter 供父节点访问子节点内部信息。不过也不是所有类型的都写了，为了省事，我只写了 Feature 和 Expression 两个类的 semant 方法。写的时候可以在 cool-tree.handcode.h 的宏里面定义这些接口，这样就不用手动把定义复制到每个子类里面去了。剩下的各种列表、Branch 和 Formal 的处理逻辑就一起写到他们的父节点里面了，因为他们被用到的地方是唯一的，写在哪里都是写一遍。semant 方法接受两个参数，一个当前的类，对应规则里面的环境 C；还要一个是 ClassTable 这里面存放了所有需要用到的工具以及符号表（对应规则里的环境 O,M），然后递归向下处理整个AST。\n整个过程分为两个部分实现，分别处理继承关系和其余部分（主要是类型检查）。\n继承关系检查又需要扫描三次类列表，第一遍去除重复的类定义并检查预定义类冲突；第二遍初步建立继承关系树，检查基类存在性；第三遍遍历继承关系树，检查是否存在环形继承。这些工作完成后，产生了一个继承树和一些其他的辅助记录结构，后面的检查会依赖这些信息。 检查环路其实很简单，只需要从 Object 开始遍历一遍树，没访问到的肯定有环。因为语法分析保证了一个类只能有一个基类，如果存在环那么它向根肯定跳不到 Object，不过向上跳不好写，反过来就是从 Object 开始遍历树无法访问到的节点在环上，就很简单了。 不过 skeleton 并没有提供相应的数据结构，需要自己实现。写一个 node 类型，然后写上父节点和子节点指针（列表），另外需要一个指针存对应的类以及一个辅助变量（用来后面写 LCA 和判定环路）。 在实现的过程中比较遗憾的是，指针乱飞，而且它提供的符号表还内存泄漏，实在是一言难尽。不过累了，懒得改 RAII 了， 其余部分需要两次遍历，一次线性扫描所有的类，遍历每个类的 Features 列表，收集每个类里面的属性和方法定义加入符号表并检查重复定义和方法覆盖的情况；同时还要顺便保证一下 Main 类和 main 方法的存在。第二次就是类型检查，从 AST 的 program 开始（这个 skeleton 已经写好了）向下递归调用子节点的 semant 方法来进行检查。 之所以要两遍，是因为属性和方法可以在定义前被使用，因此需要提前收集，不然没法做类型检查。 这里涉及到符号表的设计。根据类型检查规则，需要两个表，一个是标识符，一个是方法。我的做法是给每个类分了一组符号表（标识符和方法），用 map 索引起来，在第一次扫描的时候把类的属性和方法就塞进去，同时还有 self:SELF_TYPE 这个保留定义。 第一次检查的时候，需要处理重复定义和方法覆盖。对于属性，重复定义还需要考虑继承的属性；对于方法，特别注意方法覆盖，需要比较长度、返回类型（完全一致，不可用派生类）和每个形式参数的完全一致。 第二次就比较的繁琐，需要把每一条类型检查规则写成 C++ 代码。为此，还需要定义运算符 join 和 conform（相当于课上的 lub 和 \u0026lt;=）。前者是因为 if 和 case 两个语句的返回类型要取它们的最小上界。这个过程中需要特别注意的是对 SELF_TYPE 的处理，因为 SELF_TYPE 不在类定义表里，而且很多规则都涉及到这个东西。 具体的实现因为太多了，就不写了。 对着手册写完了一堆规则之后，还有究极麻烦的错误处理。这里列几个基本的原则，实在难绷的会记录在下面的细节说明中。\n只有在无法确定类型的时候赋值 Object，而不是一有类型错误就返回 Object。比如使用了未定义的类型，只需要报错就行了，在后续的检查中不需要把他改成 Object。还有算术，无论两边的操作数类型是啥，这个算术表达式都是返回 Int 类型的。 SELF_TYPE 和 SELF_TYPE_c，这两个东西在 AST 里面都写成 SELF_TYPE 这个 Symbol，在实际检查的时候再特别判定。另外关于这两个玩意的错误很多都是特别判定的，再参考实现里面这东西的错误不和其他的一起判断，我也推荐这样的写法，比如一开始先不考虑这两玩意儿，写完之后再加上。 尽量多检查一些东西，有些能继续的就继续，只有一阶段检查完之后可以 abort，其他的尽量不直接 return。 细节说明 特别注意一下的情况统计，会比较有用。\n引入新变量绑定的四种情况\nattribute definitions; formal parameters of methods; let expressions; branches of case statements. 允许使用 SELF_TYPE 的四种情况\nnew SELF TYPE return type of a method, declared type of a let variable declared type of an attribute 这个 PA 的坑细节很多，调了大半天bug。\n关于 self 和 SELF_TYPE 的特别判定 self 不能被赋值、不能重定义（属性名、 let 变量名、形式参数名、case 绑定名） SELF_TYPE 不能重定义（类检查）、只能出现在四个地方（因此不能用于形参定义、静态函数调用） 表达式的返回值可能是 SELF_TYPE，这是就需要结合当前类来执行 conform 和 join 操作了，如果不考虑的话会段错误。 记得在返回类型的时候同时改 AST 上的类型标注（主要是 Expression 类下面的，Feature 和 Formal 一开始就标好了 type_decl 这个反而不能改） 方法、属性查询的时候，记得要查父类，不然继承的变量和方法就找不到了。 还有各种未定义的处理，一不小心就段错误了 返回 Object 的情况：objectid 未定义、new 未定义类、函数调用中无法确定被调用函数的情况（类未定义、函数未定义、函数参数个数不对）、loop 返回值。 剩下的基本上能从手册的12章中比较清晰的看出来。\n","date":"2023-03-28T00:00:00Z","permalink":"https://ridethepig.github.io/blog/cool-compiler-part4/","title":"COOL Compiler-Part4"},{"content":"PA3 这个作业写 Parser。主要问题依然来自于 bison 工具不会用以及各种奇形怪状的 edge case，折磨程度和前一个差不多，写了3天的样子。写的时候一直在想如果有 ANTLR 就好了，之前玩过，感觉比 Flex + Bison 这种老古董要舒服多了。\nBison 踩坑 前期主要是 Bison 不会用，这里记录一些坑。基本上的工作就是在翻译手册上的 BNF 然后写 semantic action。写着写着突然发现它的课上好像根本没讲这玩意，就挺抽象的。\n一开始需要了解的东西（不至于迷惑）：$$ $[1-n] 分别表示 : 左边的 non-terminal 和右边的第n个符号所关联的值，这些值可以理解为树的结点。这些东西是有类型的，所有可用类型定义在 %union 里面，对应到产生式上需要单独指定（貌似新版的 bison 提供了推导功能，但是这个实验在设计的时候显然没有）。对于终结符（这里就是那些 TOKEN），默认 int，如果带 lexeme 值的需要特别指定 %token\u0026lt;typename\u0026gt; token-name 这种；对于非终结符，需要指定 %type\u0026lt;typename\u0026gt; non-terminal-name，这里就类似于 non-terminal 的声明。bison 会检查这些所有的类型是不是匹配，当然这里的检查只是检查这些语法符号之间的类型匹配，具体到 C++ 的函数调用还是交给编译器。@$ @[1-n] 是行号相关的东西。详细的信息似乎在 bison 文档里面有一个单独的小节列出了符号的含义来着，忘了。\n关于 Bison 手册的阅读：这里我直接用的最新的3.8.2，直接看最新的文档就行了。 1.1-1.4，简单了解一下；第2章可以看，也可以去看看《Flex与Bison》，都是用例子讲解；然后就是具体的东西，3.2-3.4，3.7，5.1-5.7这些都会用到；看看这些基本上就能把框架搭起来了。 然后到了第一次编译，第8章关于 debug 的说明还是可以看看的 最后是看第6章关于错误处理的说明，虽然这个说明也没啥大用。 框架代码会导致 Shift-Reduce Conflict：如果是框架提供的那种、用空规则定义各种 xx_list 的写法，会出现 SR Conflict。虽然实际上应该是可以用的（大雾）（因为有一些 bison 的默认行为会使得这么做能够得到正常的结果），但是我还是把它拆掉了（不像看到 warning），也就是把用到 xx_list 的地方写成有 xx_list 和无 xx_list 两种，而不是交给 xx_list 这个 nterm 来处理空的情况。这样就没有 warning 了。 一些东西是 bison 的扩展，因为开了兼容性警告 -Wyacc，所以用了会 warning，比如 %empty %precedence 这种。 剩下的倒是没啥，因为没有用旧版本的东西，所以没有出现 flex 那么多奇怪的东西。\n基础设施说明 这里的代码库主要是他们自己写的奇怪的 AST 的东西，虽然用起来也没啥大问题，不过总觉得有点抽象。这里主要参考 cool-tour.pdf 的第6节，描述还算是比较详细的。\n具体的东西没必要了解，也不需要修改它的结构，说一下基本的逻辑就能上手写 semantic action 了。\n首先它的功能是提供一种 AST 的描述方法，定义了一堆不同类型的 node，写语义动作的过程就是用这些 node 来组装一个 AST。 用到的接口基本上就是类似于构造函数一类的东西（这么理解其实对于写这个 lab 而言没有任何问题），每种 node 都有一个自己的类型，能够接收一组特定类型的参数进行构造。不同的类型通过 bison 文件前面的 %union 进行定义，构造器就是在填当前 node（$$）的信息和子节点关系。写文法就类似于递归下降（虽然实际上 bison 用的是 LALR），一种自然的构造语法树的过程。 node 主要有两种，一种是 list，另一种是单独的 node。list 表达的是一堆同类型的子节点，构造的时候和链表类似，这个在 skeleton 里面有例子（class list）。然后我们在定义的时候，可以参考着写。 除了简单看一看那个 cool-tour，具体的定义去看那个 aps 文件，描述了详细的参数类型。 这个实验只需要用构造器函数就行了，生成 C++ 时候添加的方法用不到，是给后面计算 AST 用的。 实现说明 要修改的文件主要是 cool.y，但是为了处理行号的问题，还需要修改 /include/PA3/cool-parse.h:754。\n最简单的部分是翻译文法定义，照着 manual 12节抄就行了。在此过程中，可选的部分要稍微处理一下，描述的时候拆成有和没有可选部分两条规则，然后还要填上默认值，比如省略初始化的时候需要填个 no_expr()、函数调用省略对象的时候需要补上默认的 object(idtable.add_string(\u0026quot;self\u0026quot;)) 。这里面唯一要动一动脑子的就是前面提到的 list 的书写方法，一方面是 Shift-Reduce Conflict 最好不要写空规则，另一方面就是链表的构造，不过这个可以抄前面的 class_list 的定义，不需要自己折腾了。\n然后的是优先级定义，虽然也没啥好说的，照抄 manual 的优先级表。值得注意的是，这里不需要理会 dangling else 问题，因为文法不允许省略 else 子句；这种设计虽然对于 PA1 写代码很不友好，但是实现起来还是很舒服的。\n比较头疼的是 let，这东西没办法写在 expression 规则里面，需要自己再开一个 non-terminal 来写递归。之所以麻烦，是因为它的定义列表是没有长度限制的，所以要用文法描述就必须通过递归。还有就是它需要把有多个符号定义的 let 转换为多个只有一个符号定义的 let 的嵌套。比较好理解的写法是写右递归，类似于 lisp 里面的链表，看到逗号就继续递归加尾巴，把 IN expression 作为终止条件。不过这个最后的 expression 会导致冲突，因为 let 本身就是一个 expr，所以你也不知道这个后面的东西是接在里面这个 expr 的后面还是接在 let 这个大的 expr 的后面。一个具体的例子：let id1:T1 in expression.f()，有两种加括号的方法 (let id1:T1 in expression).f() 和 let id1:T1 in (expression.f())，也就是在这个 . 的地方产生了 Shift-Reduce。根据提示，我们可以用 %prec 来解决问题，在优先级列表最低级里面加一个 LETEXPR，然后在 IN expr %prec LETEXPR，这样就会优先匹配其他的可能属于 expr 的产生式，最后再匹配 let 后面的那个。\n写完以上这些东西，这个文法实际上已经完成了，能够解析所有合法的情况。\n最麻烦的事情是错误恢复。不过说难也还好，关键是没个例子不知道咋写。基本的写法就是有一个内置的 terminal error，可以匹配所有的出错情况，然后就可以一直跳过直到我们指定的某一个 token。基本上就是在每个 list 那边加一条 | error ';' 类似的东西，这样就可以把错误跳过去直到一个合法的结束符（handout 里面的要求就是如果有合法的结束，那么从下一个同类型的结构继续）。不过 let 那边需要特别注意一下，因为除了中间的声明部分的情况，我们还希望继续检查最后的那个 expr，因此不能只写一个 error ','，如果只有一个变量声明的话，那么后面的 expr 就会无法匹配规则，因此还要写一个 error IN。\n不过以上都是我的写法，我看 Github 上还有别的写法，有的有问题，有的写的不太好但是能过（就比如说用空规则），总之能用就行，我也不能保证我写的一定没问题，毕竟对于 bison 还不是很熟悉。\n最后还有一个行号的问题，建议把所有的行号都设置成最后一个符号的行号，不过实际上可以不改。感觉需要改一下的是 cool-parse.h 那边，因为 no_expr 的行号设为0比较合理，我这里好像是会继承基类tree_node 的构造函数，把行号设置为当前的行号；但是其实应该写成0，我也不知道当年的编译器是咋做的。\n","date":"2023-03-24T00:00:00Z","permalink":"https://ridethepig.github.io/blog/cool-compiler-part3/","title":"COOL Compiler-Part3"},{"content":"PA2 PA 2-5 正式写编译器。PA2 写词法分析器，首先读一遍 README 和 handout。\n环境配置\n因为这个项目的结构非常的智障，导致需要进行一些配置才能让 clangd 正常工作。因为是 Makefile 项目，所以不能直接生成 compile_commands.json。\n安装 apt install bear，这个工具可以拦截 make 命令来生成上述的文件。 在 PA2 目录下，运行 make clean \u0026amp;\u0026amp; bear -- make lexer，然后 clangd 应该就不会找不到头文件之类的了 获取评测脚本\n现在已经没有办法在线提交测试了（除非花钱？），因此需要从一些奇怪的地方获取测试工具，这里我从 https://github.com/shootfirst/CS143 这个 repo 里面扒了评测脚本（测试数据已经包含在了脚本里了） pa[2-5]-grading.pl，测试的话直接用 perl ./pa2-grading.pl 就行了。 这个东西确实测出来一些自己没考虑到的边角问题，虽然我已经很努力的在编测例了。\n写完了发现还是很折磨的，写了快两天的样子，一方面是对于 flex 工具和配套的基础设施不是很了解，另一方面是各种细节问题需要处理。\n实现说明 比较简单的部分是那些只需要返回一个 token 类型的东西（关键字和符号这种），pattern 就是他们自己，然后 action 就一个 {return (TOKEN)}。\n然后稍微想了一下的，标识符和 Int、Bool 常量，需要写一个简单的正则外加操作 String Table 和 cool_yylval。\n需要折腾一会的是注释，需要用到 flex 的状态。\n比较简单的是单行注释，检测到 -- 就进入 \u0026lt;SCOMMENT\u0026gt;（Single-line Comment），然后检测到换行就回到 INITIAL 状态。这里是 . 和 \\n 这一组互斥状态，EOF 不需要单独处理，可知已经覆盖了所有的情况。 然后是多行注释，不过这里需要支持 nested comment。这玩意的意思是说，需要在注释里面也要成对匹配 (* *)，不能简单的只考虑最外层或者最内层的符号对。这里需要多加一个变量 comment_nest_level 来维护嵌套的层数，流程也更复杂一些。 首先遇到 (* 进入 \u0026lt;NCOMMENT\u0026gt;（Nested Comment），同时初始化嵌套层数；然后在该状态下过滤 (*，发现一个就叠一层，过滤 *) 发现一个减一层或者到底了就退出状态就行了；这里需要特殊处理 EOF，如果在该状态下匹配到 EOF，需要报错，但是因为反正输入流已经结束了，就不需要做 resume 了；遇到 \\n 维护一下行号；剩下的就交给 .。前面其实不需要写 exclusion，因为最长匹配（(* *) 都是2个字符，. 和 \\n 都是1个， EOF 不可能匹配到其他的东西上），所以可以简单的囊括所有的情况并维护优先级。 除了注释里面的部分，还需要考虑一个单独的 *)，需要匹配并报错（而不是* ) 两个 token）。这个是4.1节第5条的要求。这样一来，我们就解决了嵌套注释不匹配的两种错误情况，即：左符号比右符号多 =\u0026gt; EOF in comment 报错；右符号比左符号多（等价于单独的 *)） =\u0026gt; Unmatched *) 报错。 最折腾的是字符串，因为它要考虑多行的情况，而且需要做特殊的 resume 处理。好消息是这些细节文档都有描述，坏消息是需要看好几遍才能完全理解。\n为了方便处理出错恢复处理，用了两个状态 \u0026lt;STRING\u0026gt; 和 \u0026lt;STRINGREC\u0026gt;（String Recovery）（不然需要在 action 里面写很多的特判）。 正常情况下，遇到 \u0026quot; 进入 \u0026lt;STRING\u0026gt;；然后对需要特殊处理的部分编写规则： \\ 转义：匹配两个字符，根据 \\ 后面的字符决定把什么东西写进最终的字符串常量里面，这个东西在 handout 的第4.3节和 manual 的10.2节有描述；需要注意的是，合法多行转义可以（在最后加一个 \\ 然后换行，后面没有其他空白符）在这里一并处理掉，只不过需要写成(.|\\n)。 EOF：根据 manual，除了 \\0 和 EOF，其他字符均可出现在字符串中。因此，需要单独处理这两玩意。EOF 和前面的注释类似，比较简单。 0字符：0字符需要恢复。除了返回 ERROR Token，还要把状态切换到 \u0026lt;STRINGREC\u0026gt;，剩下的部分交给恢复规则。 未转义换行：根据最长匹配，可以直接写 \u0026lt;STRING\u0026gt;\\n，因为转义过的是2个字符。这个不需要进恢复状态，因为它直接返回 \u0026lt;INITIAL\u0026gt; 然后继续下一个字符就相当于处理了恢复的过程。 对于除了以上情况的所有字符（可以 exclude 或者把 . 写到最后），用 boilerplate 给我们定义的 string_buf 存放。这里需要处理一个字符串过长的问题，判断指针超限之后，进 \u0026lt;STRINGREC 并返回 ERROR Token，具体的边界情况可以对拍（对比标准实现）来获知。最后就是遇到了未转义的 \u0026quot;（根据最长匹配可以直接写 \u0026lt;STRING\u0026gt;\\\u0026quot;），把 string_buf 塞进 stringtable 里面，回到 \u0026lt;INITIAL\u0026gt;。 对于恢复状态 \u0026lt;STRINGREC\u0026gt;，根据手册，从下一个未转义的换行符或者未转义的\u0026quot;（因为要求是 closing \u0026quot;）开始继续正常的词法分析。所以在前面需要把 \\\\\\n 和 \\\\\\\u0026quot; 给处理掉，然后遇到 \\\u0026quot;|\\n 这两个之后就直接返回 \u0026lt;INITIAL\u0026gt; 就行，也不需要 return 任何东西。期间也要记得维护行号。不过事实证明，不需要单独处理 EOF，因为恢复了也没东西了。 这里有一个细节问题，就是报错的行号必须等于出错的地方的行号，因此不能留到后面统一返回报错，而是一旦出错就立刻返回。 容易忘掉的点，一个是空白符匹配，需要一个 pattern（action 留空），不然遇到空白符 lexer 会行为异常，同时遇到换行还要维护行号；第二个是不合法字符，有些 ASCII 我们并没有用到，因此需要最后一个 . 来匹配并报错、跳过。同样的，. 和 \\n（包含在空白符规则里面）的组合至少保证了所有的字符都会被匹配、处理。\n不过其实，最离谱的是自己设计测试样例，这很考验对于手册的理解，不然就会漏掉点什么（虽然漏掉一些 edge case 对于后面也没啥影响就是了）。\n在用了官方的评测脚本之后，又发现了一个问题：\\\\0（0x5C 0x00） 是不允许的。这个其实判定起来不难，但是会想不到，因为 PA2 的 handout 没写这一条，虽然 manual 里面 A string may not contain the null 的确是不允许这种情况（因为它转义完了还是 \\0），但是谁会想到测这个呢？\n基础设施说明 个人感觉，一开始做的比较迷惑的主要原因在于它的代码框架比较凌乱，文档也有点谜语人，读了好几遍文档才知道该写点啥。\n写之前多读几遍文档，首先看一遍 PA2 的实验说明，了解一下需要干什么，里面也有一些读其他文档和代码的指导。然后是 cool-manual.pdf 看第10节（主要是写 pattern 的时候看）和第12节里面那个大的 BNF 文法（里面描述了所有用到的符号），以及 cool-tour.pdf 看第3节，在写 action 的时候会用到它来存字符串。最后看一下代码，主要是 /include/cool-parse.h，这里面定义了非 ASCII 符号的 TOKEN，还有 YYSTYPE 枚举，这个枚举是用来存 lexeme 的，；lextest.cc 也要看一下，至少知道输出的都是什么。\n这个里面用到的基础设施主要是一个 String Table，用来存放所有遇到的字符串。里面有个 add_string 方法，会先查再加还带内存分配，所以直接调用就行。碰到需要存字符串值的东西，各种 identifier、String 常量和 Int 常量（不检查不转换，直接存），这三个每个都有一个单独的实例对象（idtable stringtable inttable），需要根据不同的 token 用。\n另外一个就是 YYSTYPE cool_yylval 这个枚举。如果有需要存的信息（lexeme 或者错误信息，参考第5节 Notes for the C++ Version of the Assignment），每个 action 往里面写一个值，这个对应 PA2 文档第4节开头的部分，当时看了半天才理解到是要存这东西里面。用到里面的3个枚举值：boolean、symbol、error_msg。如果是解析出来 Bool 常量，那么直接写进去 true/false；如果出错了，给字符指针 error_msg 赋值，我猜需要用到 strdup，但是单就这个实验看不出来，总感觉要出内存 bug（也不知道后面会不会 free 掉）；剩下来那些需要存 lexeme 的就先 add_string 然后它会返回一个 Entry，这东西就是所谓的 Symbol 啦。\nflex 工具踩坑 最后记录一下 flex 这个工具的一些坑。\n版本：因为不知道在网上的什么地方看到了一个 blog 说是新版本的 flex 在处理 c++ 时的行为和旧版不一样，所以选择了旧版本，也就是 apt install flex-old 安装的版本（2.5.4）。问题在于我看的文档版本是最新的，遇到了一个不支持的语法，不过其他的倒是没有特别需要注意的地方。旧版本的 flex 似乎不支持 (?i:xxx) 这种写法，这个在关键字忽略大小写的时候会比较省事（因为只有关键字需要忽略大小写，所以不能开全局忽略），可惜的是旧版本只能像个傻子一样写成 CLASS [Cc][Ll][Aa][Ss][Ss]。 奇怪的缩进规则：它居然和 python 一样，依靠缩进来分辨一些东西，每个 Section 的规则还稍有不同。比如在 Rule Section（就是实际写 action 的那一节），pattern 必须无缩进，然后其他的东西（比如注释）必须前面有空白符，不然就会被认为是一个 pattern。在看文档的时候要注意一下 (un)indented 这个词，可以避免很多奇怪的事情。\n一开始没看到 the pattern must be unindented and the action must begin on the same line 这一句，没给注释加前面的空格，然后就调了半天的 unrecognized rule。 还有就是 action 可以没有大括号但是不能没有分号，以及它其实是可以写多行的，只要前面有 indent 就行（不然会写出很长一串）。 EOF 符号：flex 里面的 EOF 专门有一个 \u0026lt;\u0026lt;EOF\u0026gt;\u0026gt; 来表示，但是它不能和其他的 pattern 写在一起，也就是需要单独一行写一个这东西，不然报错。 0 字符（null character）：这个本身没什么特别的，直接用就行，不过需要注意的是，. 通配符是包含 \\0 的，也就是一不小心就用这玩意把 \\0 给匹配进去了，单独写的那个 \\0 规则就不生效，会导致一些费解的事情发生。 VSCode 插件：搜到两个还算下载量比较多的，但是都不行，有一个着色有 bug（可能是因为它太老了，接口不兼容了），还有一个加了莫名其妙的、极具误导性的语法检查还关不掉（一点问题都没有的代码给我每行一个红色波浪线）。建议用第二个，然后大脑忽略他的错误提示。 剩下的就看两眼文档就会了，跟课上教的 Regular Expression 基本上大差不差。\n","date":"2023-03-21T00:00:00Z","permalink":"https://ridethepig.github.io/blog/cool-compiler-part2/","title":"COOL Compiler-Part2"},{"content":"COOL Compiler 是 Stanford CS143:Compilers 的课程项目，这学期学编译原理，于是就做了一下。每个 PA 都写了一点笔记和踩坑记录，大概分个两三次更完。\n开始之前 这门课的官方材料好像每隔几年就会换一个地方，导致找起来十分的困难（之前做的 xv6 就很棒，多少年的东西都放在同一个网站上），现在这个时间点（2023年3月）的官网应该是在 edx 上面，需要注册收费之类的才能获取相关材料。不过这门课历史悠久，基本上从2000年左右就有了，自然是被大家复制传播到了各种地方。这个 repo 里面的 starter code 是从 github 上别人的仓库里面的分发包（student-dist.tar.gz）解压出来的，我对比了几个仓库的代码内容都是一样的，那么做这个版本的应该问题不大。不过和课程网站上的内容还是有一些不同的，这就没有办法了，大家也拿不到 Stanford 的内部版本。\nPA1 第一个实验是用 COOL 写一个简单的程序，程序的功能是解释一个简单的 Stack Machine 语言，会输入一些序列然后按照文档的说明进行操作。\n推荐的实现方式是，定义一个 StackCommand 类，然后为每一条命令实现一个子类用来执行具体的操作。这里还给了一个工具类 atoi.cl，里面实现了 String 到 int 的转换。不需要实现错误处理，假设给出的序列都是合法的。不过本人才疏学浅，就写了几个 if 就写完了，压根没写这么复杂。\n首先我们需要一个 List 作为栈，这个可以从 examples/list.cl 里面抄过来，然后把数据类型改成 String 就可以了。然后就是处理输入输出，定义一个输入变量，一个大循环判断是不是 input = \u0026quot;x\u0026quot;，里面一个大 if-else-then 判断输入的命令，如果是 d 就调用前面抄过来的 print_list（需要修改一下格式和类型）；如果是 e 需要再来一个 if-else-then 来处理求值操作；其他的就直接塞进栈里面，这里不做错误处理，假设都是合法的。具体到 e 命令里面，pop 并判断栈顶，如果是 +，pop 两次，调用 a2i 做运算然后再 i2a 变回字符串 push 到栈上；如果是 s，依然需要 pop 两次并保存 pop 出来的东西，然后逆序 push 进去就完成了交换操作。\n主要的困难在于 COOL 的智障语法，其他的倒是没啥难度。\n最智障的是它的 expr。绝大部分的东西都是个表达式，两个大括号也是表达式 { [[expr; ]]+}，两个大括号中间的表达式后面必须跟分号（其他的不需要），if - fi 后面都必须跟分号我也是绷不住了。然后它的函数定义后面跟着那两个大括号是个语法符号（摆设）而不是 expr，这种就很不直觉，让我困惑了半天然后翻它的文法声明才发现这个事情。feature::=ID( [ formal [[, formal]]∗ ] ) : TYPE { expr }，也就是说，只能写一个表达式，不然就得再加一个单独的大括号然后里面写多个分号隔开的表达式。 其次是它的 if-then-else 居然不能没有 else！这导致我不得不像个傻子一样定义一个 dummy(): Object {0};，然后放在根本不需要的 else 子句里面。 还有它的 while 循环居然没有 break ？！ let 语法也是究极奇葩，我是不能理解为什么要设计成这个样子。想定义一个局部变量都得加一层嵌套，这个嵌套多得让我觉得我 tm 是在写 scheme。 它的 case 也是奇葩，居然是用来做动态类型匹配的，匹配的是类型而不是值，和正常的 switch-case 完全不一样，倒是有点像 rust 里面的那种感觉。 测试的话，虽然 handout 里面说是直接 make test 然后对比输出，不过我也没看到它哪里有所谓的 reference implementation，自己看了看测例觉着没啥问题就行了。\n","date":"2023-03-18T00:00:00Z","permalink":"https://ridethepig.github.io/blog/cool-compiler-part1/","title":"COOL Compiler-Part1"},{"content":" 期末\n强制\n幸运加成! #_#\n","date":"2019-01-11T00:00:00Z","permalink":"https://ridethepig.github.io/blog/%E6%9C%9F%E6%9C%AB%E5%BC%BA%E5%88%B6%E5%B9%B8%E8%BF%90%E5%8A%A0%E6%88%90/","title":"幸运加成"},{"content":"NOIP 退役回顾 回首 初二起4年OI, 占据了我编程岁月的相当一部分时光. 现在想起来, 其实有点后悔. 人们都说青春无悔, 然而青春实际上是充满着悔恨和嗟叹的. 从想要开发游戏, 到被带进竞赛的坑, 其实莫名奇妙, 我自己并不知道这一系列的选择代表了什么, 现在看了, 它们代表着失败和悔恨. 如果可以重新来过, 我选择享受每一天的阳光, 享受计算机科学和算法本身的优美, 没有智障的题面, 没有毒瘤的数据, 也没有时间限制, 排名先后, 分数和自招.\n当然, 在无聊的竞赛之余, 我还学习了Python \u0026amp; C#语言, 操作系统 \u0026amp; 编译原理, 也学会了很多计算机相关的专业知识, 它们给我带来了无尽的乐趣, 让我认识到计算机科学世界的广博, 支撑着我度过竞赛岁月. 希望后来者们不要局限于竞赛, 除了竞赛, 要记得计算机还有很多更加有趣和有用的方面.\n我很感谢那些从初一起就陪伴我的同学们, 无论是中途退出, 还是早早退役, 感谢你们陪我打RA3, 陪我在冬令营课上刷知乎, 陪我刷题, 向我讲解题目. 值得庆幸的是, 这一切并不依赖于竞赛的载体, 我们拥有竞赛之外的更多的东西: 游戏, 番剧, 食物, 搞笑\u0026hellip;\u0026hellip;这或许是竞赛生活中为数不多了乐趣了. 也是竞赛留给我的唯一收获. 竞赛败坏了我的编程习惯, 带偏了我的思维, 浪费了我的青春, 这是人生之痛, 但苦难同时也是救赎.\n这里特别的感谢FSR大人, 以及您所讲过的算法, 题目, 以及有趣的番剧和精彩的RA3对决. 希望以后仍然有机会一起讨论这些, 虽然不是很想提及竞赛. 祝您早日金牌.\n至于老师, 感谢本校的总教练laoni, 感谢您的关心和培养, 虽然没有能够取得好成绩, 辜负期望了. 同时也感谢隔壁jdzx的chenzhong老师, 感谢初中时候指导我学习了中级算法, 并且耐心地解决我的问题. 是您使得我可以较为轻松地进阶提高组的比赛.\n同时也隔空感谢一下前些日子在czyz集训时的同学们. 你们应该已经取得好成绩了吧. 另外还有隔壁的tjh巨佬, 同届的OI选手, 也算是相互勉励(%)了吧.\n当下 此时也没有什么太多的感触了, 只是觉得比较的轻松, 可以睡一个好觉了. 虽然成绩还不清楚, 虽然明天还有期中考试, 但是不管怎样, 都已经结束了. 此时突然想要找个人聊一聊. 不过各位可能都在复习期中 / 到处浪吧\u0026hellip;\n未来 正如昨天写到的, 我对于这样的竞赛已经感到十分失望了. 并不想要多说什么, 只是以后不会再有以后了. CCF(China Collecting money Foundation)再也收不到我的血汗钱了. ACM-ICPC除非在弱校, 否则不会去参加了. 就连大学选择计算机专业的可能性也将为一成了. 希望这次做得能够决绝一点, 不要像高一差5分退役的时候怀抱幻想了. 青春没有重来, 人生充满后悔. 然而我们还是希望下次能够做得更好, 总是在绝望中, 骗自己去怀抱希望.\n至于以后, 直到高三毕业, 都会用周末和假期的闲暇时间, 用心打磨一个项目, 或许是一个实用工具, 也或许是一个大型后端工程. 以前都太浮躁了, 没有能够把一个项目做好, 这次希望可以. 指导感兴趣的同学也是可以的, 只不过不会忽悠他们去学竞赛了.\n以后我的博客里应该还会再出现一篇NOIP相关的文章, 不过那得等到出成绩之后了.\n以后不能每天碰到电脑了, 可能会一周甚至两周一更吧. 主要内容主要会是学校生活, 项目开发经历以及技术原理解析和科技新闻一类的东西, 虽然我也不觉得会有人能够看到它们.\n结束 就这么结束了呢. 怀着悔恨, 不甘, 无助的心情, 去面对永无黎明的黑暗. \u0026ldquo;信竟没有明天\u0026rdquo;, 用RA3苏联第6关的话来说, 大概是这样的感觉吧.\n就这么结束吧. さようなら。\nPrisrak · Smalin (Maoliang_Li)\n","date":"2018-11-11T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E6%AD%A3%E5%BC%8F%E9%80%80%E5%BD%B9%E5%AE%A3%E8%A8%80/","title":"NOIP 退役回顾"},{"content":"NOIP 考试记 -3 今天早上又去学校打了一场模拟赛, 感觉比较郁闷. 最近心态似乎还是比较爆炸, 又爆零了. T1因为评测机辣鸡导致暴力居然T掉了, 本机可以过3个点. T2居然把MST的并查集写错了. T3因为比赛环境比较的毒瘤, 就没有写暴力就交了. 总共浪掉了110. 毒瘤至极, 我自己也不想说什么.\n几个要注意一下的:\n写组合数不要暴力写, 记得打一下组合数的表, 顺便还少了一个log的逆元 看清题目, 不要太想当然. 估计也还是因为不够重视吧. 今天的炸零. 也只能这么安慰一下自己了. 其实还是暴露出来更多的一些问题, 比如如何保证暴力能拿分, 确保拿到分. 去年的时候由于各种码力加成, 就不用担心什么暴力写不出来之类的问题. 今年水平稍微提高了, 暴力水平反而下降了, 各种手滑出大锅. 再有就是如何能够比较全面的考虑一个问题, 有几题以为想到正解, 然后直接炸零.\n估计这几天本来想写的20道题就写不完了, 事到如今也只能相信自己了. 还剩两天, 估计就只能把NOIP几天暴力和模拟的原题写一写了. 然后再复习一下基本算法, 剩下时间就全部交给DP了, 毕竟连续几年都是一天一条DP, 把人气死, 尤其是我这种DP巨弱的选手.\n-2 虽然今天早上打算认真听课, 但是还是忍不住上完了主课去看了一眼. 今天的题其实还是比较平和的. T1可以暴力卡常40pt. 然而正解是除法分块优化除法求和来暴力枚举. 有两个初三的jl立马就想到了, 我今天晚上才理解这个东西, 感觉真的是要入土了. T2的话, 15min出正解, 没写, 估计写了会挂掉. T3是个原题, 毒瘤树形dp, 不多说什么, 也不是不可做就是了. 反正感觉因该第一天不去才对的说. 2333\n几个要注意一下的:\n看到带取模的数学题, 记得把 $$ a \\bmod p $$ 变成 $$ a - \\lfloor\\frac{a}{p}\\rfloor * p $$\n除法分块??\n今天算是稍微回复了一点码力, 不过还是非常的眼瞎, 各种打错. 明天打算再做两道NOIP原题, 其他的不管了, 看看骗分导论, 学一波模拟退火, 就去GG退役了. 今天也好颓废啊, 甚至想要NOIP前夜放君の名来着2333.(不知道有没有人跟我一起看) 今天莫名其妙心态不错\n-1 哇, 明天就去南京了, 心情有点小复杂, 感觉这一年又白活了. 今天主要是打板子和学习玄学算法, 还有好多的板子没有去打, 话说如果不是NOIP就不知道自己其实还有好多东西没有去学. (所以又浪了一年) 更多的话, 就留到明天晚上再说吧.\n0 Day0结束了. 最后一天的佛脚真的是抱的可以, 一天打了十几个板子, 外加十个DP板子, 简直就跟TMD什么都没有学过一样. 除了感觉自己白学一年, 就没有什么别的感触了. 现在其实一会感觉很慌, 一会又感觉稳的不行. 反正, 就这样吧, 希望这种东西, 本事无所谓有, 也无所谓无的. 现在最重要的似乎是睡一觉以及保证自己的肚子不要出锅. 赶紧睡了, 没有竞赛的黎明正在等待着我.\n1 今天居然出现了3条原题??? (我不想和你说什么, 因为我只是一只CCF) 导致已知上百号人当场AK, 无数人250+. 没有骗满分的我留下了蒟蒻的泪水. T1居然还是抄的以前的NOIP??? 然而我考场上并没有想到怎么写, 于是胡诌了一个递归分治, 大样例和自己的毒瘤数据都过了, 应该没有什么大问题. 有人说会被卡掉, 不过不管了. 期望得分: 70 - 100. T2不知道是个什么, 一眼看出背包可做, 然后就写了个80分做法. 满分做法没有调对. 期望得分: 80. T3是个二分答案+树形dp, 然而考场上不会写check函数, 就立马凉凉. 写了35分部分分, 另外的20部分分没有调出来. 所以今天的期望得分再185 - 215之间.不算太差, 但绝对算不上是满意, 已经凉透了. 我彻底对CCF和信息学奥赛失望了, 连最基本的出题态度都已经丧失的竞赛还有什么希望吗? 虽然大佬们可能AK得非常开心, 但是对于中等水平的选手绝对不是什么开心的事情, 辛辛苦苦来参加复赛, 做到的却是陈旧的题目, 更可悲的是我竟然不知道T2T3是原题. 不想复习了. 已经提前退役了, 我已经把Luogu上的签名改成了退役选手, 也公开了所有代码. 再见了, NOIP. 虽然明天还是会去强撑着把它考完.\n2 这还行\n暴力 GG 滚粗 退役\n然后去搬砖, 享受奋斗的社会主义人生\n之前看到了去年NOIP小学奥数那张毒瘤图, 突发奇想地打算在NOIP之前看一波\u0026lt;你的名字\u0026gt;, 于是乎今天下午, 在确认直接提前一天退役以后, 跟同学一起看了这个前年的番. 总体感觉是: woc, 这居然是一个大制作. 本来以为这还是类似于言叶之庭的作画, 没想到居然画面如此之精良.\n看的时候是一边吐槽一边看的, 外加旁边还有两个放鬼畜加打游戏的, 所以观感不是很好, 但觉得如果在电影院看的话, 效果应该是很好的. 尤其是画的彗星的场面, 非常的漂亮.\n情节本身不多说, 写得很好, 虽然一开始看得有一点懵逼, 毕竟是时空交错的剧情, 导致到后来就不知道是谁在说话了, 最后似乎是新海诚第一次发糖, 虽然不是特别甜\u0026hellip; 比较可惜的是没有能够一个人享受剧情, 作为一个剧情导向的死宅, 我更加觉得有点浪费. 导致看完内心毫无波澜\u0026hellip; 本来是非常凄美的爱情故事, 然而在看完一大波鬼畜和吐槽之后, 就完全无感了, 比较难受.\n音乐无论是作曲还是配制, 都非常的到位, 之前在听歌的时候就能感觉到场面的宏大开阔, 当bgm响起的时候实在是激动万分. (洋次郎自然是没话说的呀) 后来本着尊重演职人员的态度, 顺手看了一眼CV, woc, 简直是太强了: 信长, 上百石萌音, 连香菜都来客串了\u0026hellip;\u0026hellip;\n可惜并没有什么可爱的妹子一起看的说\u0026hellip;\n至于看完了有什么想法的话, 可能没有. 估计是因为老了, 这样的番看多了, 也就不觉得有什么触动, 所以也越来越难被感动. 现在已经害怕看恋爱番了\u0026hellip;一个是怕出现那样的情况, 还有一个是自己会觉得有一丝忧伤\u0026hellip;当别人成为人生赢家的时候, 然而我还在写着毫无算法可言的代码, 看着鬼畜的时候, 偶尔也会觉得人生的灰暗吧. 当然还有旁边坐着一个老司机的忧伤.\n话说日本的传统文化可以玩好多东西, 然而不知道为什么中国那些古董就一点也不文艺呢, 而是有一种木头的感觉.\n希望明天RP++. (话说我今天考场上跟就跟看这个番的时候一样懵逼) 同时也祝和我分享此番的同志zjy RP++\n一边听着过气的歌一边写下的无聊感言\n","date":"2018-11-10T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip-%E8%80%83%E8%AF%95%E8%AE%B0/","title":"NOIP 考试记"},{"content":"NOIP退役整理 2 图论 看完保证你, 退役!\n继续没有任何证明的笔记\n[TOC]\n0. 基础的算法 -1. 链式前向星 最最最最重要的存图方法.\nint head[maxn], cnt = 1; struct Edge { int next, to, w; } edge[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } for (int i = head[u]; i; i = edge[i].next) { int v = edge[cnt].to; //... } 0. 百分数(BFS)和电风扇(DFS) 这个我不想说什么. 不过什么DFS的手工栈估计也是不会考,我虽然会写但是只用过一次还炸了\n1.拓扑排序 拓扑序是一个比较重要的顺序,可以用来做各种事情,比如在图上递推, 或者直接解题什么的.\n主要就是在DAG上分析依赖关系. 还可以判环.主要思想就是:每次找入度为0的节点,找到后删除该节点和该节点的出度边.\n// deg[]是入度. vis[]呵呵. 以下默认使用链星. (生成树除外) void Topo(int u) { vis[u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; deg[v] --; if (!deg[v]) Topo(v); } } //main for (register int i = 1; i \u0026lt;= n; ++ i) { if (!vis[i] \u0026amp;\u0026amp; !deg[i]) Topo(i); } 可以在这个主要模板上做各种操作. 判环的话, 记一个color标记(比如:记正在访问为-1, 已经访问为1, 没有访问为0), 如果祖先节点没有返回但是子孙节点又访问到了它, 于是就有环了.\n其实还有BFS的写法.估计不考, 就不管了.随便找了一个板子\n1.最短路 1. Dijkstra 先膜一波: %%%Dijkstra%%%\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; using std::priority_queue; const int maxn = 1e5 + 10; const int inf = 0x7fffffff; inline int read() { int x = 0, f = 1; char c; while((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct T_Edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; inline void AddEdge(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } struct T_Node { int i, d; T_Node(int a, int b): i(a), d(b) { } inline friend bool operator \u0026lt; (T_Node a, T_Node b) { return a.d \u0026gt; b.d; } }; priority_queue\u0026lt;T_Node\u0026gt; pq; int n, m, s; int dis[maxn + 10], vis[maxn + 10]; int main() { n = read(); m = read(); s = read(); register int ui, vi, wi; for (register int i = 1; i \u0026lt;= m; ++ i){ ui = read(); vi = read(); wi = read(); AddEdge(ui, vi, wi); } for (int i = 1; i \u0026lt;= n; ++ i) { dis[i] = inf; } T_Node now(s, 0); now.i = s; now.d = dis[s] = 0; pq.push(now); while (!pq.empty()) { now = pq.top(); pq.pop(); int u = now.i; if(vis[u]) continue; vis[u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (!vis[v] \u0026amp;\u0026amp; dis[v] \u0026gt; dis[u] + edge[i].w) { dis[v] = dis[u] + edge[i].w; pq.push(T_Node(v, dis[v])); } } } for (register int i = 1; i \u0026lt;= n; ++ i){ printf(\u0026#34;%d \u0026#34;, dis[i]); } return 0; } 这个的复杂度是严格O(nlog(n))的.(其实跑n遍dj比一遍floyd要快(不考虑常数) // 笑)\n2. SPFA #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; inline int read() { /*...*/} int head[maxn], cnt = 1; struct Edge{ int next, to, w; } edge[maxn]; inline void add_edge (int u, int v, int w) {/*...*/} int vis[maxn], dis[maxn]; inline void spfa(int s) { int q[maxn]; memset(q, 0, sizeof(q)); memset(dis, 0x3f, sizeof(dis)); int l = 1, r = 1; q[l] = s, dis[s] = 0; while (l \u0026lt;= r) { int u = q[l ++]; vis[u] = [0]; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (dis[v] \u0026gt; dis[u] + edge[i].w) { dis[v] = dis[u] + edge[i].w; if (!vis[v]) vis[v] = 1, q[++r] = v; } } } } //main 这个写起来比较方便, 虽然有可能会被卡掉.\n3. Floyd 这个的主要思想是DP. 所以也是可以在上面加个一位瞎搞的. 复杂度很高, O(n^3)\n状态转移方程 $$ D[k,i,j] 表示经过几个编号不超过k的节点,从i到j的最短路.我们把这个k作为一个中转点一样的东西 \\\\ 显然, D[k, i, j] = min(D[k-1, i, j], D[k-1, i, k] + D[k-1, k, j]) \\\\ 再显然,k这一维可以被推掉 \\\\ 就变成了: D[i, j] = min(D[i, j], D[i,k] + D[k,j]) $$\n//init memset(d, 0x3f, sizeof(d)); for (register int i = 1; i \u0026lt;= n; ++ i) d[i][i] = 0; //自己到自己 // read in... for (register int k = 1; k \u0026lt;= n; ++ k) { for (register int i = 1; i \u0026lt;= n; ++ i) { for (register int j = 1; j \u0026lt;= n; ++ j) { d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]); } } } 这个玩意儿似乎可以用来求最小环, 最后再写吧\n然而更加牛逼的是, 这个玩意儿的求解过程比较类似于矩阵乘法, 有些看似不可做的题目可以用类似于这样的矩阵快速幂跑.\n4. 相关题目 Luogu P1144 最短路计数. 在跑Dj/ Spfa的时候随便统计一下 Luogu P2384 把加法换成了乘法, 保证你退役2333. 其实打个log就好了 Luogu P1613 在Floyd上加一维乱搞 5. 我是不是应该皮一把k短路 A*可做. 复杂度上界O(nklog(nk)\n我不会写红红火火恍恍惚惚\n2.生成树 1. Kruskal #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e5 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int fa[maxn]; int findfa(int x) { return fa[x] == x ? fa[x] : fa[x] = findfa(fa[x]); } struct Edge{ int from, to, w; inline friend bool operator \u0026lt; (Edge a, Edge b) { return a.w \u0026lt; b.w; } } edge[maxn]; int main() { int n = read(); int m = read(); for (int i = 1; i \u0026lt;= m; ++ i) edge[i].from = read(), edge[i].to = read(), edge[i].w = read(); std::sort(edge + 1, edge + m + 1); int cnt = 0, ans = 0; for (int i = 1; i \u0026lt;= n; ++ i) fa[i] = i; for (int i = 1; i \u0026lt;= m; ++ i) { int fau; if ((fau = findfa(edge[i].from)) != findfa(edge[i].to)){ fa[edge[i].to] = fau; ans += edge[i].w; cnt ++; } } if (cnt \u0026lt; n-1) printf(\u0026#34;fuck\u0026#34;); //如果边数不对就说明生成失败了 else printf(\u0026#34;%d\u0026#34;,ans); } 2. Prim 不讲 这个基本用不到. 只有在稠密图上才会优于KS.\n3. 变种生成树 最大生成树就把排序的顺序改一下就好了.\n次大/小生成树有点难写.\n先求最小生成树T,枚举添加不在T中的边,则添加后一定会形成环,找到环上边值第二大的边,把它删掉,计算当前生成树的权值,取所有枚举修改的生成树的最小值,即为次小生成树.这种方法的实现更为简单,首先求最小生成树T,然后从每个结点u,遍历最小生成树T,用一个二维的数组max[u][v]记录结点u到结点v的路径上边的最大值,然后枚举不在T中的边(u,v),计算T-max[u][v]+w(u,v)的最小值,即为次小生成树的权值 ,这种方法的时间复杂度为O(n^2+e).\n因为没什么题,就不多说了.\n考生成树的时候,一般是Day2T1的难度.基本上不会有什么特别的地方,一旦看出来能敲对就可以了.题目都比较弱智,不贴了\n3.Tarjan 先膜一波为敬: %%%Tarjan%%%\n1. 强连通分量 概念就不说了. 主要用来缩点,缩完以后就把一个有环图变成DAG,就可以随便瞎搞了.\n求这个玩意儿,其实有另外一个奇葩的跑两边的算法.(在接受FanDalao的指导之前,我一直写的是那个k打头的算法).\n先上板子\nint low[maxn], dfn[maxn], stk[maxn], instk[maxn], tim, top, scc[maxn], num; // scc[u]代表u属于的强连通分量的编号 // low[u]代表u能到达的最小的dfn,似乎也就是最老的祖先 // dfn代表的似乎是dfs序列 void Tarjan(int u) { dfn[u] = low[u] = ++tim; instk[stk[++top] = u] = 1; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (!dfn[v]) { Tarjan(v); low[u] = std::min(low[u], low[v]); } else if (instk[v]) { low[u] = std::min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { //完了,又回到自己了 num ++; while(1) { int v = stk[top --]; instk[v] = 0, scc[v] = num; if (v == u) break; } } } 还是有一些有趣的题目的.不过感觉都比较趋同,缩点-\u0026gt;搞一搞连通性,最短路,出度入度-\u0026gt;没了\n2. 割点和桥 概念不说.\n割点\ninline void dfs(int u,int root) { int sz = 0; dfn[u] = low[u] = ++cnt; for (register int i = head[u];i;i = edge[i].next) { int v = edge[i].to; if (dfn[v]) low[u] = min(low[u],dfn[v]); else { sz ++; dfs(v,root); if (low[v] \u0026gt;= dfn[u]) iscut[u] = true; low[u] = min(low[u],low[v]); } } if (u == root \u0026amp;\u0026amp; sz \u0026lt; 2) iscut[u] = false; } // may be more beautiful void point(int u, int rt) { int sz = 0; dfn[u] = low[u] = ++tim; for (register int i = head[u]; i; i = edge[i].next ) { int \u0026amp;v = edge[i].to; if (!dfn[v]) { sz ++; point(v, rt); if (low[v] \u0026gt;= dfn[u]) iscut[u] = 1; low[u] = std::min(low[u], low[v]); } else { low[u] = std::min(low[u], dfn[v]); }\t} if (u == rt \u0026amp;\u0026amp; sz \u0026lt; 2) iscut[u] = 0; } 桥 //正确性不明\nvoid bridge(int u, int fa) { low[u] = dfn[u] = ++tim; for (register int i = head[u]; i; i = edge[i].next){ int \u0026amp;v = edge[i].to; if (!dfn[v]) { bridge(v, u); low[u] = std::min(low[u], low[v]) ; if (low[v] \u0026gt; dfn[u]) { // \u0026#34;\u0026gt;\u0026#34; isbridge[u][v] = 1; } } else if (fa != v) { low[u] = std::min(low[u], dfn[v]); } } } 似乎没有什么题目。\n3. 双联通分量 \u0026ldquo;点双连通图的定义等价于任意两条边都同在一个简单环中,而边双连通图的定义等价于任意一条边至少在一个简单环中.\u0026ldquo;这个是从网上抄的.\u0026ldquo;不同双连通分量最多只有一个公共点,即某一个割顶,任意一个割顶都是至少两个点双连通的公共点.不同边双连通分量没有公共点,而桥不在任何一个边双连通分量中,点双连通分量一定是一个边双连通分量.\u0026rdquo;\n这个东西的求解跟上面的割点和桥差不多,虽然我没写过.(有一条HNOI2012)\n过天把代码补上\n4. LCA \u0026ldquo;对呀对呀..求LCA有六种方法,你知道吗?\u0026rdquo; \u0026ndash;fan乙己 %%%%%%\n1. 暴力 我表示不会写. 这个应该跟倍增差不多思想.就是对于两个点,轮流向上面跳,直到碰起来这个样子.\n2. ST表/RMQ 这个跟tarjan一样不是很常用.就不打了,省的浪费时间和记忆力\n3. 倍增 最最最常用而且很好写的lca.大家都在写它.(虽然很容易被卡掉,但是NOIP级别的还没有毒瘤到去卡这个)\n主要思想就是先预处理出每个点的深度,然后对于两个点的深度差倍增的向上跳,因为是倍增所以比一般的跳快一点.\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int next, to; } edge[maxn\u0026lt;\u0026lt;1]; inline void AddEdge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; } int deep[maxn], l[maxn][30]; void dfs(int u) { //预处理 for (register int i = 1; i \u0026lt;= 20; ++ i) { l[u][i] = l[l[u][i-1]][i-1]; } for (register int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (v == l[u][0]) continue; // 什么,儿子变成父亲了233 l[v][0] = u; // v的父亲是u,就是从v向上跳2^0,即1步到达u deep[v] = deep[u] + 1; dfs(v); } } inline int getlca(int u, int v) { if (deep[u] \u0026lt; deep[v]) u ^= v ^= u ^= v;\tfor (register int i = 20; i \u0026gt;= 0; -- i) { if (deep[l[u][i]] \u0026gt;= deep[v]) { u = l[u][i]; } }//把u和v跳到同一高度 if (u == v) return u; //到了一个点上,说明这两个点具有祖先关系 for (register int i = 20; i \u0026gt;= 0; -- i) if (l[u][i] != l[v][i])//一起跳 u = l[u][i], v = l[v][i];\treturn l[u][0]; } int n,m,s; int main() { n = read(); m = read(); s = read(); int tmp1,tmp2; for (register int i = 1; i \u0026lt;= n-1;i ++) { tmp1 = read(); tmp2 = read(); AddEdge(tmp1,tmp2); AddEdge(tmp2,tmp1); } deep[s] = 1; dfs(s); for (register int i = 1;i \u0026lt;= m; i++) { tmp1 = read(); tmp2 = read(); printf(\u0026#34;%d\\n\u0026#34;,getlca(tmp1,tmp2)); } } 4. 树链剖分 树剖是前置技能.不说.\n主要思想是把u和v所在链的顶端跳到一起\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int next, to; } edge[maxn\u0026lt;\u0026lt;1]; inline void AddEdge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt++; } int sz[maxn], son[maxn], top[maxn], deep[maxn], fa[maxn]; void dfs1(int u) { sz[u] = 1, son[u] = 0; for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (v == fa[u]) continue; fa[v] = u, deep[v] = deep[u] + 1; dfs1(v); if (!son[u] || sz[v] \u0026gt; sz[son[u]]) son[u] = v; sz[u] += sz[v]; } } //处理儿子 void dfs2(int u, int tp) { top[u] = tp; if (son[u]) dfs2(son[u], tp); for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (v != fa[u] \u0026amp;\u0026amp; v != son[u]) dfs2(v, v); } }//处理链顶 inline int getlca(int u, int v) { while (top[u] != top[v]) { if (deep[top[u]] \u0026lt; deep[top[v]]) u ^= v ^= u ^= v; u = fa[top[u]]; } if (deep[u] \u0026gt; deep[v]) u ^= v ^= u ^= v; return u; } int main() { int n = read(), m = read(), s = read(); for (register int i = 1; i \u0026lt; n; ++ i) { int u = read(), v = read(); AddEdge(u, v); AddEdge(v, u); } dfs1(s); dfs2(s, s); for (register int i = 1; i \u0026lt;= m; ++ i) { int ui = read(), vi = read(); printf(\u0026#34;%d\\n\u0026#34;, getlca(ui, vi)); } return 0; } 5. 离线Tarjan 不是很常用.贴一个久远的板子.\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; const int maxn = 3e6+50; int n,m,s,cnt1 = 1, cnt2 = 1; int head1[maxn], head2[maxn], ans[maxn], fa[maxn]; bool vis[maxn]; struct t_edge{ int next, to; }edge[maxn]; struct t_query{ int next, to, num, vis; }query[maxn]; inline void AddEdge(int,int); inline void AddQuery(int,int,int); inline int read(); int father(int); inline void combine(int,int); void dfs(int); int main() { //freopen(\u0026#34;testdata.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); n = read(), m = read(), s = read(); //scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s); int ui,vi; for (int i = 1; i \u0026lt;= n-1; ++i) { int ui = read(),vi = read(); //scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;ui,\u0026amp;vi); AddEdge(ui,vi); AddEdge(vi,ui); } for (int i = 1; i \u0026lt;= m; ++i) { int ui = read(),vi = read(); //scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;ui,\u0026amp;vi); AddQuery(ui,vi,i);AddQuery(vi,ui,i); } //fclose(stdin); for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; dfs(s); for (int i = 1;i \u0026lt;= m; ++i) printf(\u0026#34;%d\\n\u0026#34;,ans[i]); return 0; } inline void AddEdge(int u,int v) { edge[cnt1].next = head1[u]; edge[cnt1].to = v; head1[u] = cnt1 ++; } inline void AddQuery(int u,int v,int num) { query[cnt2].next = head2[u]; query[cnt2].to = v; query[cnt2].num = num; head2[u] = cnt2 ++; } inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 3) + (x \u0026lt;\u0026lt; 1) + c - 48; return f ? x : -x; } int father(int x) { if (fa[x] != x) fa[x] = father(fa[x]); return fa[x]; } inline void combine(int x,int y) { fa[father(x)] = father(y); } void dfs(int u) { vis[u] = true; for (int i = head1[u]; i ; i = edge[i].next) { int \u0026amp;v = edge[i].to; if (vis[v]) continue; dfs(v); combine(v,u); } for (int i = head2[u]; i ; i = query[i].next) { int \u0026amp;v = query[i].to; if (vis[v] \u0026amp;\u0026amp; !query[i].vis) { ans[query[i].num] = father(v); query[i].vis = true; } } } 6. 笛卡尔树 这个不会写, 巨难\n5. 二分图 1. 二分染色 这个算法似乎还是考过的,主要用来判断一个图是否是二分图,还可以顺带做一些操作.看到有某些互斥操作或者两边分的比较明显的就可以考虑二分图相关的东西.染色很简单,暴力遍历一边就结束了.\n题目:\nLuogu P1155. 其实也可以不用二分图.也比较不好想到是二分图 Luogu P1330. 这个比较明显. 蒟蒻表示自己基本只刷过luogu\u0026hellip;没有什么别的题库.tcl\n2. 二分图匹配 这个里面有许多奇奇怪怪的概念:\n定义：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。\n匹配点：匹配边上的两点\n极大匹配(Maximal Matching)：是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。\n最大匹配(maximum matching)：是所有极大匹配当中边数最大的一个匹配,设为M。选择这样的边数最大的子集称为图的最大匹配问题。\n完美匹配（完备匹配）：一个图中所有的顶点都是匹配点的匹配，即2|M| = |V|。完美匹配一定是最大匹配，但并非每个图都存在完美匹配。\n最优匹配：最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，求一个匹配使得匹配边上的权值和最大。一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。（KM（Kuhn and Munkres）算法，是对匈牙利算法的一种贪心扩展。）\n最小覆盖 二分图的最小覆盖分为最小顶点覆盖和最小路径覆盖：\n①最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联\n注：二分图的最小顶点覆盖数=二分图的最大匹配数\n②最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。\n注：二分图的最小路径覆盖数=|V|-二分图的最大匹配数\n最大独立集:最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说最大独立集=|V|-二分图的最大匹配数。最大独立集S 与 最小覆盖集T 互补\n这个当然是抄的\n1. 二分图最大匹配 就是找到最多的匹配个数. 经典模型为稳定婚姻问题.\n二分图匹配本质上是一个网络流问题,只要再左边一列的左边加一个源点,右边一列右边再加一个汇点,跑最大流就好了.但是对于二分图来说其实不必要这个样子,可以简单一点.\n接下来是板子. 其实代码并不是很难, 难在发现这是一个二分图,再把模型建起来.这一点在网络流里面也是一个巨大的问题.233\n算法为匈牙利算法.主要思想就是先随便匹配,遇到有重合的就考虑拆掉原来的,再给原来的重新配一个.知道再也配不到为止.(一个无比凶残的算法)\n// Luogu P3386 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 1e6 + 10; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } int head[maxn], cnt = 1; struct Edge { int to, next; } edge[maxn \u0026lt;\u0026lt; 1]; inline void add_edge(int u, int v) { edge[cnt].next = head[u]; edge[cnt].to = v; head[u] = cnt ++; } int pre[maxn], vis[maxn], tim, ans; int dfs(int u) { for (register int i = head[u]; i; i = edge[i].next) { int \u0026amp; v = edge[i].to; if (vis[v] == tim) continue; //神奇的常数优化,不需要memset了 vis[v] = tim; if (!pre[v] || dfs(pre[v])) { // 自己未被匹配 || 可以腾出一个位置; 这个写得顺序也是一个常数优化 pre[v] = u; // 重新匹配成功 return 1; } } return 0; } int main() { int n = read(), m = read(), e = read(); for (register int i = 1; i \u0026lt;= e; ++ i) { int ui = read(), vi = read(); if (ui \u0026gt; n || vi \u0026gt; m) continue; add_edge(ui, vi); } for (register int i = 1; i \u0026lt;= n; ++ i) { tim ++; if (dfs(i)) ans ++; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 2. 二分图最大带权匹配(最优匹配) 就是给每一个匹配加一个权值,然后求最大匹配,同时使权值最优.\n同样可以跑网络流. 不过主要使KM算法.这个东西可以用,但是似乎从来没有刻意去考过, 估计也暂时不将去考.\n鉴于我自己只是了解大概思想, 板子就没有了.\n6. 各种奇怪算法 1. 差分约束 有一大堆形如 $$ x{i} - x{j} \\leq c_{k} $$ 的不等式, 因为它们长得非常像SPFA / DJ中的三角形不等式, 于是乎可以用图论方法来求解这一堆东西的关系.\n如果出现小于, 就在后面-1就好了, (至于double请自求多福), 如果是大于等于之类的, 打个负号然后考场上现场瞎编就好了.\n如果存在负环, 表明不满足条件 (貌似很多题里面只要有环就不成立, 到时候随机应变就好了)\n如果跑出来是个inf, 就表明没有任何的限制.\ndis的结果就是每一条约束链的最小花费, (一组解?)\n下面是个板子\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 10001; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } struct t_edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; int head[maxn], cnt = 1; inline void add_e(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } int dis[maxn], vis[maxn], flg; int n, m; void spfa(int s) { if (flg) return; vis[s] = 1; for (register int i = head[s]; i; i = edge[i].next) { int v = edge[i].to; if (flg) return; if (dis[v] \u0026lt; dis[s] + edge[i].w) { dis[v] = dis[s] + edge[i].w; if (!vis[v]) spfa(v); else { flg = 1; return; } } } vis[s] = 0; } int main() { n = read(); m = read(); int op, ai, bi, ci; for (register int i = 1; i \u0026lt;= m; ++ i) { op = read(); ai = read(); bi = read(); switch(op) { case 1:{ ci = read(); add_e(bi, ai, ci); break; } case 2: { ci = read(); add_e(ai, bi, -ci); break; } case 3: { add_e(ai, bi, 0); add_e(bi, ai, 0); break; } } } for (register int i = 1; i \u0026lt;= n; ++ i) { spfa(i); if (flg) break; } printf(flg ? \u0026#34;No\\n\u0026#34; : \u0026#34;Yes\\n\u0026#34;); return 0; } 2. 负环 深搜或者SPFA都可以用来判负环\n至于正环, 随便写一写就好了\n上代码\n大法师:\n// luogu-judger-enable-o2 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; const int maxn = 3001; inline int read() { int x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } struct t_edge{ int to, next, w; } edge[maxn \u0026lt;\u0026lt; 1]; int head[maxn], cnt = 1; inline void add_e(int u, int v, int w) { edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt ++; } int dis[maxn], vis[maxn], flg; int n, m; void spfa(int s) { if (flg) return; vis[s] = 1; for (register int i = head[s]; i; i = edge[i].next) { int v = edge[i].to; if (flg) return; if (dis[v] \u0026gt; dis[s] + edge[i].w) { dis[v] = dis[s] + edge[i].w; if (!vis[v]) spfa(v); else { flg = 1; return; } } } vis[s] = 0; } int main() { int t = read(); while (t --) { n = read(); m = read(); int ui, vi, wi; flg = 0; cnt = 1; memset(vis, 0, sizeof(vis)); memset(head, 0, sizeof(head)); memset(dis, 0, sizeof(dis)); for (register int i = 1; i \u0026lt;= m; ++ i) { ui = read(); vi = read(); wi = read(); if (wi \u0026lt; 0) add_e(ui, vi, wi);\telse { add_e(ui, vi, wi); add_e(vi, ui, wi); } } for (register int i = 1; i \u0026lt;= n; ++ i) { spfa(i); if (flg) break; } printf(flg ? \u0026#34;YE5\\n\u0026#34; : \u0026#34;N0\\n\u0026#34;); } return 0; } 百分数:\n#include\u0026lt;bits/stdc++.h\u0026gt; #define IL inline #define RI register int #define N 100086 #define clear(a) memset(a,0,sizeof a) #define rk for(RI i=1;i\u0026lt;=n;i++) using namespace std; IL void read(int \u0026amp;x) { int f=1;x=0;char s=getchar(); while(s\u0026gt;\u0026#39;9\u0026#39;||s\u0026lt;\u0026#39;0\u0026#39;){if(s==\u0026#39;-\u0026#39;)f=-1;s=getchar();} while(s\u0026lt;=\u0026#39;9\u0026#39;\u0026amp;\u0026amp;s\u0026gt;=\u0026#39;0\u0026#39;){x=x*10+s-\u0026#39;0\u0026#39;;s=getchar();} x*=f; } int n,m,T; struct code{int u,v,w;}edge[N]; bool vis[N]; int head[N],tot,dis[N],cnt[N]; IL void add(int x,int y,int z){edge[++tot].u=head[x];edge[tot].v=y;edge[tot].w=z;head[x]=tot;} IL bool spfa(int now) { rk vis[i]=false,dis[i]=2147483647,cnt[i]=false; queue\u0026lt;int\u0026gt;q; q.push(now); vis[now]=true; dis[now]=0; while(!q.empty()) { int u=q.front();q.pop();vis[u]=false; if(cnt[u]\u0026gt;=n)return true; for(RI i=head[u];i;i=edge[i].u) { if(dis[edge[i].v]\u0026gt;dis[u]+edge[i].w) { dis[edge[i].v]=dis[u]+edge[i].w; if(!vis[edge[i].v]) { q.push(edge[i].v); vis[edge[i].v]=true; cnt[edge[i].v]++; if(cnt[edge[i].v]\u0026gt;=n)return true; } } } } return false; } int main() { read(T); while(T--) { read(n),read(m); tot=0;clear(head); for(RI i=1,u,v,w;i\u0026lt;=m;i++) { read(u),read(v),read(w); if(w\u0026lt;0)add(u,v,w); else add(u,v,w),add(v,u,w); } puts(spfa(1)?\u0026#34;YE5\u0026#34;:\u0026#34;N0\u0026#34;); } } 3. 最小环 可以用Floyd来求, 似乎dj也可以做. 不过网上似乎只有Floyd的做法, 于是乎抄写一波.\n4. 反图 这个主要是用来解决不能到达终点的情况的. 很多时候正反跑一遍 或者直接反着跑就会奇迹再现\n5. 欧拉路 6. 哈密顿路 不管了\n7. 倍增 这个可以用来优化图上 / 树上的长度问题. 具体写得话, 随缘了.\n记得不要把数组开太小. 还有这个玩意儿有点耗空间. (不过这几年不卡空间就是了)\n7.一些奇特的东西 1.DFS序和DFS树 咕咕咕\u0026hellip;\n8. 一些奇葩题 POJ3613 看起来是图论题的矩阵快速幂 NOIP2013 华容道: 非常牛逼的一条图论建模 ","date":"2018-11-08T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-2-%E5%9B%BE%E8%AE%BA/","title":"NOIP退役整理 2 图论"},{"content":"NOIP退役整理 3 数据结构 看完保证你, 退役!\n感觉NOIP的数据结构并不是很多的说\u0026hellip;233\n0. 并查集 1. 树状数组 随便贴一个区间加的\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #define re register int #define lowbit(x) (x \u0026amp; -x) const int maxn = 5e5 + 10; typedef long long lld; inline lld read() { lld x = 0, f = 1; char c; while ((c = getchar()) \u0026gt; \u0026#39;9\u0026#39; || c \u0026lt; \u0026#39;0\u0026#39;) if (c == \u0026#39;-\u0026#39;) f = 0; x = c - 48; while ((c = getchar()) \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - 48; return f ? x : ~x + 1; } lld a[maxn], n, m; inline void Add(lld x, lld k) { for (; x \u0026lt;= n; x += lowbit(x)) a[x] += k; } inline lld get(lld x) { lld r = 0; for (; x; x -= lowbit(x)) r += a[x]; return r; } int main() { n = read(); m = read(); lld now, last = 0; for (re i = 1; i \u0026lt;= n; ++ i) { now = read(); Add(i, now - last); last = now; } for (re i = 1; i \u0026lt;= m; ++ i) { lld op = read(), x = read(); if (op == 1) { lld y = read(), k = read(); Add(x, k); Add(y + 1, -k);\t} else { printf(\u0026#34;%lld\\n\u0026#34;, get(x)); }\t} return 0;\t} 2. 线段树 随便写写就好\n3.ST表 主要用来解决RMQ(区间最值问题)的一种算法, 主要思想竟然是动态规划(区间动规)和倍增.支持O(nlog(n))预处理, O(1)查询, 而且常数非常小, 跑得跟记者一样快但是不支持修改,极大地限制了它的运用范围.\n方程: $$ f[i,j] = max(f[i,j-1], f[i + 2^{j-1}, j-1]) \\ 其中f[i,j]表示a[i]到a[2^j-1]区间内的最大值 $$ 求解的时候 $$ k = log_2(r - l + 1)\\ ans = max(f[l, k], f[r - 2^k + 1, k]) $$ 板子\n// 初始化部分 for (log[0] = -1, register int i = 1; i \u0026lt;= n; ++ i) log[i] = log[i \u0026gt;\u0026gt; 1] + 1; //递推log,在询问较多时可以卡卡常 for (register int i = 1; i \u0026lt;= n; ++ i) st[i][0] = dat[i]; //dp初始化 for (register int j = 1; j \u0026lt;= 22; ++ j) { for (register int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; ++ i) { st[i][j] = std::max(st[i][j-1], st[i+(1\u0026lt;\u0026lt;j-1)][j-1]); } } //查询 inline int query_max(const int \u0026amp; l, const int \u0026amp; r) { int k = log[r - l + 1]; return std::max(st[i][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); } 4. 平衡树大法!!! 这个不会用到的. 只是个人兴趣而已\n5. Trie 6. 平板电视(ext/pb_ds/*.hpp) 7. 差分 前缀和 这个玩意儿写得不错, 抄下来了.\n前缀和 1.一维前缀和 对于数组A[], 前缀和SUM[i]表示的就是A[1]+A[2]+…+A[i].\nint init() { for(int i = 1; i \u0026lt;= n; i++) sum[i] = sum[i-1] + a[i]; } int get(int l, int r) { return sum[r] - sum[l-1]; } 2.二维前缀和 对于二维数组, 前缀和SUM[i][k]表示的是所有A[i’][k’](1\u0026lt; = i’\u0026lt;=i,i \u0026lt;= k’\u0026lt;=k)的和.\nint init() { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j]; } } } int get(int x1, int y1, int x2, int y2) { return sum[x1][y1] - sum[x1][y2 - 1] - sum[x2 - 1][y1] + sum[x2 - 1][y2 - 1]; } 3.%k时的优化 （p - q）% k= 0 ==\u0026gt; p % k = q % k 统计q % k 和 p % k 相等的数 详细见T1\n差分 1.一维差分 我们对[L,R]区间进行加num操作，在C[L]处加上num，在C[R+1]处减去num\nvoid init(int l,int r,int num) { dis[l] += num, dis[r + 1] -= num; } int get() { for(int i = 1; i \u0026lt;= n; i++) { val[i] = val[i-1] + dis[i]; } } 2.二维差分 其实也挺简单，和二维前缀和一样\nvoid init(int x1, int y1, int x2, int y2, int num) { sumx1 += num; sumx1 -= num; sumx2 + 1 -= num; sumx2 + 1 += num; } void get() { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= n; j++) { sumi += sumi + sumi-1 - sumi-1; } } } 3.树上差分 (1)点差分 对 u 到 v 的路径上的点 +num 用来求 - 已知路径求树上所有节点被路径覆盖次数\nint init(int u, int v, int num) { dis[u] += num; dis[v] += num; dis[lca(u,v)] -= num; dis[f[lca(u,v)]] -= num; } (2)边差分 对 u 到 v 的路径上的边 +num 用来求 - 已知路径求被所有路径覆盖的边 dis[i] 表示以i节点为儿子的边\nint init(int u, int v, int num) { dis[u] += num; dis[v] += num; dis[lca(u,v)] -= 2 *num; } 最后dfs遍历一遍\nvoid dfs(int x) { for(int i = head[u]; i; i = e[i].next) { int v = e[i].v; if(v != fx) { //fx 为倍增数组 dfs(v); dis[x] += dis[v]; } } } ","date":"2018-11-08T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"NOIP退役整理 3 数据结构"},{"content":"NOIP退役整理 1 数学相关 看完保证你,退役\n这篇笔记里从不写证明\n[TOC]\n0.更加基础的算法 这里贴几个最最最最基础的算法\n1.√n求因数 int cnt = 0, fac[maxn]; inline void get_factor(int x) { for (register int i = 1; i * i \u0026lt;= x; ++ i) { if (x % i == 0) { fac[++ cnt] = i; if (i != x / i) fac[++ cnt] = x / i; } } } 2.gcd int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } 3.√n分解质因数 int cnt = 0; prime[maxn], index[maxn]; inline void prime_factor(int x) { for (register int i = 2; i * i \u0026lt;= n; ++ i) if (x % i == 0) { prime[++ cnt] = i, index[cnt] = 0; while (n % i == 0) x /= i, index[cnt] ++; } if (x \u0026gt; 1) prime[++ cnt] = x, index[cnt] = 1; } 1. 裴蜀定理 (Bezout) $$ ax + by = m $$\n对于这样一个不定方程,当且仅当gcd(a,b) | m的时候,有无数多个整数解.特别的,对于 ax + by = 1, 当且仅当a和b互质时有如上结论.\n另: 对于任意多个未知数和任意多个系数, 这个结论也是成立的. 也就是 $$ a_{1}x_{1} + a_{2}x_{2} + \\cdots + a_{n}x_{n} = d \\\\ 其中d = (a_{1}, a_{2}, \\cdots,a_{n}) $$ 这样一个式子.\n似乎简单的用法就是推出系数和后面的解的关系,然后用gcd或者整数相关的东西瞎搞.\n例题:\nBZOJ 1441. 显然就是推广结论的裸题 \u0026lt;JSOI 2009 瓶子和燃料\u0026gt; 虽然感觉和Bezout没有什么关系\u0026hellip;个人认为,这就是个结论题, 似乎用辗转相减更好理解一点 \u0026lt;HAOI2011 向量\u0026gt; 这个比较难,要多推几步.也是一条Bezout定理.(从某个聚铑博客里发现的题) (这个我不会写) NOIP2014 Day2T3 解方程. 这个似乎就是直接枚举(因为1e6好像可以过去),然后Bezout定理去检验.(话说这题好皮啊\u0026hellip;)(然而我也不会写) 2.拓展欧几里得 (Ex_Gcd) 1.基本内容 这个算是一个比较基础的算法,用来解线性同余方程.\n这个方程大概长这个样子: $$ ax \\equiv b\\pmod {m} $$ 我们需要求整数解.\n把这个玩意儿变个形, 就得到了 $$ ax + my = b $$ 这不就是个二元不定方程吗.这个可以用exgcd来解.显然, 由Bezout定理可知, 如果有整数解,那就一定有无数个这样的解. 当且仅当(a,m) | b时有整数解\n所以在解方程之前需要判定合法. 也就是判断(a, m)|b是否成立.\n先上代码\nvoid ex_gcd(int a, int b, int \u0026amp; d, int \u0026amp; x, int \u0026amp;y) { if (b == 0) { x = 1, y = 0, d = a; } else { ex_gcd(b, a % b, d, y, x); // 划重点. x和y不要打反了 y -= x * (a / b); //这个括号一定要打。否则会先乘溢出 } } 解出来以后,这只是一个解.\n所有的解可以由一种构造方法得到, 也就是通解.\n$$ x_{i} = x_{0} + i * b/(a,m),i\\in Z\\\\ y_{i} = y_{0} - i * b/(a,m),i\\in Z $$\n还有最小整数解:\n$$ x_{min} = (x*b/d \\bmod (m / d) + m / d) \\bmod (m/d) \\\\ 其中d = (a, m); $$\n似乎还可以这么写: (不是很清楚这两个有什么区别) 总而言之,求逆元用下面的,最小整数解用上面的\n$$ x_{min} = (x \\bmod m + m) \\bmod m $$\n2. 中国剩余定理 用来解线性同余方程组.背结论好了.\n$$ 设m_1, m_2, m_3, \\cdots, m_n 是两两互质的数\\\\ 设 m = \\Pi_{i=1}^nm_i\\\\ M_i = \\frac{m}{m_i}\\\\ t_i是同余方程 M_i*t_i \\equiv 1 \\pmod m_i的一个解\\\\ $$\n$$ 则对于任意n个整数a_1,a_2,\\cdots,a_n,\\\\ \\begin{equation} \\left\\{ \\begin{array}{lr} x \\equiv a_1 \\pmod{m_1} \\\\ x \\equiv a_2 \\pmod{m_2} \\\\ \\cdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right. \\end{equation} \\\\ 该方程组有整数解, 为x = \\Sigma_{i=1}^{n}a_iM_it_i $$ 同样的,这也只是一个特解. 最小整数解需要%一下.\n终于到例题了:\nPoj1061 青蛙的约会. 经典老题 NOIP2012 同余方程. 裸的拓欧. 没了. 附赠:一个不错的讲解 3.各种筛 (把你打成筛子) 这个相信大家都很清楚是什么. 就当板子放在这里.\n1.素数筛 inline void get_prime(int n) { memset(vis, 0, sizeof(vis)); int cnt = 0; for (register int i = 2; i \u0026lt;= n; ++ i) { if (!vis[i]) { vis[i] = prime[++ cnt] = i; } for (int j = 1; j \u0026lt;= cnt; ++ j) { if (prime[j] \u0026gt; vis[i] || prime[j] \u0026gt; n / i) break; vis[i * prime[j]] = prime[j]; }\t} } 顺手判素数\ninline bool is_prime(int x) { for (register int i = 1; i * i \u0026lt;= x; ++ i) { if (x % i == 0) { return false; } } return true; } 2.欧拉筛 inline void get_phi(int n) { memset(vis, 0, sizeof(vis)); int cnt = 0; for (register int i = 2; i \u0026lt;= n; ++ i) { if (!vis[i]) { vis[i] = prime[++ cnt] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= cnt; ++ j) { if (prime[j] \u0026gt; vis[i] || prime[j] \u0026gt; n / i) break; vis[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]); }\t} } 求一个phi. 长得和分解质因数一毛一样\nint get_phi(int n) { int ans = n; for (register int i = 2; i * i \u0026lt;= n; ++ i) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n \u0026gt; 1) ans = ans / n * (n - 1); return ans; } 顺便一提, phi(n)表示小于等于n的素数个数\n积性函数什么的反正考不到我也不会,就不管了.\n大概的表是 0, 1, 2, 2, 4, 2, 6, 4, 10 \u0026hellip;\u0026hellip; 这个可以打表想到\n例题: Poj3090.可以由暴力算法观察结果得出,这个是个欧拉函数(反正当时做的时候是打表出来的).至于具体证明,呵呵\n4.逆元 逆元就是用来做除法取模的东西. 一个数处以另一个数等于被除数乘上除数的逆元.(因为在取模的时候,除法不满足结合律, 所以要用逆元)我们有多种方法求逆元,直接给出代码.\n1.exgcd 这个其实就是线性同余方程右边是1的情况下的解, 很明显它是唯一的,而且可以用exgcd解.\nint get_inv(int n, int p) { int x, y, d; ex_gcd(n, p, x, y, d); return (x%p+p)%p; } 复杂度 O(log(n))\n2.费马小定理 这个只有在a,p互素的时候才能用\n由 $$ a^{p-1} \\equiv 1 \\pmod {p}, p是素数 $$ 可以随便瞎推得 $$ inv(i) = i^{p-2} \\pmod{p}, p是素数 $$ 因为用了一个快速幂,所以复杂度是O(log(n))\nint get_inv_fm(int x, int p) { int k = p - 2, ans = 1; x %= p; for (; k; k \u0026gt;\u0026gt;= 1) { if (k \u0026amp; 1) ans = ans * x % p; x = x * x % p; } return ans % p; } 其实还有什么Euler定理,当n垂直于a的时候,a^φ(n) 同余于 1(在模n意义下).这样的玩意儿\n3.线性递推 inline void get_inv_arr(int n, int p){ inv[1] = 1; for (register int i = 2; i \u0026lt;= n; ++ i) { inv[i] =(long long)(p - p/i) * inv[p % i] % p;\t//防溢出 } } 这个没什么好说的,反正不长,背下来就好.\n5.组合相关 1.基本内容 加法, 乘法原理\n排列数\n$$ P_{n}^{m} = \\frac{n!}{(n-m)!} $$\n组合数 $$ C_{n}^{m} = \\frac{n!}{m!(n-m)!} = \\frac{P_{n}^{m}}{m!} $$\n相关计算性质 $$ C_{n}^{m} = C_{n}^{n-m} \\\\ C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1} \\\\ \\Sigma_{i = 0}^{n}C_{n}^{i} = 2^{n} $$\n这些东西可以用来递推或者化简.\n虽然不知道是什么,但是还是写一下多重集的组合数吧233 $$ 对于一个多重集S = {n_{1} * a_{1},n_2*a_2,\\dots,n_k * a_k} \\\\ 设整数r\u0026lt;=n_i(i\\in[1,k]),从S中取出r个元素的不同多重集数量是C_{k+r-1}^{k-1} $$\n有时候需要求组合数,接下来给出相关代码\n求一个组合数\ninline int comb(int n, int m, int p) { int n_1 = 1, m_1 = 1; for (int i = n; i \u0026gt;= n - m + 1; -- i) n_1 = n_1 * i % p; for (int i = m; i \u0026gt;= m; -- i) m_1 = m_1 * i % p; return n_1 * get_inv(m_1, p) % p; //假装我们这里有一个求逆元的函数 } 这个比较慢,O(n)的\n求很多个\n//假设我们有了所有阶乘的取模的值和其逆元的值 return fac[n] * fac_inv[m] * fac[n - m] % p; 二项式定理(杨辉三角形) 就是那个noip2011 day2t1. $$ (a+b)^{n} = \\Sigma_{i = 0}^{n}C_{n}^{i}a^{i}b^{n-i} $$\nfor (register int i = 1; i \u0026lt;= k; ++ i) { comb[i][0] = comb[i][i] = 1; }\tfor (register int i = 2; i \u0026lt;= k; ++ i) { for (register int j = 1; j \u0026lt;= n; ++ j) { comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % hhr; } } 2.Lucas定理 $$ C_{n}^{m} \\equiv C_{n \\bmod p}^{m \\bmod p} * C_{n/p}^{m/p} \\pmod {p} $$\n注意,这里的p是素数, 如果是合数的情况,似乎是可以分解来做. 我给的地址里面有讲到.\n唯一的~~例题似乎是BJZOJ1951的古代猪文.比较难,还要合并线性同余方程组(中国剩余定理).不会写\n带Lucas定理的求组合数. 据说在模数比较大的时候不需要Lucas(来自某位dalao)\ntypedef long long ll; inline ll fast_pow(ll a, ll b, ll \u0026amp;p) { ll ans = 1; a %= p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = ans * a % p; a = a * a % p; } return ans % p; } ll Comb(ll n, ll m, ll \u0026amp;p) { if (m \u0026gt; n) return 0; ll ans = 1; for(register int i = 1; i \u0026lt;= m; ++ i) { ll a = (n - m + i) % p; ll b = i % p; ans = ans * (a * fast_pow(b, p-2, p) % p) % p; // 费马小定理逆元 } return ans; } ll Lucas(ll n, ll m, ll \u0026amp;p) { if (m == 0) return 1; return Comb(n % p, m % p, p) * Lucas(n / p, m / p, p) % p; } 其实还有拓展Lucas定理\u0026hellip;不管了.\n赠送:一个很好的文章\n3.容斥原理 这个东西说简单也很简单, 但是不是非常好说明.那么一大堆数学公式不但难打,而且看着也嫌烦. 举个例子,就是那个高一数学做的集合题, 那个什么参加乒乓球, 篮球还有什么足球的同学一共多少个什么的东西.这个东西在竞赛中的应用大概是把一类计数类问题进行转换,转换成比较便于计算的形式,然后得出结果,通常是什么逆向思维.也有分类之后算总和的时候进行容斥以得出正确的结论.\n因为我自己写得比较烂,理解也非常浅陋,下面贴几个Blog:\n1\n4.隔板法 隔板法就是在n个元素间的(n-1)个空中插入k个板,可以把n个元素分成k+1组的方法.\n这个东西讲起来比较麻烦\u0026hellip;2333继续放blog(其实是我不会)\n1\n6.矩阵相关 矩阵的基本计算就不说了.\n矩阵考的最多的就是用矩阵来加速多项式的递推计算,也就是矩阵快速幂\n1.矩阵快速幂 先上板子\nstruct matrix { ll dat[maxn][maxn]; int n, m; matrix(int sz1, int sz2) : n(sz1), m(sz2) { memset(dat, 0, sizeof(dat)); } inline friend matrix operator + (matrix a, matrix b) { matrix c(a.n, a.m);\tfor (register int i = 1; i \u0026lt;= a.n; ++ i) { for (register int j = 1; j \u0026lt;= a.m; ++ j) { c.dat[i][j] = a.dat[i][j] + b.dat[i][j]; } } return c; } inline friend matrix operator * (matrix a, matrix b) { matrix c(a.n, b.m);\tfor (register int i = 1; i \u0026lt;= c.n; ++ i) { for (register int j = 1; j \u0026lt;= c.m; ++ j) { for (register int k = 1; k \u0026lt;= a.m; ++ k) { c.dat[i][j] = (c.dat[i][j] + a.dat[i][k] * b.dat[k][j] % p) % p; } } } return c; } }; inline matrix fast_pow(matrix a, ll k) { matrix ans(a.n, a.m); for (register int i = 1; i \u0026lt;= ans.n; ++ i) { ans.dat[i][i] = 1; } for (; k; k \u0026gt;\u0026gt;= 1) { if (k \u0026amp; 1) ans = ans * a; a = a * a; } return ans; } 2.矩阵加速递推 对于一个递推式,我们可以把它放在某一个矩阵里面.然后它的每一次递推操作可以使用矩阵运算来解决,套上快速幂就会像记者一样.难点主要在于构建单位矩阵.\n以Fibonacci为例:\n我们有 $$ F[n] = F[n-1] + F[n-2] $$ 然后把它放到一个1*2的矩阵里面(我喜欢横着的) $$ \\left[ \\begin{matrix} F[n-1] \u0026amp; F[n] \\end{matrix} \\right] \\\\ \\left[ \\begin{matrix} F[n-2] \u0026amp; F[n-1] \\end{matrix} \\right] $$ 我们希望从上面一个推到下面一个, 于是乎由于F[n-1] = 0 * F[n-2] + 1 * F[n-1], F[n] = 1 * F[n-1] + 1 * F[n-2],可以得出如下单位矩阵 $$ \\left[ \\begin{matrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 1 \\\\ \\end{matrix} \\right] $$ 我们只要把这个矩阵做上n-1次乘法就可以得到结果了.\n例题很多,就不一一列举了.\n7.线性基(虽然可能不考) 这个比较简单，用来求一堆数异或起来的最值问题。主要的做法就是把这一堆数字的二进制给存起来，然后去一个一个异或。用到了向量的思想，不多说，背板子。\nconst int maxbit = 63; struct linear_base { linear_base() { memset(dat, 0, sizeof(dat)); } long long dat[maxbit + 1]; bool insert(long long n) { for (register int i = maxbit; i \u0026gt;= 0; -- i) { if (n \u0026amp; (1LL \u0026lt;\u0026lt; i)) { if (!dat[i]){ dat[i] = n; break; } n ^= dat[i]; } } return n \u0026gt; 0; } long long get_min() {\tfor (register int i = maxbit; i \u0026gt;= 0; -- i) { if (dat[i]) return dat[i]; } return 0; } long long get_max() { long long ret = 0; for (register int i = maxbit; i \u0026gt;= 0; -- i) { if ((ret ^ dat[i]) \u0026gt; ret) { ret ^= dat[i]; } } return ret; } }; 附赠:一个很好的文章\n8.概率期望(碰到就放弃系列) 1.基本内容 2.期望DP 9.神奇的东西 1.题目收集 Luogu: 斐波那契公约数 gcd(F[n], F[m]) = F[gcd(n,m)] Luogu: P4388 phi 2.GCD相关性质 并不清楚有什么\n3.几个数列 1. Catalan $$ Cat_n = \\frac{C_{2n}^{n}}{n + 1} $$\n几个常见的情况:\n合法括号匹配序列数(n左n右 -\u0026gt; Cat(n)) 合法出栈序列数(n个数 -\u0026gt; Cat(n)) n个节点构成的不同二叉树的数量 给个表:1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012\u0026hellip;\u0026hellip;\n2. Fibonacci 这个就不说了\n3.欧拉函数 前面有\n4.约数个数 4. 数论分块 这个详见余数求和那道题\n5.一些结论 $$ (x + 1)^p \\equiv x^p + 1 \\pmod{p} $$\n可以用来证明Lucas定理(对于OI来说没什么用) $$ 对于a \\perp b, 形如k*a + b的素数有无数个 $$ 虽然不知道有什么用\n10.致谢 百度 cnblogs csdn luogu \u0026lt;算法竞赛进阶指南\u0026gt; \u0026lt;信息学奥赛一本通 提高\u0026gt; \u0026lt;具体数学\u0026gt;\n","date":"2018-11-05T00:00:00Z","permalink":"https://ridethepig.github.io/blog/noip%E9%80%80%E5%BD%B9%E6%95%B4%E7%90%86-1-%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3/","title":"NOIP退役整理 1 数学相关"},{"content":"OI劝退指南 写了6年代码，搞了4年竞赛，终于要到头了。万事终有结束的一天，现在我倒是希望我的竞赛早点结束。我不希望再在自己不喜欢的事情上浪费时间了。总之，撑到今年NOIP就好。结束之后，我决定不再参加任何算法类竞赛，也不接受关于算法竞赛的任何咨询和讨论。\n正如标题所言，这一篇blog是作为一个失败者写给后死者们看的，希望以后的学生们不要盲目地被拉上贼船吧，希望他们能够做真正自己喜欢的事情。\n“后死诸君多努力 ” —— ？？\n回忆 ​\t正所谓殊途同归，每个人都应该有一个不同的开始。至于我，一个被拉上贼船的人，自然不是对竞赛或者是算法感兴趣。在小学的时候，因为非常闲（这也导致我现在每天累的死去活来还考得一塌糊涂），所以天天在打游戏。那时候虽然已经是2011年了，我五年级，但是我还是很喜欢玩C\u0026amp;C系列中的Red Alert 2，一款2000年针对win2000左右系统开发的即时战略游戏。我对它进行了深入的研究，也不再满足于仅仅是在它既有的框架内玩游戏，就开始玩mod，以至于自己想要写一个mod。一开始先改一改配置文件（没错，就是那个rules.ini，玩过的都知道），后来发现这样也太局限了，就顺手接触了编程相关的内容。因为各种原因，我最先学会的，居然是VBS（就是那个windows脚本，天天被用来做无脑病毒）。后来由于要忙小升初，就浪费了一段时间。\n​\t上初一之前，我被拉去参加了一个类似于竞赛预科班一样的东西，于是乎就学会了Pascal和基本的算法。初一开始，学校有NOIP的竞赛，我也顺手去报了名。然而我并不是那么重视这个东西，因为它主要是做题。在做够了八国联军的题目之后，我不想再看到题目。初一的寒假，本校唯一一次和盐城大丰的某个学校联系举行了一次冬令营，在那里我发现了自己的浅薄，那里的学生已经掌握了高阶的算法，基本上是我在高一的时候才会的东西。然而我并没有引起重视。在那里最大的收获是一个学生教练，Tsinghua计算机毕业，当时因为NOI金牌保送的。从他那里我了解了更加广大的计算机世界，比如java，c++，python和php这些语言。于是回来以后我就更无心竞赛，开始学这些东西。初二的时候，莫名其妙地过了初赛，NOIP普及组两日游，拿了个小奖。那年暑假，我才真正认真的开始竞赛，估计那时侯水平还是可以的，够得上提高组的二等奖了。那个暑假，我还开始了对编译器的研究，写出来一个小的解释器demo，可以有控制流和数组。初三的NOIP考得非常惨，因为少打一个空格导致最后一题爆零，错失一等奖。\n​\t中考结束以后，事情很多，就没有再搞竞赛。只是在开学之后突击了一下，就去考了NOIP2017提高，因为没有开long long错失一等奖，非常气，就打算再忙一年。渐渐发现，自己已经跟不上趟了，数学思维的硬伤导致我的动态规划和数学内容非常差，图论和打表暴力还马马虎虎。计算机竞赛已经成为了一块心病，一个包袱，丢不掉，也不想去学，一直到现在，浪费了我不少时间，也没有多大长进，估计也不会有什么好的成果。\n​\t这就是我的故事，6年，也就短短百余字。\n遗憾 ​\t这几年比较后悔的事情，就是没有在NOIP2017以后就退役，以及发现算法竞赛本质太迟了，直到年初我才大概搞明白什么才是我真正想要去学习的。还有就是初中太浪了吧。\n结论 第一个结论是关于算法竞赛本质\n算法竞赛，本质上更加倾向于数学，尤其是离散数学，而且基本超出了高中的范围，和高中课程基本没有什么联系。我作为一个数学渣，能撑这么久，主要还是编程能力在死磕。而且算法就是数学的一个分支，考到的内容一般比较抽象，对审题建模要求也比较高，计算机不过是个工具罢了。单单通过学习算法竞赛，你甚至不能搞懂计算机是怎么工作的，也不要妄想能够写出一个像样的应用。\n第二个结论是关于算法竞赛的优点\n首先可以对编程有一个基本的认识。\n其次可以学到许多离散数学的知识和以后基本用不到的算法（基本上二叉树封顶）\n还有对理科思维也是有一定的作用的\n最后当然是如果考得好（怎么说也得省队吧）的话，可以自主招生\n第三个结论是关于它的缺点\n这个竞赛就像高考一样，是考试。它会挖空心思来为难考生，有许多根本在现实中不存在的巨大数据量和限制，而且很多模型是不切实际的。这个考试还会对学生的代码风格和以后写大型程序的能力造成巨大破坏。最可怕的一点在于，它需要用到电脑（注意我说的这个用词）。这样就比较尴尬了，因为会情不自禁的打开b站，打开qq，打开游戏。。。。etc。\n第四个结论是关于初心和选择\n虽然我不是很喜欢那个包子，但是初心还是非常重要的。我就是一个忘记初心的人，我本来想要做游戏，后来就开始被学竞赛，甚至走偏到了操作系统的歪门邪道上来。我现在比较后悔当时没有毅然决然放弃竞赛，而是为了一些什么去硬撑着，总觉得有点可惜，反而浪费了热情和精力。\n这里还要谈一谈所谓竞赛和工程。竞赛是智力游戏，而工程是荒野求生。竞赛关注算法的方方面面，而工程对效率、空间的要求较低，主要关注正确性，实用性和整体的架构。编程有很多方面，竞赛是给那些计算机科学家和未来的技术大佬准备的。如果立志成为工程师的话，其实不必沉迷过深，算法学到了就行了，竞赛什么的都去死吧。不是说算法不重要，而是真正重要的算法都不难也不多。通用算法就那么几个，剩下的就比较的specific了，它们只解决在特定情况下的某一小类问题。\n第五个，最后一个结论是关于心态\n这个竞赛和其他的竞赛一样，都比较考验智力。总会有那么一些人比你年纪小、能力强，天才层出不穷。不必太放在心上，因为他们本来就是用来仰望的，人还是要看着前面走路。在你看前面的时候，他们早已让别人无法望其项背了，不会太堵你的路的。如果喜欢，就继续做下去吧。不喜欢就尽早放弃，把时间让给真正有意义的事情。\n展望 编程在未来应该是一个常用技能，就像现在的神经网络一样。无奈现在懂得人还是不多。很多情况下，人们还是需要一个比较高级的计算器的。在公司里叫做办公自动化（比如高效excel什么的），在科学研究中是建模的一部分（最流b的计算器之matlab）。编程不一定要参加竞赛，也不只是竞赛。我甚至会建议那些真正想要把编程作为一种爱好的人，真正想要做出一些属于自己的东西的人不要去参加竞赛。考试总是有着巨大限制的。\n在暑假里我参加了一个学校里大佬搞得计算机普及项目，也去讲了一节课。我还是真心希望更多的人能够喜欢编程，也很欢迎和竞赛题无关的算法和技术讨论。\n至于怎么入门和继续学习，我觉得从实践先做起，成就感和热情很重要。然后再去研究一些基本的算法和原理，最后就朝着目标前进吧。\n江苏省扬州中学OI退役\t2017级\txxx\t于\t2018年8月3日晚22时48分\n","date":"2018-08-03T00:00:00Z","permalink":"https://ridethepig.github.io/blog/oi%E5%8A%9D%E9%80%80%E6%8C%87%E5%8D%97/","title":"OI劝退指南"},{"content":"Modern Operating Systems 导读 太懒了不想写小标题 之所以会写这一篇导读，主要是由于自己准备看一看 Windows Internels 这本书，里面据说讲了不少黑科技，比如说Windows10系统基本上是跑在一个虚拟机上什么的，于是乎就准备先补一补操作系统基本理论，翻出了尘封一整个学期的《现代操作系统》这个砖头，开始认真看，并且计划做一些批注，以表示自己曾经读过这本书（自从被强迫做红楼梦的批注之后，就忍不住读书做批注了，啊啊啊啊）。现在的阅读进度大概是前4章结束，之后大概会跳过不少内容，可能会看第5章，略读第8章，再认真看看第11章，基本上就可以结束本次阅读了。说实在的还是想去把本书的第四版略读一下，因为似乎它有讲到云和windows8还有iOS和Android这种比较现代的东西，对我的阅读还是有不少好处的。\n大概说说这本书讲了什么 这本书正如它的标题所说，是一本关于操作系统理论的书，讲得比较的学院派，不过我本来就是要看一些比较理论的东西，毕竟工程里的实现千千万。所以关于OS的东西基本上都讲到了，除了具体实现，比如说历史，设计类型，基本的概念，进程线程，内存管理，文件磁盘，输入输出，甚至还有系统安全和实例分析。有点笼统吧，这是我的基本感觉，不过这个似乎也具体不起来，要不然就要够一架子书了。\n阅读的知识准备 哈哈，终于到了我可以嘲讽他人的地方了，毕竟作为一个OI菜鸡，天天被大佬嘲讽。\n首先是半精通c语言，（c++什么的去死吧，世界上最垃圾的语言），因为几乎所有的OS都是用C写的，指针的概念对于理解十分重要。\n其次是对OS的基本理解，最好Windows和*nix都体验过。最好还懂一点多线程和汇编，读到相关章节的时候就会异常亲切，然后跳过去。\n其实汇编和本书的第3章结合起来读更加有助于理解。对于程序编译、链接和执行的相关机理也可以实现了解一下。\n建议在自己野心勃勃地去写一个dos之前，先读一读这种理论书，不建议边学边做或者是去看代码什么的。另外，书里还有一点点的数学内容和一部分硬件相关，不过问题不是很大。最后就是把算法学学好，什么链表，图论，树都是有涉及到的，不过书中新介绍的算法比这些简单多了，都是一些实用、稳定、平均较优的易于理解的算法。とにかく，Don\u0026rsquo;t Panic。\n读些什么 这是个比较重要的问题，因为这毕竟是这是这一篇主要想要说的东西。hhh。第一遍随便你怎么看，像我一般会来来回回把第一章看个四五回才会真正get determined来读这本书的。第二遍可以通读，比较事无巨细的全都看一遍。这之后就可以以此为基础做一些其他的阅读，或者实践一下，再加深理解之后，可以挑一些来研究研究。里面的基本概念需要比较好的理解和掌握，至于一些算法，就我暂时看下来，只需要知道它们的各自的用途和优缺点就差不多了，不需要具体掌握细节内容。最好一边读一边查一查不知道的内容，可以扩展知识量，还有always留一份英文版，电子的就好，因为会出现垃圾翻译的情况。\n相关推荐 c语言：Primer系列 汇编：《汇编语言》 操作系统：《操作系统设计与实现》（也是本书作者写的）\nLinux内核设计相关内容 其他：编码 | 程序员的基本素养：编译、链接 ","date":"2018-06-01T00:00:00Z","permalink":"https://ridethepig.github.io/blog/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AF%BC%E8%AF%BB/","title":"现代操作系统 导读"}]